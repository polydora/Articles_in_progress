library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)
library(pROC)
library(betareg)



myt <- read.table("data_salinity3.csv", header = T, sep = ";")

myt$Sp [myt$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt$Sp [myt$str <= 0.5] <- "M.edulis"
myt$Sp <- factor(myt$Sp)

# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]


# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)

#Оставляем только данные, на основе, которых строится модель
myt3 <- myt2[myt2$dataset == "testing", ]
myt2 <- myt2[myt2$dataset == "training", ]


myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )


# Частота M.trossulus в популяции, вычисленная как срденее значение structure
freq_MT <- summaryBy( str ~ pop, data = myt2)
names(freq_MT) <- c("pop", "freq_MT")

myt2 <- merge(myt2, freq_MT)

myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)

myt2$Location <- paste(myt2$sea,"_", myt2$sal_place, sep = "") #Перемменная для кодирования четырех выделов



# Регрессионная модель, описывающая связь между долей Т-морфотипа вероятностью встретить M.trossulus в популяции


prop_T_MT <- summaryBy(Sp2 + ind  ~ pop + sea + sal_place, data = myt2, keep.names = T)
names(prop_T_MT)[4:5] <- c("Prop_MT", "Prop_T")

prop_T_MT$Prop_MT_adj <- ifelse(prop_T_MT$Prop_MT == 0, 0.000001, prop_T_MT$Prop_MT)


prop_T <- summaryBy(ind  ~ pop, data = myt2, keep.names = T)
names(prop_T) <- c("pop", "Prop_T")

myt4 <- merge(myt2, prop_T, by = "pop")

# Model_T_MT <- glmer(Sp2 ~ Prop_T*sea*sal_place + (1|pop), data = myt4, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
# 
# drop1(Model_T_MT, test = "Chi")
# 
# 
# Model_T_MT2 <- update(Model_T_MT, .~.-Prop_T:sea:sal_place)
# drop1(Model_T_MT2, test = "Chi")
# 
# Model_T_MT3 <- update(Model_T_MT2, .~.-Prop_T:sal_place)
# drop1(Model_T_MT3, test = "Chi")
# 
# Model_T_MT4 <- update(Model_T_MT3, .~.-Prop_T:sea)
# drop1(Model_T_MT4, test = "Chi")
# 
# Model_T_MT5 <- update(Model_T_MT4, .~.-sea:sal_place )
# drop1(Model_T_MT5, test = "Chi")
# 
# Model_T_MT6 <- update(Model_T_MT5, .~.-sea)
# drop1(Model_T_MT6, test = "Chi")
# 
# Model_T_MT <- Model_T_MT6

Model_T_MT <- betareg(Prop_MT_adj ~ Prop_T + sea*sal_place, data = prop_T_MT)

prop_T_MT$pop[c(5)]


which(cooks.distance(Model_T_MT) == max(cooks.distance(Model_T_MT)))
plot(Model_T_MT)

# Model_T_MT_diagn <- fortify(Model_T_MT)
# 
# ggplot(Model_T_MT_diagn, aes(x = pop, y = .scresid)) + geom_boxplot()


# drop1(Model_T_MT2, test = "Chi")





# Model_T_MT2 <- betareg(Prop_MT_adj ~ Prop_T + sea*sal_place, data = prop_T_MT)  


new_data <- prop_T_MT %>% group_by(sea, sal_place) %>% do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 100)))


predicted <- predict(Model_T_MT, newdata = new_data,  type="response")

new_data$fit <- predicted

# new_data$se <- predicted$se.fit




ggplot(data = new_data, aes(x = Prop_T)) + geom_line(aes(y = fit, color = sal_place, linetype = sea), size = 1) + theme_bw() + geom_point(data = prop_T_MT, aes(x = Prop_T, y = Prop_MT, color = sal_place, shape = sea), size = 4) + labs(x = "Proportion of T-morphotype in population", y = "Proportion of M.trossulus", color = "Freshness")  





########## Калькулятор на основе Симуляций ############


probs_calc_3 <- function(variable = "Location", place = "white_normal", P_MT = 0.5) {
  n <- which(names(myt2) == variable)
  d <- myt2[myt2[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)
  
  P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
  P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
  # P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)
  
  P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
  P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
  # P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)
  
  
  P_MT_T <- (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT))
  P_ME_E <- (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)
  
  c(P_MT_T, P_ME_E)
}




freq_calc <- function(variable = "Location", place = "white_normal"){
  n <- which(names(myt2) == variable)
  d <- myt2[myt2[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)
  # freq_dd
  P_MT_T <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.edulis[2])
  P_ME_E <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])
  P_MT_E <- freq_dd$M.trossulus[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])
  P_ME_T <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.trossulus[2])
  P_T_MT <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])
  P_E_MT <- freq_dd$M.trossulus[1]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])
  P_T_ME <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])
  P_E_ME <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])
  P_MT   <- sum(freq_dd$M.trossulus)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
  
  c(P_MT_T, P_ME_E, P_MT_E, P_ME_T, P_T_MT, P_E_MT, P_T_ME,  P_E_ME, P_MT)
}

freq_calc()






#Вычисляем количество M.trossulus, M.edulis, как выборку из биномиального распределения
N_sim <- function(P_T=0.5, P_MT_T=1, P_ME_E=1, P_MT_E = 0, P_ME_T=0, Ntotal = 1000000){
  N_T <- rbinom(1, Ntotal, P_T) #Извлекаем особей Т морфотипа
  N_MT_T <- N_T*(P_MT_T) #Сколько из них M.trossulus
  # N_E <- rbinom(1, (100000000 - N_T), (1-P_T))
  N_E <- Ntotal - N_T #Сколько осталось Е морфотипа
  N_MT_E <- N_E*(P_MT_E) #Сколько M.trossulus среди Е морфотипа
  N_MT <- N_MT_T + N_MT_E #Общее количество M.trossulus
  N_ME <- Ntotal - N_MT #Остатки - это M.edulis 
  c(N_MT, N_ME)
}


# dd_prop <- rep(NA, 1000)
# 
# for(i in 1:10000) dd_prop[i] <- N_sim()[1]/(N_sim()[1]+N_sim()[2])
# 
# hist(dd_prop)
# 


props <- expand.grid(Prop_T = seq(0, 1, 0.01), sea = c("barents", "white"), sal_place = c("fresh", "normal"))

props$place <- paste(props$sea,"_", props$sal_place, sep = "")



for(i in 1:nrow(props)){
  freq_calc_result <- freq_calc(place = props$place[i])
  props$P_MT_T[i] <- freq_calc_result [1]
  props$P_MT_E[i] <- freq_calc_result [3]
  N_simulated <- N_sim(P_T = props$Prop_T[i], P_MT_T = props$P_MT_T[i], P_MT_E = props$P_MT_E[i])
  props$N_MT [i] <- N_simulated[1]
  props$N_ME [i] <- N_simulated[2]
  props$Prop_MT [i] <- props$N_MT [i]/(props$N_MT [i] + props$N_ME [i])
  props$P_MT_T [i] <- probs_calc_3(place = props$place[i], P_MT = props$Prop_MT[i])[1]  
  props$P_ME_E [i] <- probs_calc_3(place = props$place[i], P_MT = props$Prop_MT[i])[2]  
}   



(Pl_calc <- ggplot(props, aes(x = Prop_T, y = Prop_MT)) + geom_line(color = "black") + facet_grid(sea~sal_place) + geom_line(aes(y=P_MT_T), color = "red", linetype = 2, size = 1) + geom_line(aes(y=P_ME_E), color = "blue", linetype = 2, size = 1) + geom_line(data = new_data, aes(x = Prop_T, y = fit), color = "gray", size = 1) + labs(x="Proportion of T_morphotype", y = "Accuracy") + scale_y_continuous(breaks = seq(0, 1, 0.1), sec.axis = sec_axis(trans = ~., name = "Proportion of M.trossulus") ) + theme_bw() +  scale_x_continuous(breaks = seq(0, 1, 0.1)) + geom_point(data = prop_T_MT, aes(x = Prop_T, y = Prop_MT, color = sal_place, shape = sea))) 













######################

N_sim2 <- function(P_T=0.5, P_MT = 0.5,  P_T_MT, P_E_MT, P_T_ME,  P_E_ME, Ntotal = 1000000){
  N_MT <- rbinom(1,Ntotal, P_MT)
  N_ME <- Ntotal - N_MT
  N_MT_T <- N_MT * P_T_MT * P_T
  N_MT_E <- N_MT * P_E_MT * (1-P_T)
  N_ME_T <- N_ME * P_T_ME * P_T
  N_ME_E <- N_ME * P_E_ME * (1-P_T)
  
  c(N_MT_T, N_MT_E, N_ME_T, N_ME_E)  
  
}




N_sim3 <- function(P_T=0.5, P_MT = 0.5,  P_T_MT, P_E_MT, P_T_ME,  P_E_ME, Ntotal = 1000000){
  N_MT_T <- Ntotal * (P_T_MT * P_MT/(P_T_MT * P_MT + P_T_ME*(1-P_MT)))
  N_MT_E <- Ntotal * (P_E_MT * P_MT/(P_E_MT * P_MT + P_E_ME*(1-P_MT)))
  N_ME_E <- Ntotal * (1-P_T) - N_MT_E
  N_ME_T <- Ntotal * P_T - N_MT_T
  
  c(N_MT_T, N_MT_E, N_ME_T, N_ME_E)  
  
}




props <- expand.grid(Prop_T = seq(0, 1, 0.01), sea = c("barents", "white"), sal_place = c("fresh", "normal"))

props$place <- paste(props$sea,"_", props$sal_place, sep = "")

# i = 1
# c(N_MT_T, N_MT_E, N_ME_T, N_ME_E)  




for(i in 1:nrow(props)){
  freq_calc_result <- freq_calc(place = props$place[i])
  props$P_MT_T[i] <- freq_calc_result[1]
  props$P_ME_E[i] <- freq_calc_result[2]
  props$P_MT_E[i] <- freq_calc_result[3]
  props$P_ME_T[i] <- freq_calc_result[4]
  props$P_T_MT[i] <- freq_calc_result[5]
  props$P_E_MT[i] <- freq_calc_result[6]
  props$P_T_ME[i] <- freq_calc_result[7]
  props$P_E_ME[i] <- freq_calc_result[8]
  props$P_MT[i] <- freq_calc_result[9]
  
  
  N_simulated <- N_sim2(P_T = props$Prop_T[i], P_T_MT = props$P_T_MT[i], P_E_MT = props$P_E_MT[i], P_T_ME = props$P_T_ME[i],  P_E_ME = props$P_E_ME[i], P_MT = props$Prop_T[i])
  props$N_MT [i] <- N_simulated[1] + N_simulated[2] 
  props$N_ME [i] <- N_simulated[3] + N_simulated[4]
  props$Prop_MT [i] <- props$N_MT [i]/(props$N_MT [i] + props$N_ME [i])
  props$P_MT_T [i] <- probs_calc_3(place = props$place[i], P_MT = props$Prop_MT[i])[1]  
  props$P_ME_E [i] <- probs_calc_3(place = props$place[i], P_MT = props$Prop_MT[i])[2]  
}   




(Pl_calc <- ggplot(props, aes(x = Prop_T, y = Prop_MT)) + geom_line(color = "black") + facet_grid(sea~sal_place) + geom_line(aes(y=P_MT_T), color = "red", linetype = 2, size = 1) + geom_line(aes(y=P_ME_E), color = "blue", linetype = 2, size = 1) + geom_line(data = new_data, aes(x = Prop_T, y = fit), color = "gray", size = 1) + labs(x="Proportion of T_morphotype", y = "Accuracy") + scale_y_continuous(breaks = seq(0, 1, 0.1), sec.axis = sec_axis(trans = ~., name = "Proportion of M.trossulus") ) + theme_bw() +  scale_x_continuous(breaks = seq(0, 1, 0.1)) + geom_point(data = prop_T_MT, aes(x = Prop_T, y = Prop_MT, color = sal_place, shape = sea))) 





#######################################

# Внмание! Отсюда, кажись, идет код с верным алгоритмом ############


freq_calc2 <- function(variable = "Location", place = "barents_fresh"){
  n <- which(names(myt2) == variable)
  d <- myt2[myt2[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)

  #Вероятность встретить M,trossulus среди Т морфотипа оценка условной веротяности P_MT|T
  P_MT_T <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.edulis[2])
  
  #Вероятность встретить M.edulis среди E морфотипа
  P_ME_E <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])
  
  #Вероятность встретить M.trossulus среди E морфотипа
  P_MT_E <- freq_dd$M.trossulus[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])

  #Вероятность встретить M.edulis среди T морфотипа
  P_ME_T <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.trossulus[2])

  #Вероятность встретить T морфотп среди M.trossulus морфотипа
  P_T_MT <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])

  #Вероятность встретить E морфотп среди M.trossulus морфотипа
  P_E_MT <- freq_dd$M.trossulus[1]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])

  #Вероятность встретить T морфотп среди M.edulis морфотипа
  P_T_ME <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])
  
  #Вероятность встретить E морфотп среди M.edlis морфотипа
  P_E_ME <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])

  #Вероятность встретить M.trossulus любого морфотипа
  P_MT   <- sum(freq_dd$M.trossulus)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.edulis любого морфотипа
  P_ME   <- sum(freq_dd$M.edulis)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.trossulus T морфотипа
  P_MT_of_T   <- (freq_dd$M.trossulus[2])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
  
  #Вероятность встретить M.trossulus E морфотипа
  P_MT_of_E   <- (freq_dd$M.trossulus[1])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.edulis T морфотипа
  P_ME_of_T   <- (freq_dd$M.edulis[2])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
  
  #Вероятность встретить M.edulis E морфотипа
  P_ME_of_E   <- (freq_dd$M.edulis[1])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить  E морфотип
  P_E   <- sum(freq_dd[1, -1])/sum(freq_dd[,-1])
  
  #Вероятность встретить  T морфотип
  P_T   <- sum(freq_dd[2, -1])/sum(freq_dd[,-1])
  
    
  props <- c(P_MT_T, P_ME_E, P_MT_E, P_ME_T, P_T_MT, P_E_MT, P_T_ME,  P_E_ME, P_MT, P_ME, P_MT_of_T, P_MT_of_E, P_ME_of_T, P_ME_of_E, P_E, P_T)

  names(props) <- c("P_MT_T", "P_ME_E", "P_MT_E", "P_ME_T", "P_T_MT", "P_E_MT", "P_T_ME",  "P_E_ME", "P_MT", "P_ME", "P_MT_of_T", "P_MT_of_E", "P_ME_of_T", "P_ME_of_E", "P_E", "P_T")
  
  props
}




freq_calc2 ()



  P_MT_calc2 <- function(P_T=0.5, P_MT_of_E, P_ME_of_T){
  P_MT <-P_T + (P_MT_of_E - P_ME_of_T)
  P_MT
  
}



props <- expand.grid(Prop_T = seq(0, 1, 0.01), sea = c("barents", "white"), sal_place = c("fresh", "normal"))

props$place <- paste(props$sea,"_", props$sal_place, sep = "")

# i = 1
# c(N_MT_T, N_MT_E, N_ME_T, N_ME_E)  


i = 1

for(i in 1:nrow(props)){
  freq_calc_result <- freq_calc2(place = props$place[i])
  
  P_MT_of_E <-   freq_calc_result [12]
  P_ME_of_T <-  freq_calc_result [13]
  
  props$Prop_MT [i] <- P_MT_calc2(P_T = props$Prop_T[i], P_MT_of_E = P_MT_of_E, P_ME_of_T = P_ME_of_T )
  props$P_MT_T [i] <- probs_calc_3(place = props$place[i], P_MT = props$Prop_MT[i])[1]  
  props$P_ME_E [i] <- probs_calc_3(place = props$place[i], P_MT = props$Prop_MT[i])[2]  
}   
  

 

(Pl_calc <- ggplot(props, aes(x = Prop_T, y = Prop_MT)) + geom_line(color = "black") + facet_grid(sea~sal_place) + geom_line(aes(y=P_MT_T), color = "red", linetype = 2, size = 1) + geom_line(aes(y=P_ME_E), color = "blue", linetype = 2, size = 1) + geom_line(data = new_data, aes(x = Prop_T, y = fit), color = "gray", size = 1) + labs(x="Proportion of T_morphotype", y = "Accuracy")  + theme_bw() +  scale_x_continuous(breaks = seq(0, 1, 0.1)) + geom_point(data = prop_T_MT, aes(x = Prop_T, y = Prop_MT, color = sal_place, shape = sea))  + scale_y_continuous( sec.axis = sec_axis(trans = ~., name = "Proportion of M.trossulus"), limits = c(0,1) )) 



myt3$Sp2 <- ifelse(myt3$Sp == "M.trossulus", 1, 0) 
myt3$congr <- ifelse((myt3$ind == 1 & myt3$Sp == "M.trossulus") | (myt3$ind == 0 & myt3$Sp == "M.edulis"), 1, 0   )


testing_prop_T_MT <- summaryBy(Sp2 + ind  ~ pop + sea + sal_place, data = myt3, keep.names = T)
names(testing_prop_T_MT)[4:5] <- c("Prop_MT", "Prop_T")

testing_prop_correct <- summaryBy(congr  ~ pop + sea + sal_place + Sp, data = myt3, keep.names = T)

testing_prop_correct2 <- merge(testing_prop_T_MT,testing_prop_correct )



Pl_calc + geom_point(data = testing_prop_correct2[testing_prop_correct2$Sp == "M.edulis", ] , aes(x = Prop_T, y = congr), color = "blue") + geom_point(data = testing_prop_correct2[testing_prop_correct2$Sp == "M.trossulus", ] , aes(x = Prop_T, y = congr), color = "red") 


###############################################


# Калькулятор на основе регрессионных моделей и простых баесовских кривых####


probs_calc_3 <- function(variable = "Location", place = "white_normal", P_MT = 0.5) {
  n <- which(names(myt2) == variable)
  d <- myt2[myt2[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)
  
  P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
  P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
  # P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)
  
  P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
  P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
  # P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)
  
  
  P_MT_T <- (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT))
  P_ME_E <- (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)
  
  c(P_MT_T, P_ME_E)
}


props <- expand.grid(Prop_T = seq(0, 1, 0.01), sea = c("barents", "white"), sal_place = c("fresh", "normal"))

props$place <- paste(props$sea,"_", props$sal_place, sep = "")


props$P_MT <- predict(Model_T_MT, newdata = props, type ="response")

for(i in 1:nrow(props)){
  props$P_MT_T [i] <- probs_calc_3(place = props$place[i], P_MT = props$P_MT[i])[1]  
  props$P_ME_E [i] <- probs_calc_3(place = props$place[i], P_MT = props$P_MT[i])[2]
  
}





(Pl_calc <- ggplot(props, aes(x = Prop_T, y = P_MT)) + geom_line(color = "gray") + facet_grid(sea~sal_place) + geom_line(aes(y=P_MT_T), color = "red", linetype = 2) + geom_line(aes(y=P_ME_E), color = "blue", linetype = 2) + geom_line(data = new_data, aes(x = Prop_T, y = fit), color = "black", size = 1) + labs(x="Proportion of T_morphotype", y = "Accuracy") + scale_y_continuous(sec.axis = sec_axis(trans = ~., name = "Proportion of M.trossulus")) + theme_bw()  )




myt3$Sp2 <- ifelse(myt3$Sp == "M.trossulus", 1, 0) 
myt3$congr <- ifelse((myt3$ind == 1 & myt3$Sp == "M.trossulus") | (myt3$ind == 0 & myt3$Sp == "M.edulis"), 1, 0   )



testing_prop_T_MT <- summaryBy(Sp2 + ind  ~ pop + sea + sal_place, data = myt3, keep.names = T)
names(testing_prop_T_MT)[4:5] <- c("Prop_MT", "Prop_T")


testing_prop_T_MT$Prop_MT_predicted <- predict(Model_T_MT, newdata = testing_prop_T_MT,  type="response")

# Соотношение предсказаных и наблюдаемых значений доли M.trossulus

qplot(testing_prop_T_MT$Prop_MT, testing_prop_T_MT$Prop_MT_predicted) + geom_abline() + geom_smooth(method = "lm")



testing_prop_correct <- summaryBy(congr  ~ pop + sea + sal_place + Sp, data = myt3, keep.names = T)

testing_prop_correct2 <- merge(testing_prop_T_MT,testing_prop_correct )

Pl_calc + geom_point(data = testing_prop_correct2[testing_prop_correct2$Sp == "M.edulis", ] , aes(x = Prop_T, y = congr), color = "blue") + geom_point(data = testing_prop_correct2[testing_prop_correct2$Sp == "M.trossulus", ] , aes(x = Prop_T, y = congr), color = "red") 


################################################3


write.table(prop_T_MT, "clipboard", sep = "\t")


