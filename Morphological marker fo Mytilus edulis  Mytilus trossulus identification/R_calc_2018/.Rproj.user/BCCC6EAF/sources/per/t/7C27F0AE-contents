---
title: "Reliability of Mytilus edulis and M. trossulus identification by semi-diagnostic conchological character varies between oceanic and estuarine habitats across Kola Peninsula (White Sea, Barents Sea)."
author: 
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning = FALSE, message = FALSE)
library(knitr)

```

<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }
td {  /* Table  */
  font-size: 20px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>



## Модель, описывающая связь между Частотой Т-морфотипа и частотой MT

```{r, results='hide'}
library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)
library(pROC)
library(betareg)
library(lmtest)
library(broom)


myt <- read.table("data_salinity3.csv", header = T, sep = ";")

myt <- myt[myt$dataset != "overseas", ]

myt$Sp [myt$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt$Sp [myt$str <= 0.5] <- "M.edulis"
myt$Sp <- factor(myt$Sp)

# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]





# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)



# Бинарное обозначение видов

myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)


#Correct identification
myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )


# Частота M.trossulus в популяции, вычисленная как срденее значение structure

freq_MT <- summaryBy( str ~ pop, data = myt2)
names(freq_MT) <- c("pop", "freq_MT")

myt2 <- merge(myt2, freq_MT)

# Подразделяем дмнные на три сабсета

myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "fresh"] <- "Barents_fresh" 
myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "normal"] <- "Barents_normal" 
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "normal"] <- "White" 
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "fresh"] <- "White" 



#Оставляем только данные, на основе, которых строится модель
myt3 <- myt2[myt2$dataset == "testing", ]
myt2 <- myt2[myt2$dataset == "training", ]


# myt2 %>% group_by(Subset) %>% summarise(n_pop = length(unique(pop)))


myt3 %>% group_by(Subset) %>% summarise(n_pop = length(unique(pop)))



# Соотношение доли Т-морфотипа и доли MT в каждой из популяций
prop_T_MT <-  myt2 %>% group_by(Subset, pop) %>% do(data.frame(Prop_MT = mean(.$Sp2), N_MT = sum(.$Sp2 == 1), N_ME = sum(.$Sp2 == 0),  Prop_T = mean(.$ind), N_T = sum(.$ind ==  1), N_E = sum(.$ind == 0))) 
  
  
prop_T_MT_testing <-  myt3 %>% group_by(Subset, pop) %>% do(data.frame(Prop_MT = mean(.$Sp2), N_MT = sum(.$Sp2 == 1), N_ME = sum(.$Sp2 == 0),  Prop_T = mean(.$ind), N_T = sum(.$ind ==  1), N_E = sum(.$ind == 0))) 


# prop_T_MT$prop_MT_adj <-prop_T_MT$prop_MT



# prop_T_MT$prop_MT_adj[prop_T_MT$prop_MT_adj == 0] <- 0.00000001 # Это нужно, так как бета-распределение не включает 0 и 1 в область определения.


# Model_T_MT <- betareg(prop_MT_adj ~ Prop_T*sea*sal_place, data = prop_T_MT) 
# 
# Model_T_MT <- glmer(Sp2 ~ Prop_T*sea*sal_place + (1|pop), data = myt2, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5))) 

################################
```

```{r, results='hide'}

myt2_analysis <- merge(myt2, prop_T_MT)

Model_T_MT <- glm(Sp2 ~  Prop_T*Subset, data = myt2_analysis, family = binomial(link = "logit"))



# plot(Model_T_MT_final)
overdisp_fun <- function(model) {
    rdf <- df.residual(model)  # Число степеней свободы N - p
    if (inherits(model, 'negbin')) rdf <- rdf - 1 ## учитываем k в NegBin GLMM
    rp <- residuals(model,type='pearson') # Пирсоновские остатки
    Pearson.chisq <- sum(rp^2) # Сумма квадратов остатков, подчиняется Хи-квадрат распределению 
    prat <- Pearson.chisq/rdf  # Отношение суммы квадратов остатков к числу степеней свободы
    pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE) # Уровень значимости
    c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)        # Вывод результатов
}


overdisp_fun(Model_T_MT)





drop1(Model_T_MT, test = "Chi")


Model_T_MT_2 <- update(Model_T_MT, .~.-Prop_T:Subset)

drop1(Model_T_MT_2, test = "Chi")

# Model_T_MT_3 <- update(Model_T_MT_2, .~.-Prop_T:sea)
# 
# drop1(Model_T_MT_3, test = "Chi")

Model_T_MT_final <- Model_T_MT_2 
# Model_T_MT_4 <- update(Model_T_MT_3, .~.-Prop_T:sal_place)
# 
# drop1(Model_T_MT_4, test = "Chi")
# 
# Model_T_MT_5 <- update(Model_T_MT_4, .~.-sea:sal_place )
# 
# drop1(Model_T_MT_5, test = "Chi")
# 
# Model_T_MT_6 <- update(Model_T_MT_5, .~.-sea )
# 
# drop1(Model_T_MT_6, test = "Chi")
# 
# Model_T_MT_7 <- update(Model_T_MT_6, .~.-sal_place )
# 
# drop1(Model_T_MT_7, test = "Chi")



```



Анализ девиансы для начальной модели

```{r}
tidy(Anova(Model_T_MT))

```

Модель можно упростить.


Сравнение финальной и начальной модели


```{r}


# Model_T_MT2 <- betareg(prop_MT_adj ~ Prop_T + sea*sal_place, data = prop_T_MT)  
# 
# Model_T_MT3 <- betareg(prop_MT_adj ~ Prop_T + sea + sal_place, data = prop_T_MT)  
# 
# AIC(Model_T_MT, Model_T_MT2, Model_T_MT3)

lrtest(Model_T_MT, Model_T_MT_final)
     
```

Существенных различий между полной и сокращенной моделями нет.

Вот анализ девиансы для сокращенной модели.

```{r}
tidy(Anova(Model_T_MT_final))
```

Ниже приведены коэффициенты этой модели, пользуясь которыми можно предсказать долю M.trossulus в популяции в зависимости от доли T-морфотипа (надо только помнить, что эти коэффициенты в шкале логитов).  

```{r}


Model_T_MT_final_result <- tidy(Model_T_MT_final)

Model_T_MT_final_result$estimate <- round(Model_T_MT_final_result$estimate, 1)
Model_T_MT_final_result$std.error <- round(Model_T_MT_final_result$std.error, 2)
Model_T_MT_final_result$statistic <- round(Model_T_MT_final_result$statistic, 2)
Model_T_MT_final_result$p.value <- round(Model_T_MT_final_result$p.value, 4)




kable(Model_T_MT_final_result, col.names = c("Model term", "Estimated value", "SE", "Chi sq.", "p-value"))

```

Согласно этим результатам, связь между долей T-морфотипа и долей M.trossulus в популяции описывается следующими уравнениями.

В Баренцевом море опресненный участок (базовый уровень): $P_{MT} = \frac{e^{-2.1 + 5.2P_T}}{1+e^{-2.1 + 5.2P_T}}$


В Белом море : $P_{MT} = \frac{e^{-2.5 + 5.2P_T}}{1+e^{-2.5 + 5.2P_T}}$


В Баренцевом море неопресненный участок:$P_{MT} = \frac{e^{-3.9 + 5.2P_T}}{1+e^{-3.9 + 5.2P_T}}$



Я считаю, что эти уравнения надо эксплицитно привести в статье, так как это то, по чему можно высчитывать данные для калькулятора максмально основанного на первичных данных. 

Важно! проверь значения кожффициентов. Сделай это независимо (просто посичтай на бумажке, исходя из таблицы), так как я пишу между дел и боюсь ошибиться. 


## Визуализация модели


```{r}

new_data <- prop_T_MT %>% group_by(Subset) %>% do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 100)))

predicted <- predict(Model_T_MT_final, newdata = new_data,  type="response", se.fit = TRUE)

new_data$fit <- predicted$fit  
new_data$SE <- predicted$se.fit  


# ggplot(prop_T_MT, aes(x = Prop_T, y = prop_MT_adj, color = sal_place)) + geom_point(aes(color = sal_place)) + facet_grid( ~ sea) + geom_line(data = new_data, aes(x = Prop_T, y = fit, group = sal_place), size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population", y = "Proportion of M.trossulus", color = "Freshness")

new_data$Subset <- factor(new_data$Subset, levels = c("White", "Barents_fresh", "Barents_normal"))
  
ggplot(data = new_data, aes(x = Prop_T, y = fit, linetype = Subset))  + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE, fill = Subset),  alpha = 0.2) + geom_line(size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population (PT)", y = "M.trossulus prevalence (MTprev)") + geom_abline() + geom_point(data = prop_T_MT, aes(x = Prop_T, y = Prop_MT, shape = Subset), size = 2) + geom_point(data = prop_T_MT_testing, aes(x = Prop_T, y = Prop_MT), shape = 21, size = 4, fill = "white") + facet_wrap( ~ Subset, ncol = 3) + theme(legend.position = "bottom") + guides(shape = "none")
```


Подумай, может лучше привести резльтаты вот так. Здесь лучше видно поведение отдельных выборок. 


Впрочем, можно привести и вот такую картинку.

```{r}
ggplot(data = new_data, aes(x = Prop_T, y = fit, linetype = Subset))  + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE, fill = Subset),  alpha = 0.2) + geom_line(size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population", y = "Proportion of M.trossulus") + geom_abline() + geom_point(data = prop_T_MT, aes(x = Prop_T, y = Prop_MT, shape = Subset), size = 2) + geom_point(data = prop_T_MT_testing, aes(x = Prop_T, y = Prop_MT), shape = 21, size = 4, fill = "white") 
```


Logistic models fitted for different data subsets. Solid black curve (black squares) - White Sea; dotted black curve(black circles) - freshened Barents sea ;  dotted curve(black triangles) - Barents Sea with normal salinity. Black stight diagonal line - Y = X line, correspondet to equivalence between proporton of T-morfotypes and proportion of M.trossulus.     



## ROC-анализ

ROC-анализ позволяет оценить величину диагностической силы прзнака. Этот анализ позволяет оценить насколько используемый признак (в нашем случае морфотип) позволяет идентифицировать бинарные классы (*M.trossulus* (positive outcome) vs *M.edulis* (negative outcome)).

```{r} 

#ROC-анализ для каждого выдела
library(pROC)


myt2$Location <- myt2$Subset #Перемменная для кодирования трех выделов


ROC_white <- roc(Sp ~ ind, data = myt2[myt2$Location =="White", ], ci = TRUE)

# ROC_curve_white_fresh <- data.frame(sensitivity = ROC_white_fresh$sensitivities, specif = ROC_white_fresh$specificities, sea = "white", sal_place = "fresh") 

# ROC_white_normal <- roc(Sp ~ ind, data = myt2[myt2$Location =="white_normal", ], ci = TRUE)
# ROC_curve_white_normal <- data.frame(sensitivity = ROC_white_normal$sensitivities, specif = ROC_white_normal$specificities, sea = "white", sal_place = "normal") 


ROC_barents_normal <- roc(Sp ~ ind, data = myt2[myt2$Location =="Barents_normal", ], ci = TRUE)
# ROC_curve_barents_normal <- data.frame(sensitivity = ROC_barents_normal$sensitivities, specif = ROC_barents_normal$specificities, sea = "barents", sal_place = "normal") 


ROC_barents_fresh <- roc(Sp ~ ind, data = myt2[myt2$Location =="Barents_fresh", ], ci = TRUE)
# ROC_curve_barents_fresh <- data.frame(sensitivity = ROC_barents_fresh$sensitivities, specif = ROC_barents_fresh$specificities, sea = "barents", sal_place = "fresh") 



# #ROC-кривые, вычисленные специализированной функцией
# ROC_curves <- rbind(ROC_curve_white_fresh, ROC_curve_white_normal, ROC_curve_barents_fresh, ROC_curve_barents_normal)
# 




# Сравнение AUC для разных сабсетов

# roc.test(ROC_barents_normal, ROC_barents_fresh, paired = FALSE)
# roc.test(ROC_barents_normal, ROC_white, paired = FALSE)
# roc.test(ROC_barents_fresh, ROC_white, paired = FALSE)



```

ROC-анализ позволяет вычислять доверительные интервалы , что позволяет нарисовать вот  такую картинку. 

```{r}
ROC_result <- data.frame(Subset = c("White", "Barents_fresh", "Barents_normal"),  CI_low = NA, AUC = NA, CI_up = NA)

ROC_result[1, 2:4] <- as.numeric(ROC_white$ci)
ROC_result[2, 2:4] <- as.numeric(ROC_barents_fresh$ci)
ROC_result[3, 2:4] <- as.numeric(ROC_barents_normal$ci)

ggplot(ROC_result, aes(x = Subset, y = AUC)) + geom_col(fill = "blue") + geom_errorbar(aes(ymin = CI_low, ymax = CI_up), width = 0.2) + geom_hline(yintercept = 0.5, linetype = 2) + theme_bw() + geom_text(aes(y = c(0.9,  0.9, 0.7), label = c("a", "a", "b")))
```


Видно, что везде, кроме баренцевоморской части с нормальной соленостью, дискриминирующая сила морфотипа практически одинакова и достаточно высока (около 0.8). 

**NB!** В условиях с нормальной соленостью в Баренцевом море AUC = 0.5 не входит в доверительный интервал, что говорит о том, что даже и в этих условиях по язычку определение значимо отличается от простого подбрасывания монетки.






## Вероятность корректной идентификации видов

Согласно расширенной теореме Байеса, определение видов по морфотипам может происходить лишь с определненой веротяностью. При этом условная вероятность для данной мидии быть определнной, как M.trossulus, если мы знаем что она имеет T-морфотип ($P(MT|T)$) может быть описана следующим уравннеием.

$P(MT|T) = \frac{P(T|MT)P(MT)}{P(T|MT)P(MT) + P(T|ME)P(ME)}$ (Eq 1)

Аналогично для мидий, имеющих E-морфотип, вертяность отнесения к виду M.edulis описывается следующем уравнением

$P(ME|E) = \frac{P(E|ME)P(ME)}{P(E|ME)P(ME) + P(E|MT)P(MT)}$ (Eq 2)

где

$P(MT|T)$ - вероятность быть M.trossulus если мидия имеет T-морфотип

$P(ME|E)$ - вероятность быть M.edulis если мидия имеет E-морфотип 

$P(T|MT)$ - вероятность встретить T-морфотип среди M.trossulus

$P(E|ME)$ - вероятность встретить E-морфотип среди M.edulis

$P(MT)$ - вероятность встретить M.trossulus

$P(ME)$ - вероятность встретить M.edulis


К сожалению, взять и просто рассчитать подобные вероятности нельзя по двум причинами. Во-первых, оценки $P(MT)$ и $P(ME)$ основаны на *не*независимых выборках.  Из-за того, что наши пробы сгруппированы переменной `pop`в оценке вероятности могут проявляться локальные эффекты, смещающие вероятности. Во-вторых, диагностическая ценность морфологического признака может варьировать в связи с какими-то переменным (географические выделы, соленость и т.п.). 

В связи с этим необходимо построить "феноменологическую" модель, описывающую поведение эмпирических данных. При этом модель должна характеризовать взаимосвязь $P(MT|T)$ (аналогично для $P(ME|E)$) не только с $P(MT)$ (или $P(ME) = 1 - P(MT)$), но и с другими предикторами, которые потенциально могут играть роль в изменении характера этой связи -- это `Subset`. Модель должна включать случайный фактор `pop`, который определяет внутриклассовые корреляции в выборках.


## Модель

Для дальнейшего построения модели мы введем переменную `congr` (от "congruence"), которая принимает значение 1 если мидия имеет T-морфотип и относится к M.trossulus или имеет E-морфотип и относится к M.edulis.  В остальных случаях она приобретает значение 0. Эта переменная характеризует событие правильного определения вида по морфотипу. Модель должна описывать поведение вероятности этого события от следующих предикторов:
- доля M.trossulus в популяции (`freq_MT`) 
- морфотип (`morph`)
- `Subset`
- Все взаимодействия предикторов.  


### Строим собственно модель

```{r}
myt2_reduced <- myt2

# myt2_reduced <- myt2[!(myt2$pop %in% c("nm", "padan", "umba_06", "umba_bridge", "umba_pioner", "vor2")), ]
# unique(myt2$pop)

Mod_fT_congr <- glmer(congr ~ morph * freq_MT*Subset + (1 | pop), data = myt2_reduced, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

```




```{r, results='hide'}
# Проверка на сверхдисперсию
overdisp_fun(Mod_fT_congr)
```




```{r, results='hide'}
drop1(Mod_fT_congr, test = "Chi")

Mod_fT_congr2 <- update(Mod_fT_congr, .~.-morph:freq_MT:Subset )
drop1(Mod_fT_congr2, test = "Chi")

# Mod_fT_congr3 <- update(Mod_fT_congr2, .~.-freq_MT:sal_place )
# drop1(Mod_fT_congr3, test = "Chi")
# 
# Mod_fT_congr4 <- update(Mod_fT_congr3, .~.-sea:sal_place)
# drop1(Mod_fT_congr4, test = "Chi")
# 
# Mod_fT_congr5 <- update(Mod_fT_congr4, .~.-morph:sea)
# drop1(Mod_fT_congr5, test = "Chi")

Mod_fT_congr_fin <- Mod_fT_congr2

```



```{r}
AIC(Mod_fT_congr,Mod_fT_congr_fin)
```

Сокращенная модель лучше полной. 


### Финальная модель 

Вот анализ девиансы для финальной модели.

```{r}
Anova(Mod_fT_congr_fin)
```


Вот коэффциенты для полученной модели (приводится фиксированная часть)

```{r}
tidy(Mod_fT_congr_fin)
```

Может быть здесь тоде надо привести формулы логистических кривых, которые можно использовать для вычисления вероятностей P(MT|T) и P(ME|E). Таких формул будет 6. Надо подумать, может быть свести их все в одну таблицу вместе с формулами здя связи P(T) с P(MT)


## Визуализация модели


```{r}
newdata <- myt2_reduced %>% group_by(Subset, morph) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))

# Предсказанные значеня в шкале вероятностей
newdata$fit <- predict(Mod_fT_congr_fin, newdata = newdata, type = "response", re.form = NA) 

# Предсказанные значеня в шкале логитов
newdata$fit_eta <- predict(Mod_fT_congr_fin, newdata = newdata, re.form = NA) 

# Вычисление доверительного инеравала

# formula((Mod_fT_congr_fin)) 

X <- model.matrix(  ~ morph + freq_MT + Subset + morph:freq_MT + 
    morph:Subset + freq_MT:Subset, data = newdata) #Модельная матрица для визуализации


# Ошибки в шкале логитов
newdata$se_eta <- sqrt(diag(X %*% vcov(Mod_fT_congr_fin) %*% t(X)))

logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация

# Границы доверительных интервалов в масштабах вероятностей
newdata$lwr <- logit_back(newdata$fit_eta - 2 * newdata$se_eta)
newdata$upr <- logit_back(newdata$fit_eta + 2 * newdata$se_eta)

# newdata$lwr <- probit_back(newdata$fit_eta - 2 * newdata$se_eta)
# newdata$upr <- probit_back(newdata$fit_eta + 2 * newdata$se_eta)


Pl_fit <- ggplot(newdata, aes(x = freq_MT)) + geom_density(data = myt2, aes(x = freq_MT, , y=..scaled.., fill = morph), alpha = 0.2, adjust = 3, trim = TRUE, color = "white") + geom_ribbon(aes(y = fit, ymin = lwr, ymax = upr, group = morph), alpha = 0.2)  + geom_line(aes(y = fit, color = morph), size=1) + facet_wrap( ~ Subset) + geom_rug(data = myt2) + scale_color_manual(values = c("blue", "red")) + scale_fill_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification \n PPV and NPV", x = "M.trossulus prevalence \n (MTprev)", color = "Morphotype") + theme(legend.position = "bottom")

Pl_fit

```

Поскольку данная модель предсказывает вероятность корректного определения для индивидуальной мидии, у которой переменная отклика может принимать значение только 1 или 0, то представить первичные данные на этом графике сложно. Поэтому в качестве прокси для первичных данных мы можем изобразить точки, отражающие доли корректных определений в отдельных популяциях в зависимости от доли M.trossulus в данной популяции.  


```{r}
correct_prop <- myt2_reduced %>% group_by(Subset,  pop, morph) %>%  do(data.frame(Prop_correct = mean(.$congr), freq_MT = mean(.$freq_MT) ))


Pl_fit_init_data <- Pl_fit + geom_point(data = correct_prop, aes(x = freq_MT, y = Prop_correct, color = morph), size = 1)

Pl_fit_init_data
```


На данном графике можно нанести кривые, соответствующие условным вероятностям, основанным на оценках 
$P(T|MT)$, $P(E|ME)$, $P(MT)$ и $P(ME) = 1 - P(MT)$ для каждого сабсета.

```{r}


# Функция для вычисления условных вероятностей

probs_calc <- function(variable = "Subset", place = "White") {
  n <- which(names(myt2_reduced) == variable)
  d <- myt2_reduced[myt2_reduced[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)

  P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
  P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
  # P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)

  P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
  P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
  # P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)


  probs <- data.frame(P_MT = seq(0, 1, 0.01), P_MT_T = NA, P_ME_E = NA)

  probs$P_MT_T <- with(probs, (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT)))
  probs$P_ME_E <- with(probs, (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)  )

  probs[,4] <- place
  names(probs)[4] <- variable
  probs

}



probs_all <- rbind(probs_calc(place = "White"), probs_calc(place = "Barents_fresh"), probs_calc(place = "Barents_normal") )
# 
# probs_all$sea <- ifelse(probs_all$Location == "white_normal" | probs_all$Location == "white_fresh", "white", "barents") 
# 
# probs_all$sal_place <- ifelse(probs_all$Location == "barents_normal" | probs_all$Location == "white_normal", "normal", "fresh") 


########################### Вычисление таблицы со всеми показателями для регионов

probs_calc_3 <- function(variable = "Subset", place = "White", P_MT = 0.5) {
  n <- which(names(myt2_reduced) == variable)
  d <- myt2_reduced[myt2_reduced[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)
  
  P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
  P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
  # P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)
  
  P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
  P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
  # P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)
  
  
  P_MT_T <- (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT))
  P_ME_E <- (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)
  
  c(P_MT_T, P_ME_E)
}



freq_calc2 <- function(variable = "Subset", place = "Barents_fresh"){
  n <- which(names(myt2_reduced) == variable)
  d <- myt2_reduced[myt2_reduced[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)

  #Вероятность встретить M,trossulus среди Т морфотипа оценка условной веротяности P_MT|T
  P_MT_T <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.edulis[2])
  
  #Вероятность встретить M.edulis среди E морфотипа
  P_ME_E <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])
  
  #Вероятность встретить M.trossulus среди E морфотипа
  P_MT_E <- freq_dd$M.trossulus[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])

  #Вероятность встретить M.edulis среди T морфотипа
  P_ME_T <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.trossulus[2])

  #Вероятность встретить T морфотп среди M.trossulus морфотипа
  P_T_MT <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])

  #Вероятность встретить E морфотп среди M.trossulus морфотипа
  P_E_MT <- freq_dd$M.trossulus[1]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])

  #Вероятность встретить T морфотп среди M.edulis морфотипа
  P_T_ME <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])
  
  #Вероятность встретить E морфотп среди M.edlis морфотипа
  P_E_ME <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])

  #Вероятность встретить M.trossulus любого морфотипа
  P_MT   <- sum(freq_dd$M.trossulus)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.edulis любого морфотипа
  P_ME   <- sum(freq_dd$M.edulis)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.trossulus T морфотипа
  P_MT_of_T   <- (freq_dd$M.trossulus[2])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
  
  #Вероятность встретить M.trossulus E морфотипа
  P_MT_of_E   <- (freq_dd$M.trossulus[1])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.edulis T морфотипа
  P_ME_of_T   <- (freq_dd$M.edulis[2])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
  
  #Вероятность встретить M.edulis E морфотипа
  P_ME_of_E   <- (freq_dd$M.edulis[1])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить  E морфотип
  P_E   <- sum(freq_dd[1, -1])/sum(freq_dd[,-1])
  
  #Вероятность встретить  T морфотип
  P_T   <- sum(freq_dd[2, -1])/sum(freq_dd[,-1])
  
    
  props <- c(P_MT_T, P_ME_E, P_MT_E, P_ME_T, P_T_MT, P_E_MT, P_T_ME,  P_E_ME, P_MT, P_ME, P_MT_of_T, P_MT_of_E, P_ME_of_T, P_ME_of_E, P_E, P_T)

  names(props) <- c("P_MT_T", "P_ME_E", "P_MT_E", "P_ME_T", "P_T_MT", "P_E_MT", "P_T_ME",  "P_E_ME", "P_MT", "P_ME", "P_MT_of_T", "P_MT_of_E", "P_ME_of_T", "P_ME_of_E", "P_E", "P_T")
  
  props
}


All_freq <- data.frame(Barents_normal = freq_calc2(place = "Barents_normal"), 
                       Barents_fresh = freq_calc2(place = "Barents_fresh"),
                       White = freq_calc2(place = "White"))


tAll_freq <- as.data.frame(t(All_freq))
tAll_freq$Location <- rownames(tAll_freq)

###########################


#### Вводится коррекция в соответствии с тем, что P_MT_T = congr_T/P_T

newdata$Location <- newdata$Subset

newdata_and_freq <- merge(newdata, tAll_freq, by = "Location")

newdata_and_freq$fit_corrected <- ifelse(newdata_and_freq$morph == "T_m",newdata_and_freq$fit / newdata_and_freq$P_T, newdata_and_freq$fit / (1 - newdata_and_freq$P_T) )



Pl_fit_corrected <- ggplot(newdata_and_freq, aes(x = freq_MT, y = fit_corrected)) + geom_line(aes(color = morph), size=1) + facet_grid(sea ~ sal_place) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification", x = "Proportion of M.trossulus", color = "Morphotype") + theme(legend.position = "bottom")
 
 
 

Pl_fit_init_data_bayes <- Pl_fit_init_data + geom_line(data = probs_all, aes(x = P_MT,  y = P_MT_T), color = "red", linetype = 2) + geom_line(data = probs_all, aes(x = P_MT,  y = P_ME_E), color = "blue", linetype = 2)
Pl_fit_init_data_bayes
```





```{r}
correct_prop_test <- myt3 %>% group_by(Subset,  pop, morph) %>%  do(data.frame(Prop_correct = mean(.$congr), freq_MT = mean(.$freq_MT) ))

Pl_fit_init_data_bayes_test <- Pl_fit_init_data_bayes + geom_point(data = correct_prop_test, aes(x = freq_MT, y = Prop_correct, color = morph), size = 3)

# 
# All_freq$Probability_type <- row.names(All_freq)
# All_freq_melt <- melt(All_freq, variable.name = "Subset", value.name = "P")
# All_freq_melt$P <- round(All_freq_melt$P, 2)
# 
# All_freq_melt <- All_freq_melt[All_freq_melt$Probability_type %in% c("P_T_MT", "P_E_MT", "P_T_ME", "P_E_ME"), ]
# 
# All_freq_melt$X <- rep(c(0.4, 0.6), 3, each = 2)
# All_freq_melt$Y <- rep(c(0.1, 0.2), 6)

freq <- as.data.frame(table(myt2_reduced$Sp2, myt2_reduced$ind, myt2_reduced$Subset))

freq$Var1 <- ifelse(freq$Var1 == "1", "MT", "ME")
freq$Var2 <- ifelse(freq$Var2 == "1", "T", "E")

All_freq_melt <- melt(freq,  id.vars = c("Var1", "Var2", "Var3") )

names(All_freq_melt)[3] <- "Subset"
names(All_freq_melt)[1] <- "Genotype"
names(All_freq_melt)[2] <- "Morphotype"



All_freq_melt$Y <- rep(c(0.1, 0.2), each = 2, 3)

All_freq_melt$X <- rep(c(0.65, 0.5), 6)

lab <- data.frame(Subset = rep(c("Barents_fresh", "Barents_normal", "White"), each = 2))
lab$labs <- rep(c("MT", "ME"), 3)
lab$X = rep(c(0.5, 0.65), 3)
lab$Y <- 0.25

lab2 <- data.frame(Subset = rep(c("Barents_fresh", "Barents_normal", "White"), each = 2))
lab2$labs <- rep(c("T", "E"), 3)
lab2$Y = rep(c(0.2, 0.1), 3)
lab2$X <- 0.4


Pl_fit_init_data_bayes + geom_rect(aes(xmin = 0.35, xmax = 0.75, ymin = 0.05, ymax = 0.29), fill = "white", color = "black") + geom_text(data =  All_freq_melt, aes(x=X, y=Y, label = value), size = 3) +  geom_text(data =  lab, aes(x=X, y=Y, label = labs), size = 3) + geom_text(data =  lab2, aes(x=X, y=Y, label = labs), size = 3) 

```

Probability of correct identification of individual mussels using their morphotype. Blue solid curves - logistic regression fitted for E-morphotypes observed, solid red curves - the same for T-morphotypes; Small red and blue dots - observed proportion of correct species identification for two morphotypes in particula populations included into analysis. Large dots - proportion of corect identification in testing data set. Dotted curves - theoretical bayesian curves for $P(MT|T)$ and $P(ME|E)$ calculated as functions of proportion of M.trossulus in population. 



```{r}


Prop_T_test <-  myt3 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(ind))

Prop_T_test$freq_MT <- predict(Model_T_MT_final, newdata = Prop_T_test, type = "response")

myt3_test <- data.frame(Subset = myt3$Subset, morph = myt3$morph, pop = myt3$pop, str = myt3$str)

myt3_test_all <- merge(myt3_test, Prop_T_test)


myt3_test_all$Predicted <- predict(Mod_fT_congr_fin, newdata = myt3_test_all, type = "response", re.form = NA)

myt3_test_all$str_predicted <- ifelse(myt3_test_all$morph == "T_m", myt3_test_all$Predicted, (1-myt3_test_all$Predicted))

myt3_test_all$Sp_observed <- ifelse(myt3_test_all$str >= 0.5, 1, 0)

library("jmuOutlier")

Cors_str_predicted <- myt3_test_all %>% group_by(Subset) %>% summarise(Cor = cor(str_predicted, str, method = "spearman"), p = perm.cor.test(str_predicted, str, method = "spearman")[[4]])

myt3_test_all_stat <- myt3_test_all %>% group_by(Subset, pop, morph, str_predicted) %>% summarise(Median_str = median(str))

ggplot(myt3_test_all_stat, aes(x = str_predicted, y = Median_str)) + geom_point(size = 4, shape = 21, aes(fill = morph)) + facet_wrap(~Subset) + geom_abline() + theme_bw() + scale_fill_manual(values = c( "blue", "red")) + labs(x = "Predicted probability to be identified as M.trossulus", y = "Median of observed Structure scores", fill = "Morphotype") + geom_text(data = Cors_str_predicted, aes(x = 0.1, y = 0.9, label = paste("Cor = ",round(Cor, 2), ", p-value = ", round(p *2, 4)) ), hjust = "inward") + theme(legend.position = "bottom")

# 
# Mod_correctness_test <- glmer(Sp_observed ~ str_predicted*Subset + (1|pop), data = myt3_test_all, family = binomial(link = "logit"))
# 
# # overdisp(Mod_correctness_test)
# 
# # drop1(Mod_correctness_test, test = "Chi")
# 
# 
# 
# newdata <- myt3_test_all %>% group_by(Subset) %>% do(data.frame(str_predicted = seq(min(.$str_predicted), max(.$str_predicted), length.out = 100)))
# 
# # Предсказанные значеня в шкале вероятностей
# newdata$fit <- predict(Mod_correctness_test, newdata = newdata, type = "response", re.form = NA) 
# 
# # Предсказанные значеня в шкале логитов
# newdata$fit_eta <- predict(Mod_correctness_test, newdata = newdata, re.form = NA) 
# 
# # Вычисление доверительного инеравала
# 
# # formula((Mod_fT_congr_fin)) 
# 
# X <- model.matrix(  ~ str_predicted*Subset, data = newdata) #Модельная матрица для визуализации
# 
# 
# # Ошибки в шкале логитов
# newdata$se_eta <- sqrt(diag(X %*% vcov(Mod_correctness_test) %*% t(X)))
# 
# logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация
# 
# # Границы доверительных интервалов в масштабах вероятностей
# newdata$lwr <- logit_back(newdata$fit_eta - 2 * newdata$se_eta)
# newdata$upr <- logit_back(newdata$fit_eta + 2 * newdata$se_eta)
# 
# # newdata$lwr <- probit_back(newdata$fit_eta - 2 * newdata$se_eta)
# # newdata$upr <- probit_back(newdata$fit_eta + 2 * newdata$se_eta)
# 
# freq_MT_test <- myt3_test_all %>% group_by(Subset, pop, morph, str_predicted) %>% summarise(freq_MT = mean(Sp_observed))
# 
# ggplot(newdata, aes(x = str_predicted, y = fit)) + 
#   geom_ribbon(aes(ymin = lwr, ymax = upr, group = Subset), alpha = 0.2) + 
#   geom_line(size=1) + 
#   geom_point(data = freq_MT_test, aes(x = str_predicted,  y = freq_MT, color = morph), size = 4 ) +
#   facet_wrap( ~ Subset)  + 
#   scale_color_manual(values = c("blue", "red"))+
#   geom_abline()+
#   theme_bw() + 
#   xlim(0,1)  +
#   labs(x = "Predicted probability to be MT", y = "Observed probability to be MT") + theme(legend.position = "bottom")
# 
# 
# 



```






