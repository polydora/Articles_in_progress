---
title: "Reliability of Mytilus edulis and M. trossulus identification by semi-diagnostic conchological character varies between oceanic and estuarine habitats across Kola Peninsula (White Sea, Barents Sea)."
author: 
date: '20 января 2019 г '
abstract: "Cryptic blue mussel species (unambiguous identification by multilocus genotypes only) Mytilus edulis (МЕ) and M. trossulus (МТ) co-occur along coasts of Kola Peninsula (the White Sea, salinity up to 25 ppt, the Barents Sea, salinity up to 35 ppt). Previous studies revealed morphological differences between species in the White Sea: the majority of MT bear an uninterrupted dark prismatic strip under the ligament on the inner side of the shell (Т-morphotype) while the majority of ME lack this character (E-morphotype). The main goal of our study was to find out whether morphological differences between ME and MT persist in populations along the Barents Sea coast, and to develop practical recommendations for mussel species identification by morphotype. We also analyzed congruence between species and morphotype in limited collections of ME and MT from other regions of the Ocean where two species co-occur. In the Barents Sea estuaries (salinity as in the Whites Sea) differences in morphotype frequencies between МЕ and МТ were nearly as large as in the White Sea (65 % and 77%, correspondingly). In more oceanic habitats differences were much lower (41% on average, due to the increased frequency of Т-morphotypes among ME). For the areas where conchological character was in a good agreement with species genotype, relationships between frequency of T-morphotype in a population sample, expected frequency of МЕ and МТ, and accuracy of individual mussel identification by its morphotype are provided.  Analyses of overseas material revealed that there are some prospects for use of the character for species identification in Western Atlantics (and Scotland?), but not in Western Norway and the Baltic Sea."
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE)
library(knitr)

```

<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }
td {  /* Table  */
  font-size: 20px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>











Давай по порядку.    
Мы пытаемся выяснить можем ли мы определить вид, обладая знанием о язычке.  Или что то же самое с какой вероятностью мы можем узнавать по T-морфотипу (по наличию язычка) M.trossulus, а по E-морфотипу (отсутствию язычка) M.edulis. Или иными словами, если у нас в руке мидия T-морфотипа, то с какой вероятностью она является M.trossulus.

<br>
Это называется ***условная вероятность***: $P(MT|T)$ или $P(ME|E)$.

<br>
Про условные вероятности можно посмотреть, вот здесь, например: 

<https://ru.wikipedia.org/wiki/Теорема_Байеса>

Там пример №3 ровненько наш случай.




Согласно теореме Байеса

$P(MT|T) = \frac{P(T|MT)P(T)}{P(T|MT)P(T) + P(T|ME)P(ME)}$

$P(ME|E) = \frac{P(E|ME)P(E)}{P(E|ME)P(E) + P(E|MT)P(MT)}$

где

$P(MT|T)$ - вероятность быть M.trossulus если мидия имеет T-морфотип (язычковая)

$P(ME|E)$ - вероятность быть M.edulis если мидия имеет E-морфотип (безъязычковая)

$P(T|MT)$ - вероятность встретить T-морфотип среди M.trossulus

$P(E|ME)$ - вероятность встретить E-морфотип среди M.edulis

$P(T)$ - вероятность встретить M.trossulus

$P(E)$ - вероятность встретить M.edulis


Соответственно, зависимость вероятности корректного определения будет иметь совсем иной вид, нежели ты мне рисовал в экселе.

Для примера возьмем группу популяций, под названием kola_cut.
```{r}

library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)



# Подготовка данных

myt <- read.table("data_salinity2.csv", header = T, sep = ",")

myt$Sp [myt$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt$Sp [myt$str <= 0.5] <- "M.edulis"
myt$Sp <- factor(myt$Sp)


myt$sal_place <- factor(myt$sal_place, levels = c("low", "meadle", "high")) 
myt$sal_place2 <- ifelse(myt$sal_place == "low", "fresh", "normal") 



myt2 <- myt[!is.na(myt$size), ]

myt2 <- myt2[!is.na(myt2$ind), ]


# переменная congr - это событие правильного определения 1 если T-морфотип совпадает с MT и E-морфотип совпадает с ME, 0 - если не свопадает

myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )



ind_pop <-summaryBy(ind ~ pop, data = myt2) 

names(ind_pop) <- c("pop", "freq_Tmorph")

myt2 <- merge(myt2, ind_pop, by = "pop")


myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)

myt2$place2 <- factor(myt2$place2, levels = c( "kand_cut" , "kand_main", "kola_cut"  ,  "kola_tuva", "kola_dz"))

d <- myt2[myt2$place2 == "kola_cut", ]

dd <- melt(table(d$Sp, d$morph))
freq_dd <- dcast(data = dd, formula = Var1 ~ Var2)

freq_dd$P_E <- round(with(data = freq_dd, E_m/(E_m + T_m)), 2)
freq_dd$P_T <- round(with(data = freq_dd, T_m/(E_m + T_m)), 2)



kable(freq_dd, col.names = c("Вид", "E-морфотип", "T-морфотип", "P(E)", "P(T)"))



```

Теперь построим график, который отражает связь искомых вероятностей $P(MT|T)$ и $P(ME|E)$ с вероятностью встретить M.trossulus (или M.edulis) в популяции.


```{r}
probs <- data.frame(P_MT = seq(0, 1, 0.1), P_MT_T = NA, P_ME_E = NA)

probs$P_MT_T <- with(probs, (freq_dd$P_T[2]*P_MT)/(freq_dd$P_T[2]*P_MT + freq_dd$P_T[1]*(1-P_MT)))

probs$P_ME_E <- with(probs, (freq_dd$P_E[1]*(1-P_MT))/(freq_dd$P_E[1]*(1-P_MT) + freq_dd$P_E[2]*P_MT))


```

Вот табличные данные. Проверь, пожалуйста в экселе, не ошибся ли я.

```{r}
kable(probs, col.names = c("Вероятность встретить M.trossulus (доля MT в популяции)", "Верояность быть MT для особи с морфотипом T", "Верояность быть ME для особи с морфотипом E"))

```

А вот график.

```{r}
min_MT <- min(d$freq_MT)
max_MT <- max(d$freq_MT)
ggplot(probs, aes(x = P_MT)) + geom_line(aes(y = P_MT_T), color = "red") + geom_line(aes(y = P_ME_E), color = "blue" ) + labs(x = "Доля MT в популяции", y = "Вероятность корректного определения") + theme_bw()

# + geom_vline(xintercept = c(min_MT, max_MT), linetype = 2) 

```

Красная линия отражает вероятность корректного определения M.trossulus по T-морфотипу.
Синяя линия отражает вероятность корректного определения M.edulis по E-морфотипу.


## Теперь посмотрим на регрессионные модели
ВНИМАНИЕ! Далее, по оси OX откладывается частота M.trossulus в популяции, а вовсе не частота T-морфотипа в популяции, как это было в предыдущем репорте!






```{r}
props <- summaryBy(freq_Tmorph + freq_MT  ~ pop + place2, data = myt2)

```


На всякий случай проверяем на наличие мультиколлинеарности предикторов. 

```{r}
vif(glm(congr ~ morph + place2 + freq_MT, family = "binomial", data = myt2))

```

Здесь есть легкий ахтунг, связанный с тем, что  `freq_MT` и место (`place2`) взаимосвязаны. Это не eсть хорошо. Идеально было бы, чтобы в каждом месте была бы полная линейка  `freq_MT`.

<br>
Вот так выглядит модель

```{r, echo=TRUE}
Mod_fT_congr <- glmer(congr ~ morph * place2 * scale(freq_MT)  + (1 | pop), data = myt2, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

```


```{r}
Anova(Mod_fT_congr)
# summary(Mod_fT_congr)
```




## Диагностика

Можешь не смотреть, иди вниз к визуализации.

```{r, message=FALSE, warning=FALSE}
overdisp(Mod_fT_congr)


Mod_fT_congr_diagn <- fortify(Mod_fT_congr)


ggplot(Mod_fT_congr_diagn, aes(x = .fitted, y = .scresid, color = sea)) + geom_point() + geom_smooth()


ggplot(Mod_fT_congr_diagn, aes(x = size, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "lm")


ggplot(Mod_fT_congr_diagn, aes(x = sea, y = .scresid)) + geom_boxplot() 

ggplot(Mod_fT_congr_diagn, aes(x = Sp, y = .scresid)) + geom_boxplot() 

ggplot(Mod_fT_congr_diagn, aes(x = place2, y = .scresid)) + geom_boxplot() 

ggplot(Mod_fT_congr_diagn, aes(x = sal_place, y = .scresid)) + geom_boxplot() 

ggplot(Mod_fT_congr_diagn, aes(x = morph, y = .scresid)) + geom_boxplot() 

ggplot(Mod_fT_congr_diagn, aes(x = sal_low, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "lm")

ggplot(Mod_fT_congr_diagn, aes(x = freq_MT, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "lm")


ggplot(Mod_fT_congr_diagn, aes(x = str, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "lm")



```






## Визуализация модели 

```{r}
newdata <- myt2 %>% group_by(place2, morph) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))

newdata$fit <- predict(Mod_fT_congr, newdata = newdata, type = "response", re.form = NA) 

newdata$fit_eta <- predict(Mod_fT_congr, newdata = newdata, re.form = NA) 


X <- model.matrix(  ~ morph *place2 * freq_MT , data = newdata)



b <- fixef(Mod_fT_congr)



newdata$se_eta <- sqrt(diag(X %*% vcov(Mod_fT_congr) %*% t(X)))

logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация



newdata$lwr <- logit_back(newdata$fit_eta - 2 * newdata$se_eta)
newdata$upr <- logit_back(newdata$fit_eta + 2 * newdata$se_eta)



Pl_fit <- ggplot(newdata, aes(x = freq_MT, y = fit)) + geom_ribbon(aes(ymin = lwr, ymax = upr, group = morph), alpha = 0.2)  + geom_line(aes(color = morph)) + facet_wrap( ~ place2) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1) + geom_hline(yintercept = 0.5, linetype = 2 ) + labs(y = "Probability of correct identification") + theme(legend.position = "bottom")

```


```{r}
correct_prop <- summaryBy(congr + freq_MT  ~ pop + place2 + morph, data = myt2)

Pl_fit_init_data <- Pl_fit + geom_point(data = correct_prop, aes(x = freq_MT.mean, y = congr.mean, color = morph)) + labs(x = "MT frequency in population")
Pl_fit_init_data

```


## Наносим на графики нулевую модель

```{r}


probs_calc <- function(place) {
  d <- myt2[myt2$place2 == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var1 ~ Var2)
  freq_dd$P_E <- round(with(data = freq_dd, E_m/(E_m + T_m)), 2)
  freq_dd$P_T <- round(with(data = freq_dd, T_m/(E_m + T_m)), 2)
  probs <- data.frame(P_MT = seq(0, 1, 0.01), P_MT_T = NA, P_ME_E = NA)

  probs$P_MT_T <- with(probs, (freq_dd$P_T[2]*P_MT)/(freq_dd$P_T[2]*P_MT + freq_dd$P_T[1]*(1-P_MT)))

  probs$P_ME_E <- with(probs, (freq_dd$P_E[1]*(1-P_MT))/(freq_dd$P_E[1]*(1-P_MT) + freq_dd$P_E[2]*P_MT))
  probs$place2 <- place
  probs
}


probs_all <- rbind(probs_calc("kand_cut"), probs_calc("kand_main"), probs_calc("kola_cut"), probs_calc("kola_tuva"), probs_calc("kola_dz"))

probs_all$place2 <- factor(probs_all$place2, levels = c( "kand_cut" , "kand_main", "kola_cut"  ,  "kola_tuva", "kola_dz"))



Pl_fit_init_data + geom_line(data = probs_all, aes(x = P_MT,  y = P_MT_T), color = "red", linetype = 2) + geom_line(data = probs_all, aes(x = P_MT,  y = P_ME_E), color = "blue", linetype = 2)


```

Согласись, поведение эмпирических данных, которое в "усредненном"" виде описывает линия регрессии, вполне согласуется с тем, что должно быть в случае нулевой модели. Однако в некоторых акваториях степень отклонения достаточно велика. Почему так, давай думать. 

О степени несогласованности эмпирической линии регрессии и нулевой модели можно было бы судить по выходу линии нулевой модели за пределы доверительного интервала (серая область). Однако не стоит сейчас придавать большое значение тем случаям, когда нулевая модель выходит за его пределы. Довертельные интервалы сейчас вычслены достаточно грубо. Лучше бы их вычислять параметрическим бут-стрепом. Но это уже потом, когда я смогу тебя убедить в том, что я не занимаюсь  **черной магией**.    




## Про сложные и простые модели

Чтобы потешить твою паранойю по поводу того, как соотносятся графики, в которых все данные в одной модели, с графиками, где для каждого места подобрана отдельная модель, приведу пять графиков, где каждая из линий регрессии подобрана для отдельного участка независимо. Это совсем неправильно, но может это тебя убедит, что я не занимаюсь **злым колдунством**. Надеюсь, что сходство результатов трудно отрицать. 

Почему так делать неправильно? Потому что фактор `place` играет важную роль и вероятность корректного определения в разных местах отличается. Рассматривая все акватории в отдельности мы не сможем сделать этот вывод.  Если он не важен, так и скажи. Есть и другие причины, по которым этого делать нельзя (например, множественные сравнения, которые порождаются большим количеством моделей, приводят к тому, что вычисленным уровням значимости доверять уже нельзя). 




```{r}


plot_bad <- function(place_select){
myt3 <- myt2 [myt2$place2 == place_select, ]

Mod_fT_congr_bad1 <- glm(congr ~ morph * scale(freq_MT), data = myt3, family = "binomial")

newdata2 <- myt3 %>% group_by(morph) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))
newdata2$fit <- predict(Mod_fT_congr_bad1, newdata = newdata2, type = "response")
newdata2$fit_eta <- predict(Mod_fT_congr_bad1, newdata = newdata2, re.form = NA) 
X <- model.matrix(  ~ morph * freq_MT , data = newdata2)
b <- coef(Mod_fT_congr_bad1)

newdata2$se_eta <- sqrt(diag(X %*% vcov(Mod_fT_congr_bad1) %*% t(X)))
newdata2$lwr <- logit_back(newdata2$fit_eta - 2 * newdata2$se_eta)
newdata2$upr <- logit_back(newdata2$fit_eta + 2 * newdata2$se_eta)

Pl_fit_bad <- ggplot(newdata2, aes(x = freq_MT, y = fit)) + geom_ribbon(aes(ymin = lwr, ymax = upr, group = morph), alpha = 0.2)  + geom_line(aes(color = morph)) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1) + geom_hline(yintercept = 0.5, linetype = 2 ) + labs(y = "") + theme(legend.position = "bottom")

Pl_fit_bad + geom_line(data = probs_all[probs_all$place2 == place_select,], aes(x = P_MT,  y = P_MT_T), color = "red", linetype = 2) + geom_line(data = probs_all[probs_all$place2 == place_select,], aes(x = P_MT,  y = P_ME_E), color = "blue", linetype = 2) + ggtitle(place_select)
}

Pl1 <- plot_bad("kand_cut")
Pl2 <- plot_bad("kand_main")
Pl3 <- plot_bad("kola_cut")
Pl4 <- plot_bad("kola_tuva")
Pl5 <- plot_bad("kola_dz")

library(cowplot)
plot_grid(Pl1, Pl2, Pl3, Pl4, Pl5, ncol = 3)

```



$$
 
$$




