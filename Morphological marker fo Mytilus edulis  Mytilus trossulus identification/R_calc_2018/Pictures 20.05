---
title: "Reliability of Mytilus edulis and M. trossulus identification by semi-diagnostic conchological character varies between oceanic and estuarine habitats across Kola Peninsula (White Sea, Barents Sea)."
author: 
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning = FALSE, message = FALSE)
library(knitr)

```

<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }
td {  /* Table  */
  font-size: 20px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>





## Применимость морфологического маркера для идентификации генотипов


```{r}
library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)
library(pROC)
library(betareg)



myt <- read.table("data_salinity3.csv", header = T, sep = ",")

myt$Sp [myt$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt$Sp [myt$str <= 0.5] <- "M.edulis"
myt$Sp <- factor(myt$Sp)

# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]


# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)

#Оставляем только данные, на основе, которых строится модель
myt3 <- myt2[myt2$dataset == "testing", ]
myt2 <- myt2[myt2$dataset == "training", ]


myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )


# Частота M.trossulus в популяции, вычисленная как срденее значение structure
freq_MT <- summaryBy( str ~ pop, data = myt2)
names(freq_MT) <- c("pop", "freq_MT")

myt2 <- merge(myt2, freq_MT)

myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)





prop_T_MT <- summaryBy(Sp2 + ind  ~ pop + sea + sal_place, data = myt2, keep.names = T)
names(prop_T_MT)[4:5] <- c("prop_MT", "Prop_T")

prop_T_MT$prop_MT_adj <-prop_T_MT$prop_MT
prop_T_MT$prop_MT_adj[prop_T_MT$prop_MT_adj == 0] <- 0.00000001 # Это нужно, так как бета-распределение не включает 0 и 1 в область определения.


# Model_T_MT <- betareg(prop_MT_adj ~ Prop_T*sea*sal_place, data = prop_T_MT) 

Model_T_MT <- glm(prop_MT ~ Prop_T*sea*sal_place, data = prop_T_MT, family = binomial(link = "logit")) 

drop1(Model_T_MT, test = "Chi")


Model_T_MT_2 <- update(Model_T_MT, .~.-Prop_T:sea:sal_place)

drop1(Model_T_MT_2, test = "Chi")

Model_T_MT_3 <- update(Model_T_MT_2, .~.-Prop_T:sea)

drop1(Model_T_MT_3, test = "Chi")

Model_T_MT_4 <- update(Model_T_MT_3, .~.-Prop_T:sal_place)

drop1(Model_T_MT_4, test = "Chi")

Model_T_MT_5 <- update(Model_T_MT_4, .~.-sea:sal_place )

drop1(Model_T_MT_5, test = "F")

```



Вот анализ девиансы для этой модели. 


```{r}
Anova(Model_T_MT)

```

Эту модель явно нужно упростить. Вот такая получилась упрощенная модель. 



```{r}
library(lmtest)

Model_T_MT2 <- betareg(prop_MT_adj ~ Prop_T + sea*sal_place, data = prop_T_MT)  

Model_T_MT3 <- betareg(prop_MT_adj ~ Prop_T + sea + sal_place, data = prop_T_MT)  

AIC(Model_T_MT, Model_T_MT2, Model_T_MT3)

lrtest(Model_T_MT, Model_T_MT3)
```

Существенных различий между полной и сокращенной моделями нет.

Вот анализ девиансы для сокращенной модели.

```{r}
Anova(Model_T_MT3)
```

Ниже приведены коэффициенты этой модели, пользуясь которыми можно предсказать долю M.trossulus в популяции в зависимости от доли T-морфотипа (надо только помнить, что эти коэффициенты в шкале логитов).  

```{r}
summary(Model_T_MT3)

```


Важная особенность полученной модели: коэффициент, связывающий долю T-морфотипа с вероятностью встретить M.trossulus не изменяется от моря к морю и от одних условий солености к другим. Это говорит о том, что при увеличении частоты T-морфотипа на одну единицу веротяность встретить M.trossulus возрастает в одно и то же количество раз в любом из морей. 

## Визуализация модели


```{r}

new_data <- prop_T_MT %>% group_by(sea, sal_place) %>% do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 100)))

new_data$fit <- predict(Model_T_MT_5, newdata = new_data,  type="response")


# ggplot(prop_T_MT, aes(x = Prop_T, y = prop_MT_adj, color = sal_place)) + geom_point(aes(color = sal_place)) + facet_grid( ~ sea) + geom_line(data = new_data, aes(x = Prop_T, y = fit, group = sal_place), size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population", y = "Proportion of M.trossulus", color = "Freshness")

  
ggplot(prop_T_MT, aes(x = Prop_T, y = prop_MT_adj, color = sal_place)) + geom_point(aes(color = sal_place))+ geom_line(data = new_data, aes(x = Prop_T, y = fit, color = sea, linetype = sal_place), size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population", y = "Proportion of M.trossulus", color = "Freshness") 

plot(Model_T_MT_5)


```


Согласно этим результатам, связь между долей T-морфотипа и долей M.trossulus в популяции описывается следующими уравнениями.

В Белом море неопресненный   участок: $P_{MT} = \frac{e^{-3.1 + 5.8P_T}}{1+e^{-3.1 + 5.8P_T}}$

В Белом море опресненый участок: $P_{MT} = \frac{e^{-3.1 + 5.9P_T}}{1+e^{-3.1 + 5.9P_T}}$


В Баренцевом море неопресненный участок:$P_{MT} = \frac{e^{-4.3 + 5.9P_T}}{1+e^{-4.3 + 5.9P_T}}$

Б Баренцевом море опресненный участок: $P_{MT} = \frac{e^{-2.3 + 5.9P_T}}{1+e^{-2.3 + 5.9P_T}}$


## Часть 2. ROC-анализ

Поскольку предыдущий анализ выявил роль солености и моря, то диагностическую силу морфологического признака надо проводить отдельно для каждого выдела. ROC-анализ позволяет оценить величину диагностической силы прзнака. Этот анализ позволяет оценить насколько используемый признак (в нашем случае морфотип) позволяет идентифицировать бинарные классы (*M.trossulus* (positive outcome) vs *M.edulis* (negative outcome)).

```{r, echo=TRUE} 

#ROC-анализ для каждого выдела
library(pROC)


myt2$Location <- paste(myt2$sea,"_", myt2$sal_place, sep = "") #Перемменная для кодирования четырех выделов


ROC_white_fresh <- roc(Sp ~ ind, data = myt2[myt2$Location =="white_fresh", ], ci = TRUE)

# ROC_curve_white_fresh <- data.frame(sensitivity = ROC_white_fresh$sensitivities, specif = ROC_white_fresh$specificities, sea = "white", sal_place = "fresh") 

ROC_white_normal <- roc(Sp ~ ind, data = myt2[myt2$Location =="white_normal", ], ci = TRUE)
# ROC_curve_white_normal <- data.frame(sensitivity = ROC_white_normal$sensitivities, specif = ROC_white_normal$specificities, sea = "white", sal_place = "normal") 


ROC_barents_normal <- roc(Sp ~ ind, data = myt2[myt2$Location =="barents_normal", ], ci = TRUE)
# ROC_curve_barents_normal <- data.frame(sensitivity = ROC_barents_normal$sensitivities, specif = ROC_barents_normal$specificities, sea = "barents", sal_place = "normal") 


ROC_barents_fresh <- roc(Sp ~ ind, data = myt2[myt2$Location =="barents_fresh", ], ci = TRUE)
# ROC_curve_barents_fresh <- data.frame(sensitivity = ROC_barents_fresh$sensitivities, specif = ROC_barents_fresh$specificities, sea = "barents", sal_place = "fresh") 


# #ROC-кривые, вычисленные специализированной функцией
# ROC_curves <- rbind(ROC_curve_white_fresh, ROC_curve_white_normal, ROC_curve_barents_fresh, ROC_curve_barents_normal)
# 


```

ROC-анализ позволяет вычислять доверительные интервалы , что позволяет нарисовать вот  такую картинку. 

```{r}
ROC_result <- data.frame(sea = rep(c("white", "barents"), each = 2), sal_place = rep(c("fresh", "normal"), 2), CI_low = NA, AUC = NA, CI_up = NA)

ROC_result[1, 3:5] <- as.numeric(ROC_white_fresh$ci)
ROC_result[2, 3:5] <- as.numeric(ROC_white_normal$ci)
ROC_result[3, 3:5] <- as.numeric(ROC_barents_fresh$ci)
ROC_result[4, 3:5] <- as.numeric(ROC_barents_normal$ci)

ggplot(ROC_result, aes(x = sal_place, y = AUC)) + geom_col(fill = "blue") + geom_errorbar(aes(ymin = CI_low, ymax = CI_up), width = 0.2) + facet_wrap(~sea) + geom_hline(yintercept = 0.5, linetype = 2) + labs(x = "Salinity condition") + theme_bw()
```


Видно, что везде, кроме баренцевоморской части с нормальной соленостью, дискриминирующая сила морфотипа практически одинакова и достаточно высока (около 0.8). 

**NB!** В условиях с нормально соленостью в Баренцевом море AUC = 0.5 не входит в доверительный интервал, что говорит о том, что даже и в этих условиях по язычку определение значимо отличается от простого подбрасывания монетки.

Таким образом, саму возможность использования морфологического сигнала для определения видовой принадлежности мидии можно считать доказанной. 






## Часть 3. Вероятность корректной идентификации видов

Согласно расширенной теореме Байеса, определение видов по морфотипам может происходить лишь с определненой веротяностью. При этом условная вероятность для данной мидии быть определнной, как M.trossulus, если мы знаем что она имеет T-морфотип ($P(MT|T)$) может быть описана следующим уравннеием.

$P(MT|T) = \frac{P(T|MT)P(MT)}{P(T|MT)P(MT) + P(T|ME)P(ME)}$ (Eq 1)

Аналогично для мидий, имеющих E-морфотип, вертяность отнесения к виду M.edulis описывается следующем уравнением

$P(ME|E) = \frac{P(E|ME)P(ME)}{P(E|ME)P(ME) + P(E|MT)P(MT)}$ (Eq 2)

где

$P(MT|T)$ - вероятность быть M.trossulus если мидия имеет T-морфотип

$P(ME|E)$ - вероятность быть M.edulis если мидия имеет E-морфотип 

$P(T|MT)$ - вероятность встретить T-морфотип среди M.trossulus

$P(E|ME)$ - вероятность встретить E-морфотип среди M.edulis

$P(MT)$ - вероятность встретить M.trossulus

$P(ME)$ - вероятность встретить M.edulis


К сожалению, взять и просто рассчитать подобные вероятности нельзя по двум причинами. Во-первых, оценки $P(MT)$ и $P(ME)$ основаны на *не*независимых выборках.  Из-за того, что наши пробы сгруппированы переменной `pop`в оценке вероятности могут проявляться локальные эффекты, смещающие вероятности. Во-вторых, диагностическая ценность морфологического признака может варьировать в связи с какими-то переменным (географические выделы, соленость и т.п.). 

В связи с этим необходимо построить "феноменологическую" модель, описывающую поведение эмпирических данных. При этом модель должна характеризовать взаимосвязь $P(MT|T)$ (аналогично для $P(ME|E)$) не только с $P(MT)$ (или $P(ME) = 1 - P(MT)$), но и с двумя другими предикторами, которые потенциально могут играть роль в изменении характера этой связи -- это географический выдел (море, переменная `sea`) и присутствие постоянного опреснения (близость к устью больших рек, переменная `sal_place`). Модель должна включать случайный фактор `pop`, который определяет внутриклассовые корреляции в выборках.


## Модель

Для дальнейшего построения модели мы введем переменную `congr` (от "congruence"), которая принимает значение 1 если мидия имеет T-морфотип и относится к M.trossulus или имеет E-морфотип и относится к M.edulis.  В остальных случаях она приобретает значение 0. Эта переменная характеризует событие правильного определения вида по морфотипу. Модель должна описывать поведение вероятности этого события от следующих предикторов:
- доля M.trossulus в популяции (`freq_MT`) 
- морфотип (`morph`)
- море (`sea`)
- присутствие опреснения (`sal_place`)
- Все взаимодействия предикторов.  


### Строим собственно модель

```{r}
Mod_fT_congr <- glmer(congr ~ morph * freq_MT*sea*sal_place + (1 | pop), data = myt2, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

Mod_fT_congr_a <- glmer(congr ~ (morph + freq_MT + sea + sal_place)^2 + (1 | pop), data = myt2, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

AIC(Mod_fT_congr, Mod_fT_congr_a)

```

Модель со всеми взаимодействиями лучше. Следовательно ее и возьмем за основу


### Упрощение модели

```{r}
drop1(Mod_fT_congr, test = "Chi")

Mod_fT_congr2 <- update(Mod_fT_congr_a, .~.-morph:freq_MT:sea:sal_place )
drop1(Mod_fT_congr2, test = "Chi")

Mod_fT_congr3 <- update(Mod_fT_congr2, .~.-freq_MT:sal_place )
drop1(Mod_fT_congr3, test = "Chi")

Mod_fT_congr4 <- update(Mod_fT_congr3, .~.-sea:sal_place)
drop1(Mod_fT_congr4, test = "Chi")

Mod_fT_congr5 <- update(Mod_fT_congr4, .~.-morph:sea)
drop1(Mod_fT_congr5, test = "Chi")

Mod_fT_congr_fin <- Mod_fT_congr5

```


Итого. Модель мы сократили, но несмотря на насилие, полученная финальная модель оказалась лучше исходной. 

```{r}
AIC(Mod_fT_congr,Mod_fT_congr_fin)
```




### Финальная модель 

Вот анализ девиансы для финальной модели.

```{r}
Anova(Mod_fT_congr_fin)
```


Визуализация модели


```{r}
newdata <- myt2 %>% group_by(sea, morph, sal_place) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))

# Предсказанные значеня в шкале вероятностей
newdata$fit <- predict(Mod_fT_congr_fin, newdata = newdata, type = "response", re.form = NA) 

# Предсказанные значеня в шкале логитов
newdata$fit_eta <- predict(Mod_fT_congr_fin, newdata = newdata, re.form = NA) 

# Вычисление доверительного инеравала

# formula((Mod_fT_congr_fin)) 

X <- model.matrix(  ~ morph + freq_MT + sea + sal_place + morph:freq_MT + 
    morph:sal_place + freq_MT:sea, data = newdata) #Модельная матрица для визуализации


# Ошибки в шкале логитов
newdata$se_eta <- sqrt(diag(X %*% vcov(Mod_fT_congr_fin) %*% t(X)))

logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация

# Границы доверительных интервалов в масштабах вероятностей
newdata$lwr <- logit_back(newdata$fit_eta - 2 * newdata$se_eta)
newdata$upr <- logit_back(newdata$fit_eta + 2 * newdata$se_eta)

# newdata$lwr <- probit_back(newdata$fit_eta - 2 * newdata$se_eta)
# newdata$upr <- probit_back(newdata$fit_eta + 2 * newdata$se_eta)


Pl_fit <- ggplot(newdata, aes(x = freq_MT, y = fit)) + geom_ribbon(aes(ymin = lwr, ymax = upr, group = morph), alpha = 0.2)  + geom_line(aes(color = morph), size=1) + facet_grid(sea ~ sal_place) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification", x = "Proportion of M.trossulus", color = "Morphotype") + theme(legend.position = "bottom")

Pl_fit
```

Поскольку данная модель предсказывает вероятность корректного определения для индивидуальной мидии, у которой переменная отклика может принимать значение только 1 или 0, то представить первичные данные на этом графике сложно. Поэтому в качестве прокси для первичных данных мы можем изобразить точки, отражающие доли корректных определений в отдельных популяциях в зависимости от доли M.trossulus в данной популяции.  


```{r}
correct_prop <- summaryBy(congr + freq_MT  ~ pop + sea + morph + sal_place, data = myt2)


Pl_fit_init_data <- Pl_fit + geom_point(data = correct_prop, aes(x = freq_MT.mean, y = congr.mean, color = morph), size = 2)

Pl_fit_init_data
```


На данном графике можно нанести кривые, соответствующие условным вероятностям, основанным на оценках 
$P(T|MT)$, $P(E|ME)$, $P(MT)$ и $P(ME) = 1 - P(MT)$ для каждого из четырех выделов.

```{r}


# Функция для вычисления условных вероятностей

probs_calc <- function(variable = "Location", place = "white_fresh") {
  n <- which(names(myt2) == variable)
  d <- myt2[myt2[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)

  P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
  P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
  # P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)

  P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
  P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
  # P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)


  probs <- data.frame(P_MT = seq(0, 1, 0.01), P_MT_T = NA, P_ME_E = NA)

  probs$P_MT_T <- with(probs, (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT)))
  probs$P_ME_E <- with(probs, (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)  )

  probs[,4] <- place
  names(probs)[4] <- variable
  probs

}



probs_all <- rbind(probs_calc(place = "white_normal"), probs_calc(place = "white_fresh"), probs_calc(place = "barents_fresh"), probs_calc(place = "barents_normal") )

probs_all$sea <- ifelse(probs_all$Location == "white_normal" | probs_all$Location == "white_fresh", "white", "barents") 

probs_all$sal_place <- ifelse(probs_all$Location == "barents_normal" | probs_all$Location == "white_normal", "normal", "fresh") 


########################### Вычисление таблицы со всеми показателями для регионов

probs_calc_3 <- function(variable = "Location", place = "white_normal", P_MT = 0.5) {
  n <- which(names(myt2) == variable)
  d <- myt2[myt2[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)
  
  P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
  P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
  # P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)
  
  P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
  P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
  # P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)
  
  
  P_MT_T <- (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT))
  P_ME_E <- (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)
  
  c(P_MT_T, P_ME_E)
}



freq_calc2 <- function(variable = "Location", place = "barents_fresh"){
  n <- which(names(myt2) == variable)
  d <- myt2[myt2[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)

  #Вероятность встретить M,trossulus среди Т морфотипа оценка условной веротяности P_MT|T
  P_MT_T <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.edulis[2])
  
  #Вероятность встретить M.edulis среди E морфотипа
  P_ME_E <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])
  
  #Вероятность встретить M.trossulus среди E морфотипа
  P_MT_E <- freq_dd$M.trossulus[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])

  #Вероятность встретить M.edulis среди T морфотипа
  P_ME_T <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.trossulus[2])

  #Вероятность встретить T морфотп среди M.trossulus морфотипа
  P_T_MT <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])

  #Вероятность встретить E морфотп среди M.trossulus морфотипа
  P_E_MT <- freq_dd$M.trossulus[1]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])

  #Вероятность встретить T морфотп среди M.edulis морфотипа
  P_T_ME <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])
  
  #Вероятность встретить E морфотп среди M.edlis морфотипа
  P_E_ME <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])

  #Вероятность встретить M.trossulus любого морфотипа
  P_MT   <- sum(freq_dd$M.trossulus)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.edulis любого морфотипа
  P_ME   <- sum(freq_dd$M.edulis)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.trossulus T морфотипа
  P_MT_of_T   <- (freq_dd$M.trossulus[2])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
  
  #Вероятность встретить M.trossulus E морфотипа
  P_MT_of_E   <- (freq_dd$M.trossulus[1])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить M.edulis T морфотипа
  P_ME_of_T   <- (freq_dd$M.edulis[2])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
  
  #Вероятность встретить M.edulis E морфотипа
  P_ME_of_E   <- (freq_dd$M.edulis[1])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))

  #Вероятность встретить  E морфотип
  P_E   <- sum(freq_dd[1, -1])/sum(freq_dd[,-1])
  
  #Вероятность встретить  T морфотип
  P_T   <- sum(freq_dd[2, -1])/sum(freq_dd[,-1])
  
    
  props <- c(P_MT_T, P_ME_E, P_MT_E, P_ME_T, P_T_MT, P_E_MT, P_T_ME,  P_E_ME, P_MT, P_ME, P_MT_of_T, P_MT_of_E, P_ME_of_T, P_ME_of_E, P_E, P_T)

  names(props) <- c("P_MT_T", "P_ME_E", "P_MT_E", "P_ME_T", "P_T_MT", "P_E_MT", "P_T_ME",  "P_E_ME", "P_MT", "P_ME", "P_MT_of_T", "P_MT_of_E", "P_ME_of_T", "P_ME_of_E", "P_E", "P_T")
  
  props
}


All_freq <- data.frame(barents_normal = freq_calc2(place = "barents_normal"), 
                       barents_fresh = freq_calc2(place = "barents_fresh"),
                       white_normal = freq_calc2(place = "white_normal"),
                       white_fresh = freq_calc2(place = "white_fresh"))


tAll_freq <- as.data.frame(t(All_freq))
tAll_freq$Location <- rownames(tAll_freq)

###########################


#### Вводится коррекция в соответствии с тем, что P_MT_T = congr_T/P_T

newdata$Location <- paste(newdata$sea,"_", newdata$sal_place, sep = "")

newdata_and_freq <- merge(newdata, tAll_freq, by = "Location")

newdata_and_freq$fit_corrected <- ifelse(newdata_and_freq$morph == "T_m",newdata_and_freq$fit / newdata_and_freq$P_T, newdata_and_freq$fit / (1 - newdata_and_freq$P_T) )



Pl_fit_corrected <- ggplot(newdata_and_freq, aes(x = freq_MT, y = fit_corrected)) + geom_line(aes(color = morph), size=1) + facet_grid(sea ~ sal_place) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification", x = "Proportion of M.trossulus", color = "Morphotype") + theme(legend.position = "bottom")
 
 
 

Pl_fit + geom_line(data = probs_all, aes(x = P_MT,  y = P_MT_T), color = "red", linetype = 2) + geom_line(data = probs_all, aes(x = P_MT,  y = P_ME_E), color = "blue", linetype = 2)

```

Наверное важно, что в Баренцевом море наблюдаемая связь хорошо соотносится с теоретически ожидаемой. Это означает, видим, что локальные эффекты в Баренцевом море не очень сильны. В Белом море, видимо, они очень сильны, вследствие чего наблюдаемые кривые сильно отличаются от ожидаемых. 


## Трактовка модели

Что мы видим, глядя на полученные графики? 



1. Хотя эмпирические кривые идут более или менее сонаправленно с ожидаемыми баесовскими кривыми. Однако полного соответствия баесовских кривых и эмпирически подобранных линий регрессии нет. Это, вероятно, следствие того самого наличия группирующих факторов (`pop`). 

2. Вероятность правильного определения (можно называть это *accuarcy*) явно разная в разных морях и явно зависит от солености. Это лучше будет видно, если мы объединим графики. 

```{r, echo=FALSE}
 ggplot(newdata, aes(x = freq_MT, y = fit, linetype = sal_place))  + geom_line(aes(color = morph), size=1) + geom_ribbon(aes(ymin = lwr, ymax = upr, fill = morph), alpha = 0.2) + facet_wrap( ~ sea) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification", x = "Proportion of M.trossulus", color = "Morphotype", linetype = "Freshness") + guides(fill = "none") + theme(legend.position = "bottom")
```


В Баренцевом море вероятность правильного определения по T-морфотипу в опресненных местах резко выше, чем в не опресненных. При идентификации по E-морфотипу различия меньше, но тоже явно присутствуют. В Белом море тенденция аналогичная, но менее ярко выраженная. НО! Самое важное, что вогласно эмпирическим данным, соответствие E-морфотипа виду M.edulis в двух морях не очень зависит от солености. А вот соответствие  T-морфотипа виду M.trossulus сильно уменьшается в неопресненных местах.




## Часть 4. Проверка предсказательной силы модели


```{r}
#Наблюдаемая доля T-морфотипа
test_fr_T <- summaryBy( ind ~ sea + sal_place + pop, data = myt3)
names(test_fr_T)[4] <- "Prop_T" 

#Наблюдаемая доля доля M.trossulus
test_fr_MT <- summaryBy( str ~ sea + sal_place + pop, data = myt3)
names(test_fr_MT)[4] <- "Prop_MT_obs"


#Предсказанная доля M.trossulus
test_fr_MT$Prop_MT_predicted <-  predict(Model_T_MT2, newdata = test_fr_T, type = "response")

ggplot(test_fr_MT, aes(x = Prop_MT_obs, y = Prop_MT_predicted)) + geom_point() + geom_abline() + theme_bw() + labs(x = "Observed proportion of M.trossulus", y = "Predicted poportion of M.trossulus")

```

Вроде точки хорошо ложатся вдоль линии Y=X. 

Далее, возьмем величины доли M.trosulus и вычислим на их основе для каждой мидии из тестового датасета вероятность быть правильно идентифицированной. А далее  посмотрим, как эти величины будут соотноситься с баесовскими кривыми, полученными на основе training data set. 

Вот что получается. Каждая точка здесь -- это популяция, для которой вычислена средняя вероятность правильного определения на основе знаний доли T-морфотипа в популяции. 





```{r}
myt3 <- merge(myt3,test_fr_MT) 
# unique(myt3$pop)
myt3 <- merge(myt3,test_fr_T)


myt3$freq_MT <- myt3$Prop_MT_predicted
# myt3$freq_MT <- myt3$Prop_T

myt3$congr_predicted <- predict(Mod_fT_congr3, newdata = myt3, type = "response", re.form = NA)

Plot_test <- ggplot(myt3, aes(x = freq_MT, y = congr_predicted)) + geom_point(aes(color = morph), size = 4) + facet_wrap(~sal_place) + scale_color_manual(values = c("blue", "red")) + geom_line(data = probs_all[probs_all$sea == "barents", ], aes(x = P_MT, y = P_MT_T), color = "red", linetype = 2) + geom_line(data = probs_all[probs_all$sea == "barents", ], aes(x = P_MT, y = P_ME_E), color = "blue", linetype = 2) + theme_bw() + labs(x = "Proportion of M.trossulus or T-morphotype", y = "Probability of correct identification") + scale_x_continuous(breaks = seq(0, 1, 0.1)) + scale_y_continuous(breaks = seq(0, 1, 0.1))

T_morph_labels <- data.frame(freq_MT = rep(seq(0, 1, 0.1), 2), sal_place = rep(c("fresh", "normal"), each = 11), b0 = rep(c(-2.3,-4.3), each = 11), b1 = rep(c(5.9, 5.9), each = 11) ) 

T_morph_labels$freq_T <- round(with(T_morph_labels, (log(freq_MT/(1-freq_MT))-b0)/b1), 1)

T_morph_labels$freq_T[T_morph_labels$freq_T < 0 | T_morph_labels$freq_T > 1] <- NA

Plot_test + geom_text(data = T_morph_labels, aes(x =  freq_MT, y = 0, label = freq_T))

```

















