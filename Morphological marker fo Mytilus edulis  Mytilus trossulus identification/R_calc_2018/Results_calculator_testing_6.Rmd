---
title: ""
author: ""
date: ""
output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
library(knitr)
# library(flextable)

opts_chunk$set(echo = FALSE, cache = FALSE, fig.align ="center", warning = FALSE, message = FALSE)

# set pander table-layout options
library(pander)
panderOptions('table.alignment.default', function(df)
    ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('table.split.table', Inf)
panderOptions('big.mark', ",")
panderOptions('keep.trailing.zeros', TRUE)

```


<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }
td {  /* Table  */
  font-size: 14px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 30px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 20px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 16px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 18px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>



```{r}

library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)
library(pROC)
library(betareg)
library(lmtest)
library(broom)
library(MuMIn)
library(gridExtra)





#### Data reading and initial preparation #####

myt <- read.table("data_salinity3.csv", header = T, sep = ",")


myt_overseas <- myt[myt$dataset == "overseas", ]

myt <- myt[myt$dataset != "overseas", ]

# str(myt)

myt$Sp [myt$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt$Sp [myt$str <= 0.5] <- "M.edulis"
myt$Sp <- factor(myt$Sp)

# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]


# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)



# Бинарное обозначение видов
myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)


#Correct identification
myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )


# Частота M.trossulus в популяции

freq_MT <- myt2 %>% group_by(pop) %>% summarise(freq_MT = mean(Sp2))

myt2 <- merge(myt2, freq_MT)


# Частота T-морфотипа в популяции

Prop_T <- myt2 %>% group_by(pop) %>% summarise(Prop_T = mean(ind))

myt2 <- merge(myt2, Prop_T)


# Подразделяем данные на три сабсета

myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "fresh"] <- "BL" 
myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "normal"] <- "BH" 
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "normal"] <- "W" 
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "fresh"] <- "W" 

myt2$Subset <- factor(myt2$Subset, levels = c("W", "BL", "BH"))

# 
#Оставляем только данные, на основе, которых строится модель

# myt3 <- myt2[myt2$dataset == "testing", ]
# 
# myt2 <- myt2[myt2$dataset == "training", ]


# Извлекаем из беломорского материала тестовую выборку 
#В формальную тестовую выборку  попадают точки наиболее близкие к 20%, 40%, 60% и 80% freq_MT

# selected_pop <- myt2[myt2$Subset == "W", ] %>% group_by(Subset, pop) %>% summarise(freq_MT = mean(freq_MT)) %>% group_by(Subset) %>% arrange(freq_MT, .by_group = TRUE) %>% mutate(dif_20 = (freq_MT - 0.2)^2, dif_40 = (freq_MT - 0.4)^2, dif_60 = (freq_MT - 0.6)^2, dif_80 = (freq_MT - 0.8)^2)  %>% group_by(Subset)  %>% summarize (n_pop =n(), q_20_pop = nth(pop, which.min(dif_20)), q_40_pop = nth(pop, which.min(dif_40)), q_60_pop = nth(pop, which.min(dif_60)), q_80_pop = nth(pop, which.min(dif_80))) 
  
  


# selected_pop <- melt(selected_pop, id.vars = c("Subset", "n_pop"))$value




# myt4 <- myt2[myt2$pop %in% selected_pop, ] #новый testing dataset for the White sea

# myt3 <- rbind(myt3, myt4)

# myt2 <- myt2[!(myt2$pop %in% selected_pop), ] #новый modelling dataset

```


```{r}
# Таблица с характеристиками тестинговых данных
# myt3_print <- myt3 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), Ptros = round(mean(Sp == "M.trossulus"), 2 ))

# myt3_print_out <- flextable(
#   myt3_print, 
#   col_keys = c("Subset",	"Population",	"N_Tm_T",	"N_Em_T",	"N_Tm_E",	"N_Em_E",	"Ptros"))



# kable(myt3_print)
# myt3_print_out
```

```{r}
# Таблица с характеристиками моделлинговых данных
myt2_print <- myt2 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), Ptros = round(mean(Sp == "M.trossulus"), 2 ))

# kable(myt2_print)
```




```{r}

# Функция для вычисления P_T_MT и P_T_ME в заданном датасете (БУБЛИК) ####
donat <- function(df){
  P_MT <- sum(df$Sp == "M.trossulus")
  P_T_MT <- sum(df$Sp == "M.trossulus" & df$morph == "T_m")/P_MT
  
  P_ME <- sum(df$Sp == "M.edulis")
  P_T_ME <- sum(df$Sp == "M.edulis" & df$morph == "T_m")/P_ME
  c(P_T_MT, P_T_ME)
}




########################################3

#Функция для "ленивого" калькулятора №1 который строит зависимость Ptros от P_T  

# На входе параметры бублика

calc1 <- function(P_T_MT, P_T_ME){
  result <- data.frame(P_T = seq(0, 1, 0.01))
  result$Ptros <- (result$P_T - P_T_ME)/(P_T_MT - P_T_ME)
  result <- result[result$P_T <= P_T_MT & result$P_T >= P_T_ME, ]
  result
}



# Функция для вычисления баесовских вероятностей по данным из бублика

calc2 <- function(P_T_MT, P_T_ME){
  result <- data.frame(freq_MT = seq(0, 1, 0.01))
  result$P_MT_T <- (P_T_MT * result$freq_MT)/(P_T_MT * result$freq_MT + P_T_ME*(1-result$freq_MT))
  result$P_ME_E <- ((1 - P_T_ME) * (1 - result$freq_MT))/(1 - P_T_ME + result$freq_MT * (P_T_ME - P_T_MT))
  result
}


########################################3


# Фунция для определения похожести между эмпирическим и теоретическими моделями для МОДЕЛИ 5 (Ptros vs P_T)



perms2 <- function(df = myt2[myt2$Subset == "W", ], regr_model = Model_5_final,...) {
  require(dplyr)
  df$pop <- as.character(df$pop)
  perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
  perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
  perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
  
  perm_pairs$First <- as.character(perm_pairs$First)
  perm_pairs$Second <- as.character(perm_pairs$Second)
  perm_pairs$Delta <- NA
  for(i in 1:nrow(perm_pairs)){
    df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),] 
    
    means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
    
    perm_pairs$Delta[i] <- 
      min(c(means$freq_MT[1],means$freq_MT[2])) *(1 - max(c(means$freq_MT[1],means$freq_MT[2]))) +
      max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2]))) 
    
    W <- donat(df_selected)
    
    calc1_predict_W <- calc1(W[1], W[2])
    
    names(calc1_predict_W) <- c("Prop_T", "Ptros_predicted" )
    
    Model_prediction <- expand.grid(Subset = unique(df_selected$Subset), Prop_T = seq(0, 1, 0.01))
    
    Model_prediction$Predict <- predict(regr_model, newdata = Model_prediction, type = "response")
    
    all_prediction <- merge(calc1_predict_W, Model_prediction, by = c("Prop_T"))
    
    perm_pairs$Goodness[i] <- 1/(mean((all_prediction$Predict - all_prediction$Ptros_predicted)^2))
    
  }
  perm_pairs
}



# Фунция для определения похожести между эмпирическим и теоретическими моделями для МОДЕЛИ 5 (Ptros vs P_T) НО калибровочные вборки взяты по степени различия между частотой T-морфотипа


perms2_T <- function(df = myt2[myt2$Subset == "W", ], regr_model = Model_5_final,...) {
  require(dplyr)
  df$pop <- as.character(df$pop)
  perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
  perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
  perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
  
  perm_pairs$First <- as.character(perm_pairs$First)
  perm_pairs$Second <- as.character(perm_pairs$Second)
  perm_pairs$Delta <- NA
  for(i in 1:nrow(perm_pairs)){
    df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),] 
    
    means <- df_selected %>% group_by(pop) %>% summarise(freq_T = mean(Prop_T))
    
    perm_pairs$Delta[i] <- 
      min(c(means$freq_T[1],means$freq_T[2])) *(1 - max(c(means$freq_T[1],means$freq_T[2]))) +
      max(c(means$freq_T[1],means$freq_T[2])) *(1 - min(c(means$freq_T[1],means$freq_T[2]))) 
    
    W <- donat(df_selected)
    
    calc1_predict_W <- calc1(W[1], W[2])
    
    names(calc1_predict_W) <- c("Prop_T", "Ptros_predicted" )
    
    Model_prediction <- expand.grid(Subset = unique(df_selected$Subset), Prop_T = seq(0, 1, 0.01))
    
    Model_prediction$Predict <- predict(regr_model, newdata = Model_prediction, type = "response")
    
    all_prediction <- merge(calc1_predict_W, Model_prediction, by = c("Prop_T"))
    
    perm_pairs$Goodness[i] <- 1/(mean((all_prediction$Predict - all_prediction$Ptros_predicted)^2))
    
  }
  perm_pairs
}





# Фунция для определения похожести между эмпирическими и теоретическими моделями для МОДЕЛИ 4 (Congr vs Ptros; Morph)
perms4 <- function(df = myt2[myt2$Subset == "W"], regr_model =  Model_4_final, ...) {
  require(dplyr)
  df$pop <- as.character(df$pop)
  perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
  perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
  perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]  
  
  perm_pairs$First <- as.character(perm_pairs$First)
  perm_pairs$Second <- as.character(perm_pairs$Second)
  perm_pairs$Delta <- NA
  for(i in 1:nrow(perm_pairs)){
    df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),] 
    
    means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
    # perm_pairs$Delta[i] <- abs(means$freq_MT[1] - means$freq_MT[2])
    perm_pairs$Delta[i] <- 
      min(c(means$freq_MT[1],means$freq_MT[2])) *(1 - max(c(means$freq_MT[1],means$freq_MT[2]))) + 
      max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2])))
    W <- donat(df_selected)
    
    calc2_predict_W <- calc2(W[1], W[2])
    names(calc2_predict_W) <- c("freq_MT", "T_m",  "E_m")
    
    calc2_predict_W <- melt(calc2_predict_W, id.vars = "freq_MT" )
    names(calc2_predict_W) <- c("freq_MT", "morph", "Bayes_predict") 
    
    Model_prediction <- expand.grid(Subset = unique(df_selected$Subset),  morph = levels(df_selected$morph), freq_MT = seq(0, 1, 0.01))
    
    Model_prediction$Predict <- predict(regr_model, newdata = Model_prediction, type = "response",  re.form = NA )
    
    all_prediction <- merge(calc2_predict_W, Model_prediction, by = c("freq_MT", "morph"))
    
    
    perm_pairs$Goodness[i] <- 1/mean((all_prediction$Bayes_predict - all_prediction$Predict)^2, na.rm = T)
    perm_pairs$pop[i] <- unique(as.character(df_selected$pop))
    
  }
  perm_pairs
}




# Фунция для определения похожести между эмпирическими и теоретическими моделями для МОДЕЛИ 4 (Congr vs Ptros; Morph) но в качестве калибровочных рассматриваются выборки с наиболее смешаннойчастотой T-морфотипа

perms4_T <- function(df = myt2[myt2$Subset == "W"], regr_model =  Model_4_final, ...) {
  require(dplyr)
  df$pop <- as.character(df$pop)
  perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
  perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
  perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]  
  
  perm_pairs$First <- as.character(perm_pairs$First)
  perm_pairs$Second <- as.character(perm_pairs$Second)
  perm_pairs$Delta <- NA
  for(i in 1:nrow(perm_pairs)){
    df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),] 
    
    means <- df_selected %>% group_by(pop) %>% summarise(freq_T = mean(Prop_T))
    # perm_pairs$Delta[i] <- abs(means$freq_MT[1] - means$freq_MT[2])
    perm_pairs$Delta[i] <- 
      min(c(means$freq_T[1],means$freq_T[2])) *(1 - max(c(means$freq_T[1],means$freq_T[2]))) + 
      max(c(means$freq_T[1],means$freq_T[2])) *(1 - min(c(means$freq_T[1],means$freq_T[2])))
    W <- donat(df_selected)
    
    calc2_predict_W <- calc2(W[1], W[2])
    names(calc2_predict_W) <- c("freq_MT", "T_m",  "E_m")
    
    calc2_predict_W <- melt(calc2_predict_W, id.vars = "freq_MT" )
    names(calc2_predict_W) <- c("freq_MT", "morph", "Bayes_predict") 
    
    Model_prediction <- expand.grid(Subset = unique(df_selected$Subset),  morph = levels(df_selected$morph), freq_MT = seq(0, 1, 0.01))
    
    Model_prediction$Predict <- predict(regr_model, newdata = Model_prediction, type = "response",  re.form = NA )
    
    all_prediction <- merge(calc2_predict_W, Model_prediction, by = c("freq_MT", "morph"))
    
    
    perm_pairs$Goodness[i] <- 1/mean((all_prediction$Bayes_predict - all_prediction$Predict)^2, na.rm = T)
    perm_pairs$pop[i] <- unique(as.character(df_selected$pop))
    
  }
  perm_pairs
}


## Функция для поиска ниболее различающихся выборок по генетической струкутре
max_dif <- function(df = myt2, Subset = "W", ...) {
  require(dplyr)
  df = df[df$Subset %in% Subset, ]
  df$pop <- as.character(df$pop)
  perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
  perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
  perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]  
  
  perm_pairs$First <- as.character(perm_pairs$First)
  perm_pairs$Second <- as.character(perm_pairs$Second)
  perm_pairs$Delta <- NA

  for(i in 1:nrow(perm_pairs)){
    df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),] 
    
    means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
    
    perm_pairs$Delta[i] <- 
      max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2]))) +
      min(c(means$freq_MT[1],means$freq_MT[2])) *(1 - max(c(means$freq_MT[1],means$freq_MT[2])))
  }
  max_dif <- perm_pairs[which.max(perm_pairs$Delta), ]
  c(max_dif$First, max_dif$Second)
}



## Функция для поиска ниболее различающихся выборок по частоте T-морфотипа
max_dif_T <- function(df = myt2, Subset = "W", ...) {
  require(dplyr)
  df = df[df$Subset %in% Subset, ]
  df$pop <- as.character(df$pop)
  perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
  perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
  perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]  
  
  perm_pairs$First <- as.character(perm_pairs$First)
  perm_pairs$Second <- as.character(perm_pairs$Second)
  perm_pairs$Delta <- NA

  for(i in 1:nrow(perm_pairs)){
    df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),] 
    
    means <- df_selected %>% group_by(pop) %>% summarise(freq_T = mean(Prop_T))
    
    perm_pairs$Delta[i] <- 
      max(c(means$freq_T[1],means$freq_T[2])) *(1 - min(c(means$freq_T[1],means$freq_T[2]))) +
      min(c(means$freq_T[1],means$freq_T[2])) *(1 - max(c(means$freq_T[1],means$freq_T[2])))
  }
  max_dif <- perm_pairs[which.max(perm_pairs$Delta), ]
  c(max_dif$First, max_dif$Second)
}



# Функция для поиска выборок наиболее смешанных по генетической структуре

max_mix <- function(df = myt2, Subset = "W", ...) {
  require(dplyr)
  df = df[df$Subset %in% Subset, ]
  df$pop <- as.character(df$pop)
  perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
  perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
  perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
    
  perm_pairs$First <- as.character(perm_pairs$First)
  perm_pairs$Second <- as.character(perm_pairs$Second)
  perm_pairs$Delta <- NA

  for(i in 1:nrow(perm_pairs)){
    df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),] 
    
    means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
    
    perm_pairs$Delta[i] <- 
      max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2]))) + 
      min(c(means$freq_MT[1],means$freq_MT[2])) *(1 - max(c(means$freq_MT[1],means$freq_MT[2])))
    
  }
  
  max_mix <- perm_pairs[which.min(abs(perm_pairs$Delta - 0.5)), ]
  c(max_mix$First, max_mix$Second)
}



# Функция для поиска выборок наиболее смешанных по частоте T-морфотипа

max_mix_T <- function(df = myt2, Subset = "W", ...) {
  require(dplyr)
  df = df[df$Subset %in% Subset, ]
  df$pop <- as.character(df$pop)
  perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
  perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
  perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
    
  perm_pairs$First <- as.character(perm_pairs$First)
  perm_pairs$Second <- as.character(perm_pairs$Second)
  perm_pairs$Delta <- NA

  for(i in 1:nrow(perm_pairs)){
    df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),] 
    
    means <- df_selected %>% group_by(pop) %>% summarise(freq_T = mean(Prop_T))
    
    perm_pairs$Delta[i] <- 
      max(c(means$freq_T[1],means$freq_T[2])) *(1 - min(c(means$freq_T[1],means$freq_T[2]))) + 
      min(c(means$freq_T[1],means$freq_T[2])) *(1 - max(c(means$freq_T[1],means$freq_T[2])))
    
  }
  
  max_mix <- perm_pairs[which.min(abs(perm_pairs$Delta - 0.5)), ]
  c(max_mix$First, max_mix$Second)
}






### Функция для описания структуры калибровочных выборок

calib_str <- function(df = myt2, pop1, pop2){
  df =df[df$pop %in% c(pop1, pop2), ]
  df$Subset <- factor(df$Subset)
  str_calib <- df %>% group_by(pop, Subset) %>% summarize(N_E = sum(Sp == "M.edulis"), N_T = sum(Sp ==  "M.trossulus"), P_T_ME = mean(Sp == "M.edulis" & morph == "T_m"), P_T_MT = mean(Sp == "M.trossulus" & morph == "T_m"), Ptros = mean(freq_MT) )
  str_calib
}




########################################

# Функция для обратной трансформации логитов
logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация



# Функция для оценки сверхдисперсии в моделях GLM

overdisp_fun <- function(model) {
  rdf <- df.residual(model)  # Число степеней свободы N - p
  if (inherits(model, 'negbin')) rdf <- rdf - 1 ## учитываем k в NegBin GLMM
  rp <- residuals(model,type='pearson') # Пирсоновские остатки
  Pearson.chisq <- sum(rp^2) # Сумма квадратов остатков, подчиняется Хи-квадрат распределению
  prat <- Pearson.chisq/rdf  # Отношение суммы квадратов остатков к числу степеней свободы
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE) # Уровень значимости
  c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)        # Вывод результатов
}





```


```{r}
##### Theme for ggplot ######
theme_set(theme_bw() + theme(axis.title.x = element_text(size = 10), axis.title.y = element_text(size = 10), axis.text= element_text(size = 10), legend.position = "none" , title = element_text(size = 10)))  

```







```{r}


#### Data reading and initial preparation #####

myt <- read.table("data_salinity3.csv", header = T, sep = ",")

# Оставляем только мидий, у которых есть оценка морфотипа
myt2_all <- myt[!is.na(myt$ind), ]



### Объединяем популяции в данных Сары #####
# myt2_all$pop2 <- myt2_all$pop
# 
# myt2_all$pop[myt2_all$pop %in% c("CBCP", "CBSC")] <- "CB"
# 
# myt2_all$pop[myt2_all$pop %in% c("MDRE",   "MDRW")] <- "MDR"


# Подразделяем данные на сабсеты

myt2_all$Subset[myt2_all$sea == "barents" & myt2_all$sal_place == "fresh"] <- "WBL" 
myt2_all$Subset[myt2_all$sea == "barents" & myt2_all$sal_place == "normal"] <- "BH" 
myt2_all$Subset[myt2_all$sea == "white" & myt2_all$sal_place == "normal"] <- "WBL" 
myt2_all$Subset[myt2_all$sea == "white" & myt2_all$sal_place == "fresh"] <- "WBL" 

myt2_all$Subset[myt2_all$sea == "Baltic"] <- "BALT" 
myt2_all$Subset[myt2_all$sea == "GOM"] <- "GOM" 
myt2_all$Subset[myt2_all$sea == "Norway"] <- "NORW" 
myt2_all$Subset[myt2_all$sea == "Scotland"] <- "SCOT" 


myt2_all$Subset <- factor(myt2_all$Subset, levels = c("WBL", "BH", "NORW", "BALT", "SCOT", "GOM" ))




# Вводим обозначения 

myt2_all$Sp [myt2_all$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt2_all$Sp [myt2_all$str <= 0.5] <- "M.edulis"
myt2_all$Sp <- factor(myt2_all$Sp)



# Вводим обозначения для морфотипов
myt2_all$morph <- ifelse(myt2_all$ind == 1, "T_m", "E_m")
myt2_all$morph <- factor(myt2_all$morph)



# Бинарное обозначение видов
myt2_all$Sp2 <- ifelse(myt2_all$Sp == "M.trossulus", 1, 0)


#Correct identification
myt2_all$congr <- ifelse((myt2_all$ind == 1 & myt2_all$Sp == "M.trossulus") | (myt2_all$ind == 0 & myt2_all$Sp == "M.edulis"), 1, 0   )




# Частота M.trossulus в популяции

freq_MT <- myt2_all %>% group_by(pop) %>% summarise(freq_MT = mean(Sp2))

myt2_all <- merge(myt2_all, freq_MT)


# Частота T-морфотипа в популяции

Prop_T <- myt2_all %>% group_by(pop) %>% summarise(Prop_T = mean(ind))

myt2_all <- merge(myt2_all, Prop_T)


```





```{r}
Eq3 <- function(PT, donat){
  P_T_edu <- donat[2]
  P_T_tros <- donat[1]
  b1 <- 1/(P_T_tros - P_T_edu)
  b0 <- b1*P_T_edu
  
  # predictor <- b1*PT - b0
  # 
  # Ptros <- exp(predictor)/(1 + exp(predictor))  
  
  Ptros = (PT - P_T_edu)/ ((P_T_tros) -  P_T_edu)
  Ptros <- ifelse(Ptros <0 | Ptros >1 , NA, Ptros)
  Ptros
}
  


Eq1 <- function(Ptros, donat){
  P_T_MT <- donat[1]
  P_T_ME <- donat[2]
  P_MT_T <- (P_T_MT * Ptros)/(P_T_MT * Ptros + P_T_ME*(1-Ptros))
  P_MT_T
}


Eq2 <- function(Ptros, donat){
  P_T_MT <- donat[1]
  P_T_ME <- donat[2]
  P_ME_E <- ((1 - P_T_ME) * (1 - Ptros))/(1 - P_T_ME + Ptros * (P_T_ME - P_T_MT))
  P_ME_E
}



# Предсказания по уравнениям, для случая, когда в качестве калибровочных выборок берутся максимально различные и мексимально смешанные выборки по частоте T-морфотипа 


predict_obs_Eq123_T <- function(Set, pop_max_diff, pop_max_mix){

  donat_all <- donat(df = myt2_all[myt2_all$Subset == Set, ])
  donat_max_diff <- donat(myt2_all[myt2_all$pop %in% pop_max_diff, ])
  donat_max_mix <- donat(myt2_all[myt2_all$pop %in% pop_max_mix, ])
  
  df <- myt2_all %>% filter(Subset == Set) %>% group_by(pop) %>% summarise(PT = mean(ind == 1), Ptros_obs = mean(Sp == "M.trossulus"), N_edu = sum(Sp == "M.edulis"), N_tros = sum(Sp == "M.trossulus"), Set = unique(Subset)) %>% 
  mutate(Ptros_Eq3_diff = Eq3(PT, donat_max_diff),
         Ptros_Eq3_mix = Eq3(PT, donat_max_mix), 
         Ptros_Eq3_all = Eq3(PT, donat_all),
         
         P_MT_T_Eq1_all_diff = Eq1(Ptros_Eq3_diff, donat_max_diff),
         P_MT_T_Eq1_diff_mix = Eq1(Ptros_Eq3_diff, donat_max_mix),
         P_MT_T_Eq1_diff_all = Eq1(Ptros_Eq3_diff, donat_all),
         
         P_MT_T_Eq1_mix_diff = Eq1(Ptros_Eq3_mix, donat_max_diff),
         P_MT_T_Eq1_mix_mix = Eq1(Ptros_Eq3_mix, donat_max_mix),
         P_MT_T_Eq1_mix_all = Eq1(Ptros_Eq3_mix, donat_all),
         
         P_MT_T_Eq1_all_diff = Eq1(Ptros_Eq3_all, donat_max_diff),
         P_MT_T_Eq1_all_mix = Eq1(Ptros_Eq3_all, donat_max_mix),
         P_MT_T_Eq1_all_all = Eq1(Ptros_Eq3_all, donat_all),
         

         
         P_ME_E_Eq2_all_diff = Eq2(Ptros_Eq3_diff, donat_max_diff),
         P_ME_E_Eq2_diff_mix = Eq2(Ptros_Eq3_diff, donat_max_mix),
         P_ME_E_Eq2_diff_all = Eq2(Ptros_Eq3_diff, donat_all),
         
         P_ME_E_Eq2_mix_diff = Eq2(Ptros_Eq3_mix, donat_max_diff),
         P_ME_E_Eq2_mix_mix = Eq2(Ptros_Eq3_mix, donat_max_mix),
         P_ME_E_Eq2_mix_all = Eq2(Ptros_Eq3_mix, donat_all),
         
         P_ME_E_Eq2_all_diff = Eq2(Ptros_Eq3_all, donat_max_diff),
         P_ME_E_Eq2_all_mix = Eq2(Ptros_Eq3_all, donat_max_mix),
         P_ME_E_Eq2_all_all = Eq2(Ptros_Eq3_all, donat_all))


df2 <- myt2_all %>% filter(Subset == Set, morph == "T_m") %>% group_by(pop) %>% summarise(P_MT_T_obs = mean(ind == 1 & Sp == "M.trossulus")) 

df3 <- myt2_all %>% filter(Subset == Set, morph == "E_m") %>% group_by(pop) %>% summarise(P_ME_E_obs = mean(ind == 0 & Sp == "M.edulis")) 

dd <- merge(df, df2, all = T)
ddd <- merge(dd, df3, all = T)

df_final <- ddd 


df_final$max_mix <- 0

df_final$max_dif <- 0

max_dif_pop <- max_dif_T(df = myt2_all, Subset = Set)
max_mix_pop <- max_mix_T(df = myt2_all, Subset = Set)

df_final$max_dif [df_final$pop %in% max_dif_pop] <- 1

df_final$max_mix [df_final$pop %in% max_mix_pop] <- 1
df_final$Set = Set
result <- df_final
result
}
```





```{r}

# Популяции с наиболлее смешенными частотами T-морфотипа и результаты генотипирования для них
# Ручной поиск наилучшей популяции 
# Критерий отбора  
#  max_dif объем генотипированных особей максимальный + наиболее различающаяся частота T-morphotype
# max_mix объем генотипированных особей максимальный + частота T-morphotype наиболее близка к среднему между P_T_tros и P_T_edu значению
  
pop_max_diff_WBL <- c("ivan2", "zmis")
donat_max_diff_WBL <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_WBL, ])


pop_max_diff_BH <- c("ivan_us", "seredina")
donat_max_diff_BH <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_BH, ])


pop_max_diff_GOM <- c("VH", "CBE")
donat_max_diff_GOM <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_GOM, ])


pop_max_diff_BALT <- c("kast05", "Solvesborg")
donat_max_diff_BALT <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_BALT, ])


pop_max_diff_NORW <- c("Esp04", "Bergen_MV")
donat_max_diff_NORW <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_NORW, ])




pop_max_mix_WBL <- c("belok")
donat_max_mix_WBL <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_WBL, ])


pop_max_mix_BH <- "seredina_sub"
donat_max_mix_BH <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_BH, ])


pop_max_mix_GOM <- "MDRW"
donat_max_mix_GOM <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_GOM, ])


pop_max_mix_BALT <- "kast87"
donat_max_mix_BALT <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_BALT, ])


pop_max_mix_NORW <- "Berg_new"
donat_max_mix_NORW <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_NORW, ])



WBL_T <- as.data.frame(predict_obs_Eq123_T("WBL", pop_max_diff_WBL, pop_max_mix_WBL))
BH_T <-  as.data.frame(predict_obs_Eq123_T("BH", pop_max_diff_BH, pop_max_mix_BH))
GOM_T <- as.data.frame(predict_obs_Eq123_T("GOM", pop_max_diff_GOM, pop_max_mix_GOM))
BALT_T <- as.data.frame(predict_obs_Eq123_T("BALT", pop_max_diff_BALT, pop_max_mix_BALT))
NORW_T <- as.data.frame(predict_obs_Eq123_T("NORW", pop_max_diff_NORW, pop_max_mix_NORW))

all_obs_predict_T <- rbind(WBL_T, BH_T, GOM_T, BALT_T, NORW_T)

all_obs_predict_T_work <- all_obs_predict_T %>% select(Set, pop, PT, Ptros_obs, N_edu, N_tros, P_MT_T_obs,P_ME_E_obs, Ptros_Eq3_diff, P_MT_T_Eq1_diff_mix, P_ME_E_Eq2_diff_mix )
```



```{r}

summary_predict_observ <- all_obs_predict_T_work %>% group_by(Set) %>% summarise(PT_mean = mean(PT), n_pop = length(pop), 
                                                       n_out = sum(is.na(Ptros_Eq3_diff)), 
                                                       Prop_out = round(n_out/n_pop*100, 1),
                                                       SS_eq3 = round(sum( ((Ptros_obs -Ptros_Eq3_diff)^2)/(n_pop - n_out), na.rm = T), 2),
                                                       SS_edu_eq2 = round(sum( ((P_ME_E_obs - P_ME_E_Eq2_diff_mix)^2)/(n_pop - n_out), na.rm = T), 2),
                                                       SS_tros_eq1 = round(sum( ((P_MT_T_obs - P_MT_T_Eq1_diff_mix)^2)/(n_pop - n_out), na.rm = T), 2)
                                                       )

summary_predict_observ$Set <- factor(summary_predict_observ$Set, levels = c("WBL", "BH", "GOM", "BALT", "NORW"))



summary_predict_observ$dif_pop1 <- c(pop_max_diff_BALT[1], pop_max_diff_BH[1], pop_max_diff_GOM[1], pop_max_diff_NORW[1], pop_max_diff_WBL[1])

summary_predict_observ$dif_pop2 <- c(pop_max_diff_BALT[2], pop_max_diff_BH[2], pop_max_diff_GOM[2], pop_max_diff_NORW[2], pop_max_diff_WBL[2])


summary_predict_observ$mix_pop <- c(pop_max_mix_BALT, pop_max_mix_BH, pop_max_mix_GOM, pop_max_mix_NORW, pop_max_mix_WBL)


summary_predict_observ$dif_pops <- paste(summary_predict_observ$dif_pop1, summary_predict_observ$dif_pop2)

dd <- summary_predict_observ %>% group_by(Set) %>%  summarise(T_tros_eq3 = donat(myt2_all[myt2_all$pop %in% c(dif_pop1, dif_pop2), ])[1], 
                                                        T_edu_eq3 = donat(myt2_all[myt2_all$pop %in% c(dif_pop1, dif_pop2), ])[2],
                                                        T_tros_eq12 = donat(myt2_all[myt2_all$pop %in% c(mix_pop), ])[1], 
                                                        T_edu_eq12 = donat(myt2_all[myt2_all$pop %in% c(mix_pop), ])[2])
  
  




summary_predict_observ <- merge(dd, summary_predict_observ, by = "Set")

# summary_predict_observ$PT_05 <- with(summary_predict_observ, (T_tros_eq3 + T_edu_eq3)/2 )


```



## Practical recommendations for using of morphotype test for express analysis

In the case of an uninvestigated contact zone one can use morphotype test as an express technique for assessment of genetic structure of mixed populations and the probability of correct identification of an individual mussel. We will use all samples from WSBL, BH, GOM, BALT and NORW as testing data sets to show how to make the express assessment of main predictive values such as Ptros, P(tros|T) and P(edu|E) when information on morphotype is available but possibility of genotyping is limited.The key information for this analysis is the assessment of probability to find T-morphotype among M.trossulus and E-morphotype among M.edulis. The values of  P(T|tros) and P(E|edu) should be assumpted as a characteristic of the whole contact zone and correct assessment of both parameters is the key requirement for the further analysis.


As was shown in the main part of our work the best way to use Eq3 for the assessment of  Ptros by morphotype test is to take two samples with maximally differ genetic structure (in ideal case pure M.trossulus and pure M.edulis populations). After genotyping of mussels in these samples the values of P(T|tros) and P(E|edu)  can be assessed. However the genetic structure and its variation is unknown in the case of the new contact zone. The rational way in these conditions is to take two samples with maximally differ proportions of T-morphotype. We modelled this situation when taken as calibrating samples those ones which demonstrated maximally differ proportions of T-morphotype in combination with representative numbers of mussels (Table +). 
After the calibration made Ptros could be calculated using the  proportion of T-morphotype  (PT) in  any new sample from the same contact zone. The calculator-applet  (available at https://polydora.shinyapps.io/Identification_by_morphotype_test/) could be used for these calculations. However the linear nature of the Eq 3 allows it to predict Ptros < 0 or Ptros > 1. Such unrealistic values were received in all areas (Fig. ++). We suppose that such fails in morphotype test using is unavoidable but could be reduced by more accurate assessment of P(T|tros) and P(E|edu). However, applying this approach to the available data yielded the predictions by Eq3 that were very close to the observed values, especially in the case of GOM and WSBL (Fig. ++).

The assessment of probability of correct species identification for a given specimen with known morphotype (P(tros|T) and (P(edu|E))  is more tricky. As was shown the best prediction by Eq1 and Eq2 could be given if P(T|tros) and P(E|edu) was assessed in the samples where M.edulis and M.trossulus mixed in equal proportions. It means that for solving this task we have to make genotyping for one more calibrating sample.  It is easy to show from Eq3 that Ptros = 0.5 is expected when the proportion of T-morphotype (PT) is equal to the mean value of PT in the corresponding region. For each geographic area we found populations with PT closely approaching mean value and possessing a rather representative amount of genotyped mussels.  Further we calculated P'(T|tros) and P'(E|edu) for each calibrating sample. Then we substituted these values into Eq1 and Eq2. Further we calculated predictions by  Eq1 and Eq2 for mussels of T- and E-morphotypes correspondingly for each sample in corresponding region (Ptros for each one were calculated from data on PT by Eq3 as described in the previous paragraph). The calculations can be made using calculator-applet (https://polydora.shinyapps.io/Identification_by_morphotype_test/) Comparison of predictions by Eq1 and Eq2 with observed proportions of correctly identified species among T- and E-morphotypes (Fig. ++) revealed rather good correspondence. In those samples where corresponding morphotype was relatively abundant (large points at Fig. ++)  the predictions by Eq1 and Eq2 were close to observed values. In the case of minor morphotype (small points at Fig. ++) the correspondence of predicted and observed values was poor. 

Thus we can formulate some practical recommendations as follows. When one started to work with new contact zone and trying to give express characteristic of predictive values (Ptros, P(tros|T) and (P(edu|E))  in any sample from this contact zone one should make the manipulations as follows.
1. Make assessment of proportion of T-morphotype in maximally possible number of samples (probably taken from different environmental conditions).

2. Make genotyping of mussels from two samples with most different proportions of morphotypes.
The received  P(T|tros) and P(E|edu) should be substituted  into the Eq3 which allows to calculate Ptros in any population (from a given contact zone) with known proportion of T-morphtype. 

3. If Eq3 predict unrealistic values (Pros >1 or Ptros<0) the new calibrating sample (with more different proportion of T-morphotype or with more representative amount of genotyped mussels) should be collected.

4. If one is aimed to assess the probability of correct identification of M.edulis by E-morphotype and M.trossulus by T-morphotype one should find the maximally mixed population (population with proportion of T-morphotype close to mean value of PT) and make mussel genotyping for this sample. 

5. After genotype were identified one should calculate P'(T|tros) and P'(E|edu) in this sample and substitute these values into Eq1 and Eq2.

6. For any sample with known PT the value of Ptros could be assessed by Eq3. The assessed Ptros should be used in Eq1 and Eq2. 

7.Use of Eq1 and Eq2 should be avoided if the corresponding morphotype possesses a negligible proportion in a given sample. If the acceptable level of P(tros|T) and P(edu|E) is known the critical proportion of morphotype in the population could be found using calculator-applet (https://polydora.shinyapps.io/Identification_by_morphotype_test/).






```{r, fig.width=10, fig.height=10}

 
options(scipen = 10, digits=5)

all_obs_predict_T_work$Set <- factor(all_obs_predict_T_work$Set, levels = c("WBL", "BH", "GOM", "BALT", "NORW"))



Pl_Eq3 <- all_obs_predict_T_work %>%  ggplot(aes(x = Ptros_obs, shape = Set)) + geom_point(size = 3, fill = "black")  + theme(legend.position = "bottom")   + geom_abline() + scale_shape_manual(values = c(21, 22, 23, 24, 25))  



Pl_Eq3_diff <- Pl_Eq3 + aes(y = Ptros_Eq3_diff) + guides(shape ="none", color = "none") + xlim(0,1) + ylim(0,1) + facet_wrap(~Set, nrow = 1) + labs(x = "Ptros observed", y = "Ptros predicted by Eq3")

Pl_Eq3_diff <- Pl_Eq3_diff + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 0.98, label = paste("MSS = ", SS_eq3, "\nLost pop = ", n_out )), size = 3)





# Количество генотипированных особей
n_select <- 0


# Порог для отсечения возможности предсказания. Эта величина появляется так как мы знаем, что для минорного генотипа предсказания маловероятны. То есть мы отбираем те пробы, в которых морфотип, соответствующий виду не будет минорным

PT_minor <- 0

PT_minor_plot <- 0.2

all_obs_predict_T_work$Minor_T <- with(all_obs_predict_T_work, ifelse( PT < PT_minor_plot,  1, 0))
all_obs_predict_T_work$Minor_E <- with(all_obs_predict_T_work, ifelse( (1 - PT) < PT_minor_plot,  1, 0))



Pl_Eq1_2_diff_mix_ME <-
  ggplot(data = all_obs_predict_T_work %>% filter(N_edu > n_select) %>% filter((1-PT) > PT_minor ), aes(x = P_ME_E_obs, y = P_ME_E_Eq2_diff_mix, size = 1 - PT, shape = Set)) +
  geom_point(fill = "blue") +
  geom_abline()  + xlim(0,1) + ylim(0,1) +
  facet_wrap(~Set, nrow = 1)  +
  theme(strip.text = element_blank()) +
  labs(x = "P(edu|E) observed", y = "P(edu|E) predicted by Eq2") + 
  scale_shape_manual(values = c(21, 22, 23, 24, 25)) + 
   scale_size_continuous(breaks = c(0.1, 0.5, 0.9), range = c(0.1, 5))

Pl_Eq1_2_diff_mix_ME <- Pl_Eq1_2_diff_mix_ME + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 1, label = paste("MSS = ", SS_edu_eq2 )), size = 3) 

# + geom_point(data = all_obs_predict_T_work %>% filter( Minor_E == 1),  size = 1, shape = 21, color = "yellow", fill = "yellow") 



Pl_Eq1_2_diff_mix_MT <-
  ggplot(data = all_obs_predict_T_work %>% filter(N_tros > n_select) %>% filter(PT > PT_minor), aes(x = P_MT_T_obs, y = P_MT_T_Eq1_diff_mix, size = PT, shape = Set)) +
  geom_point(fill = "red") +
  geom_abline()  + xlim(0,1) + ylim(0,1) +
  facet_wrap(~Set, nrow = 1) +
  theme(strip.text = element_blank())+
  labs(x = "P(tros|T) observed ", y = "P(tros|T) predicted by Eq1") +
  scale_shape_manual(values = c(21, 22, 23, 24, 25)) + 
   scale_size_continuous(breaks = c(0.1, 0.5, 0.9), range = c(0.1, 5) )

Pl_Eq1_2_diff_mix_MT <- Pl_Eq1_2_diff_mix_MT + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 1, label = paste("MSS = ", SS_tros_eq1 )), size = 3)

# + geom_point(data = all_obs_predict_T_work %>% filter( Minor_T == 1),  size = 1, shape = 21, color = "yellow" , fill = "yellow") 
  






grid.arrange(Pl_Eq3_diff, Pl_Eq1_2_diff_mix_ME, Pl_Eq1_2_diff_mix_MT, nrow = 3)



```

Figure ++. Predictive values assessed by equations and observed values. MSS - mean summ of squared differencess between observed and predicted values. Lost pop - number samples with unrealistic values predicted by Eq3. The size of point is proportional to proportion of the morphotipe in corresponding sample.   



```{r}
summary_predict_observ$E_edu_eq3 <- 1 - summary_predict_observ$T_edu_eq3
summary_predict_observ$E_edu_eq12 <- 1 - summary_predict_observ$T_edu_eq12


summary_predict_observ_print <- summary_predict_observ %>% select(Set, dif_pops, T_tros_eq3, E_edu_eq3, mix_pop, T_tros_eq12, E_edu_eq12   )

kable(summary_predict_observ_print, align = "lrccrcc", digits = 2 , col.names = c("Set", "Populations with different PT" , "P(T|tros)", "P(E|edu)", "Population with mean PT", "P'(T|tros)", "P'(E|edu)"), caption = "Parameters of calibrating samples in each geographic region")

```




<!-- Вот исходники можешь покопаться сам -->
<!-- ```{r} -->

<!-- options(knitr.kable.NA = '-') -->

<!-- # kable(all_obs_predict,digits = 3, caption = "Calibration on the base of genetic structure") -->
<!-- kable(all_obs_predict_T,digits = 3, caption = "Calibration on the base of T-morphotype frequency") -->

<!-- ``` -->


