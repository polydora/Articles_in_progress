---
title: "Reliability of Mytilus edulis and M. trossulus identification by semi-diagnostic conchological character varies between oceanic and estuarine habitats across Kola Peninsula (White Sea, Barents Sea)."
author: 
date: '20 января 2019 г '
abstract: "Cryptic blue mussel species (unambiguous identification by multilocus genotypes only) Mytilus edulis (МЕ) and M. trossulus (МТ) co-occur along coasts of Kola Peninsula (the White Sea, salinity up to 25 ppt, the Barents Sea, salinity up to 35 ppt). Previous studies revealed morphological differences between species in the White Sea: the majority of MT bear an uninterrupted dark prismatic strip under the ligament on the inner side of the shell (Т-morphotype) while the majority of ME lack this character (E-morphotype). The main goal of our study was to find out whether morphological differences between ME and MT persist in populations along the Barents Sea coast, and to develop practical recommendations for mussel species identification by morphotype. We also analyzed congruence between species and morphotype in limited collections of ME and MT from other regions of the Ocean where two species co-occur. In the Barents Sea estuaries (salinity as in the Whites Sea) differences in morphotype frequencies between МЕ and МТ were nearly as large as in the White Sea (65 % and 77%, correspondingly). In more oceanic habitats differences were much lower (41% on average, due to the increased frequency of Т-morphotypes among ME). For the areas where conchological character was in a good agreement with species genotype, relationships between frequency of T-morphotype in a population sample, expected frequency of МЕ and МТ, and accuracy of individual mussel identification by its morphotype are provided.  Analyses of overseas material revealed that there are some prospects for use of the character for species identification in Western Atlantics (and Scotland?), but not in Western Norway and the Baltic Sea."
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning = FALSE, message = FALSE)
library(knitr)

```

<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }
td {  /* Table  */
  font-size: 20px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>






## Как я вижу задачу

Исходя из приведенного абстракта (с которым я, в принципе, согласен) работа состоит из двух частей.  В первой части мы покажем как работает морфологический признак в беломорско-баренцевоморском регионе. Во второй части -- как выглядит встречаемость данного признака в разных географических выделах. 

Ниже приводится мой взгляд на решения для первой части работы. Я привожу максимально подробную систему доказательств. Многое из приведенного ниже можно сократить и свести в какие-то общие картинки.


## Условные вероятости 

С какой вероятностью мы можем узнавать по T-морфотипу M.trossulus, а по E-морфотипу  M.edulis? В терминах теории вероятности это называется ***условная вероятность***: $P(MT|T)$ вероятность быть M.trossulus, если известно, что мидия имеет T-морфотип, аналогично $P(ME|E)$.



Согласно теореме Байеса

$P(MT|T) = \frac{P(T|MT)P(MT)}{P(T|MT)P(MT) + P(T|ME)P(ME)}$ (Eq 1)

$P(ME|E) = \frac{P(E|ME)P(ME)}{P(E|ME)P(ME) + P(E|MT)P(MT)}$ (Eq 2)

где

$P(MT|T)$ - вероятность быть M.trossulus если мидия имеет T-морфотип

$P(ME|E)$ - вероятность быть M.edulis если мидия имеет E-морфотип 

$P(T|MT)$ - вероятность встретить T-морфотип среди M.trossulus

$P(E|ME)$ - вероятность встретить E-морфотип среди M.edulis

$P(MT)$ - вероятность встретить M.trossulus

$P(ME)$ - вероятность встретить M.edulis


К сожалению, взять и просто рассчитать подобные вероятности нельзя по двум причинами. Во-первых, оценки $P(MT)$ и $P(ME)$ основаны на *не*независимых выборках.  Из-за того, что наши пробы сгруппированы переменной `pop`в оценке вероятности могут проявляться локальные эффекты, смещающие вероятности. Во-вторых, диагностическая ценность морфологического признака может варьировать в связи с какими-то переменным (географические выделы, соленость и т.п.). 

В связи с этим необходимо построить "феноменологическую" модель, описывающую поведение эмпирических данных. При этом модель должна характеризовать взаимосвязь $P(MT|T)$ (аналогично для $P(ME|E)$) не только с $P(MT)$ (или $P(ME) = 1 - P(MT)$), но и с двумя другими предикторами, которые потенциально могут играть роль в изменении характера этой связи -- это географический выдел (море, переменная `sea`) и присутствие постоянного опреснения (близость к устью больших рек, переменная `sal_place`). Модель должна включать случайный фактор `pop`, который определяет внутриклассовые корреляции в выборках.


## Модель

### Читаем данные

```{r}
library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)
library(pROC)



myt <- read.table("data_salinity3.csv", header = T, sep = ";")

myt$Sp [myt$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt$Sp [myt$str <= 0.5] <- "M.edulis"
myt$Sp <- factor(myt$Sp)

# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]


# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)

#Оставляем только данные, на основе, которых строится модель
myt3 <- myt2[myt2$dataset == "testing", ]
myt2 <- myt2[myt2$dataset == "training", ]

```


Для дальнейшего построения модели мы введем переменную `congr` (от "congruence"), которая принимает значение 1 если мидия имеет T-морфотип и относится к M.trossulus или имеет E-морфотип и относится к M.edulis.  В остальных случаях она приобретает значение 0. Эта переменная характеризует событие правильного определения вида по морфотипу. Модель должна описывать поведение вероятности этого события от следующих предикторов:
- доля M.trossulus в популяции (`freq_MT`) 
- морфотип (`morph`)
- море (`sea`)
- присутствие опреснения (`sal_place`)
- Все взаимодействия предикторов.  



```{r}
myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )


# Частота M.trossulus в популяции, вычисленная как срденее значение structure
freq_MT <- summaryBy( str ~ pop, data = myt2)
names(freq_MT) <- c("pop", "freq_MT")

myt2 <- merge(myt2, freq_MT)


```


### Строим собственно модель

```{r}
Mod_fT_congr <- glmer(congr ~ morph * freq_MT*sea*sal_place + (1 | pop), data = myt2, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

Mod_fT_congr_a <- glmer(congr ~ (morph + freq_MT + sea + sal_place)^2 + (1 | pop), data = myt2, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

AIC(Mod_fT_congr, Mod_fT_congr_a)

```

Модель со всеми взаимодействиями лучше. Следовательно ее и возьмем за основу

### Диагностика модели 

```{r}
Mod_fT_congr_diagn <- fortify(Mod_fT_congr)

ggplot(data = Mod_fT_congr_diagn, aes(x = .fitted, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "loess") # Идеально!


# Переменные из модели

ggplot(Mod_fT_congr_diagn, aes(x = morph, y = .scresid)) + geom_boxplot() #Норм!

ggplot(Mod_fT_congr_diagn, aes(x = sea, y = .scresid)) + geom_boxplot() #Норм!

ggplot(Mod_fT_congr_diagn, aes(x = sal_place, y = .scresid)) + geom_boxplot() #Норм!

ggplot(Mod_fT_congr_diagn, aes(x = freq_MT, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "loess") # Идеально!

ggplot(Mod_fT_congr_diagn, aes(x = sal_place, y = .scresid)) + geom_boxplot() #Норм!


# Переменные не включенные в модель

ggplot(Mod_fT_congr_diagn, aes(x = size, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "loess") #Приемлемо

ggplot(Mod_fT_congr_diagn, aes(x = str, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "gam") #Не очень хорошо! Полагаю это результат плавающей границы между видами. Не везде ее надо проводить по значению str = 0.5.

ggplot(Mod_fT_congr_diagn, aes(x = Sp, y = .scresid)) + geom_boxplot() #Есть слабый паттерн, но он опять же, я думаю, связан с тем, что граница между видами в разных популяциях должна проводиться по разным значениям structure

ggplot(Mod_fT_congr_diagn, aes(x = place, y = .scresid)) + geom_boxplot()  #Норм!

```


### Упрощение модели

```{r}
drop1(Mod_fT_congr, test = "Chi")

Mod_fT_congr2 <- update(Mod_fT_congr_a, .~.-morph:freq_MT:sea:sal_place )
drop1(Mod_fT_congr2, test = "Chi")

Mod_fT_congr3 <- update(Mod_fT_congr2, .~.-freq_MT:sal_place )
drop1(Mod_fT_congr3, test = "Chi")

Mod_fT_congr4 <- update(Mod_fT_congr3, .~.-sea:sal_place)
drop1(Mod_fT_congr4, test = "Chi")

Mod_fT_congr5 <- update(Mod_fT_congr4, .~.-morph:sea)
drop1(Mod_fT_congr5, test = "Chi")

Mod_fT_congr_fin <- Mod_fT_congr5

```

### Диагностика финальной модели

```{r}
# Оставляю пока Mod_fT_congr3 в качестве финальной модели
Mod_fT_congr_diagn <- fortify(Mod_fT_congr_fin)

ggplot(data = Mod_fT_congr_diagn, aes(x = .fitted, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "loess") # Идеально!


# Переменные из модели

ggplot(Mod_fT_congr_diagn, aes(x = morph, y = .scresid)) + geom_boxplot() #Норм!

ggplot(Mod_fT_congr_diagn, aes(x = sea, y = .scresid)) + geom_boxplot() #Норм!

ggplot(Mod_fT_congr_diagn, aes(x = sal_place, y = .scresid)) + geom_boxplot() #Норм!

ggplot(Mod_fT_congr_diagn, aes(x = freq_MT, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "loess") # Идеально!

ggplot(Mod_fT_congr_diagn, aes(x = sal_place, y = .scresid)) + geom_boxplot() #Норм!


# Переменные не включенные в модель

ggplot(Mod_fT_congr_diagn, aes(x = size, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "loess") #Приемлемо

ggplot(Mod_fT_congr_diagn, aes(x = str, y = .scresid, color = sea)) + geom_point() + geom_smooth(method = "gam") #Не очень хорошо! Полагаю это результат плавающей границы между видами. Не везде ее надо проводить по значению str = 0.5.

ggplot(Mod_fT_congr_diagn, aes(x = Sp, y = .scresid)) + geom_boxplot() #Есть слабый паттерн, но он опять же, я думаю, связан с тем, что граница между видами в разных популяциях должна проводиться по разным значениям structure

ggplot(Mod_fT_congr_diagn, aes(x = place, y = .scresid)) + geom_boxplot()  #Терпимо!




```


Итого. Модель мы сократили, но несмотря на насилие, полученная финальная модель оказалась лучше исходной. 

```{r}
AIC(Mod_fT_congr,Mod_fT_congr_fin)
```




### Финальная модель 

Вот анализ девиансы для финальной модели.

```{r}
Anova(Mod_fT_congr_fin)
```


Визуализация модели


```{r}
newdata <- myt2 %>% group_by(sea, morph, sal_place) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))

# Предсказанные значеня в шкале вероятностей
newdata$fit <- predict(Mod_fT_congr_fin, newdata = newdata, type = "response", re.form = NA) 

# Предсказанные значеня в шкале логитов
newdata$fit_eta <- predict(Mod_fT_congr_fin, newdata = newdata, re.form = NA) 

# Вычисление доверительного инеравала

# formula((Mod_fT_congr_fin)) 

X <- model.matrix(  ~ morph + freq_MT + sea + sal_place + morph:freq_MT + 
    morph:sal_place + freq_MT:sea, data = newdata) #Модельная матрица для визуализации


# Ошибки в шкале логитов
newdata$se_eta <- sqrt(diag(X %*% vcov(Mod_fT_congr_fin) %*% t(X)))

logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация

# Границы доверительных интервалов в масштабах вероятностей
newdata$lwr <- logit_back(newdata$fit_eta - 2 * newdata$se_eta)
newdata$upr <- logit_back(newdata$fit_eta + 2 * newdata$se_eta)

# newdata$lwr <- probit_back(newdata$fit_eta - 2 * newdata$se_eta)
# newdata$upr <- probit_back(newdata$fit_eta + 2 * newdata$se_eta)


Pl_fit <- ggplot(newdata, aes(x = freq_MT, y = fit)) + geom_ribbon(aes(ymin = lwr, ymax = upr, group = morph), alpha = 0.2)  + geom_line(aes(color = morph), size=1) + facet_grid(sea ~ sal_place) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification", x = "Proportion of M.trossulus", color = "Morphotype") + theme(legend.position = "bottom")

Pl_fit
```

Поскольку данная модель предсказывает вероятность корректного определения для индивидуальной мидии, у которой переменная отклика может принимать значение только 1 или 0, то представить первичные данные на этом графике сложно. Поэтому в качестве прокси для первичных данных мы можем изобразить точки, отражающие доли корректных определений в отдельных популяциях в зависимости от доли M.trossulus в данной популяции.  


```{r}
correct_prop <- summaryBy(congr + freq_MT  ~ pop + sea + morph + sal_place, data = myt2)


Pl_fit_init_data <- Pl_fit + geom_point(data = correct_prop, aes(x = freq_MT.mean, y = congr.mean, color = morph), size = 2)

Pl_fit_init_data
```


На данном графике можно нанести кривые, соответствующие условным вероятностям, основанным на оценках 
$P(T|MT)$, $P(E|ME)$, $P(MT)$ и $P(ME) = 1 - P(MT)$ для каждого из четырех выделов.

```{r}

myt2$Location <- paste(myt2$sea,"_", myt2$sal_place, sep = "") #Перемменная для кодирования четырех выделов


# Функция для вычисления условных вероятностей

probs_calc <- function(variable = "Location", place = "white_fresh") {
  n <- which(names(myt2) == variable)
  d <- myt2[myt2[,n] == place, ]
  dd <- melt(table(d$Sp, d$morph))
  freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)

  P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
  P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
  # P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)

  P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
  P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
  # P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)


  probs <- data.frame(P_MT = seq(0, 1, 0.01), P_MT_T = NA, P_ME_E = NA)

  probs$P_MT_T <- with(probs, (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT)))
  probs$P_ME_E <- with(probs, (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)  )

  probs[,4] <- place
  names(probs)[4] <- variable
  probs

}



probs_all <- rbind(probs_calc(place = "white_normal"), probs_calc(place = "white_fresh"), probs_calc(place = "barents_fresh"), probs_calc(place = "barents_normal") )

probs_all$sea <- ifelse(probs_all$Location == "white_normal" | probs_all$Location == "white_fresh", "white", "barents") 

probs_all$sal_place <- ifelse(probs_all$Location == "barents_normal" | probs_all$Location == "white_normal", "normal", "fresh") 


Pl_fit_init_data + geom_line(data = probs_all, aes(x = P_MT,  y = P_MT_T), color = "red", linetype = 2) + geom_line(data = probs_all, aes(x = P_MT,  y = P_ME_E), color = "blue", linetype = 2)

```

Наверное важно, что в Баренцевом море наблюдаемая связь хорошо соотносится с теоретически ожидаемой. Это означает, видим, что локальные эффекты в Баренцевом море не очень сильны. В Белом море, видимо, они очень сильны, вследствие чего наблюдаемые кривые сильно отличаются от ожидаемых. 


<!-- # Лирическое отступление, в котором главный герой посыпает голову пеплом... -->

<!-- **Внимание!** В предыдущих репортах я, кажись, налажал в расчетах условных вероятнстей (возможно, неправильно написал форулы). Поэтому проверьте, пожалуйста, все калькуляции баесовских кривулин вручную, построив их в экселе!!!  -->

<!-- Вот таблички, которые для этого должны понадобиться. -->

<!-- ```{r, echo=FALSE} -->
<!-- frequences <- function(variable = "Location", place = "white_fresh") { -->
<!--   n <- which(names(myt2) == variable) -->
<!--   d <- myt2[myt2[,n] == place, ] -->
<!--   dd <- melt(table(d$Sp, d$morph)) -->
<!--   freq_dd <- dcast(data = dd, formula = Var2 ~ Var1) -->
<!--   freq_dd -->
<!-- } -->

<!-- ``` -->


<!-- Для Белого моря для опресненных участков -->
<!-- ```{r, echo=FALSE} -->
<!-- frequences(place = "white_fresh") -->
<!-- ``` -->

<!-- Для Белого моря для неопресненных участков -->
<!-- ```{r, echo=FALSE} -->
<!-- frequences(place = "white_normal") -->
<!-- ``` -->


<!-- Для Баренцева моря для опресненных участков -->
<!-- ```{r, echo=FALSE} -->
<!-- frequences(place = "barents_fresh") -->
<!-- ``` -->



<!-- Для Баренцева моря для неопресненных участков -->
<!-- ```{r, echo=FALSE} -->
<!-- frequences(place = "barents_normal") -->
<!-- ``` -->

<!-- Если кривулины получатся другими, то срочно дайте знать.  -->

<!-- ------------------------- -->

## Трактовка модели

Что мы видим, глядя на полученные графики? 



1. Хотя эмпирические кривые идут более или менее сонаправленно с ожидаемыми баесовскими кривыми. Однако полного соответствия баесовских кривых и эмпирически подобранных линий регрессии нет. Это, вероятно, следствие того самого наличия группирующих факторов (`pop`). 

2. Вероятность правильного определения (можно называть это *accuarcy*) явно разная в разных морях и явно зависит от солености. Это лучше будет видно, если мы объединим графики. 

```{r, echo=FALSE}
 ggplot(newdata, aes(x = freq_MT, y = fit, linetype = sal_place))  + geom_line(aes(color = morph), size=1) + geom_ribbon(aes(ymin = lwr, ymax = upr, fill = morph), alpha = 0.2) + facet_wrap( ~ sea) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification", x = "Proportion of M.trossulus", color = "Morphotype", linetype = "Freshness") + guides(fill = "none") + theme(legend.position = "bottom")
```


В Баренцевом море вероятность правильного определения по T-морфотипу в опресненных местах резко выше, чем в не опресненных. При идентификации по E-морфотипу различия меньше, но тоже явно присутствуют. В Белом море тенденция аналогичная, но менее ярко выраженная. НО! Самое важное, что вогласно эмпирическим данным, соответствие E-морфотипа виду M.edulis в двух морях не очень зависит от солености. А вот соответствие  T-морфотипа виду M.trossulus сильно уменьшается в неопресненных местах.

Все то же самое можно показать и с помощью ROC-анализа.

# ROC-анализ

Этот анализ позволяет оценить насколько используемый признак (в нашем случае морфотип) позволяет идентифицировать бинарные классы (*M.trossulus* (positive outcome) vs *M.edulis* (negative outcome)).
Вот так выглядят ROC-кривые для каждого из выделов.

```{r, echo=TRUE} 

#ROC-анализ для каждого выдела
ROC_white_fresh <- roc(Sp ~ ind, data = myt2[myt2$Location =="white_fresh", ], ci = TRUE)
ROC_curve_white_fresh <- data.frame(sensitivity = ROC_white_fresh$sensitivities, specif = ROC_white_fresh$specificities, sea = "white", sal_place = "fresh") 

ROC_white_normal <- roc(Sp ~ ind, data = myt2[myt2$Location =="white_normal", ], ci = TRUE)
ROC_curve_white_normal <- data.frame(sensitivity = ROC_white_normal$sensitivities, specif = ROC_white_normal$specificities, sea = "white", sal_place = "normal") 


ROC_barents_normal <- roc(Sp ~ ind, data = myt2[myt2$Location =="barents_normal", ], ci = TRUE)
ROC_curve_barents_normal <- data.frame(sensitivity = ROC_barents_normal$sensitivities, specif = ROC_barents_normal$specificities, sea = "barents", sal_place = "normal") 


ROC_barents_fresh <- roc(Sp ~ ind, data = myt2[myt2$Location =="barents_fresh", ], ci = TRUE)
ROC_curve_barents_fresh <- data.frame(sensitivity = ROC_barents_fresh$sensitivities, specif = ROC_barents_fresh$specificities, sea = "barents", sal_place = "fresh") 


#ROC-кривые, вычисленные специализированной функцией
ROC_curves <- rbind(ROC_curve_white_fresh, ROC_curve_white_normal, ROC_curve_barents_fresh, ROC_curve_barents_normal)



# Находим вероятности правильного определения для каждой популяции
pops <- summaryBy(Location ~ pop, data = myt2, FUN = function(x) unique(x), keep.names = T)

pops$sea <- ifelse(pops$Location == "white_normal" | pops$Location == "white_fresh", "white", "barents") 
pops$sal_place <- ifelse(pops$Location == "barents_normal" | pops$Location == "white_normal", "normal", "fresh") 

accur_MT <- summaryBy(congr ~ pop + Sp, data = myt2[myt2$Sp == "M.trossulus", ])
names(accur_MT)[3] <- "congr_MT"

accur_ME <- summaryBy(congr ~ pop + Sp, data = myt2[myt2$Sp != "M.trossulus", ])
names(accur_ME)[3] <- "congr_ME"

aa <- merge(accur_MT, accur_ME, by = "pop")

Aaccuracy <- merge(aa, pops, by = "pop")

ggplot(Aaccuracy, aes(y = congr_MT, x = congr_ME)) + geom_point() + scale_x_reverse( lim=c(1,0)) + geom_path(data = data.frame(spec = c(1,0), sens = c(0,1)), aes(x =spec, y = sens)) + facet_grid( sea ~ sal_place )+ geom_path(data = ROC_curves, aes(x = specif, y = sensitivity), color = "blue", size = 1)  + geom_path(data = probs_all, aes(x=P_ME_E, y = P_MT_T), color = "red") + theme_bw() + labs(x = "Specificity", y = "Sensibility")

```

Здесь синяя линия -- это ROC-кривая построенная специализированной функцией из пакета pROC. Красная линия -- то что получается по идее П.П.С., если нанести вероятность правильного определения (accuracy) для M.trossulus vs 1-вероятность правильного определения (accuracy) для M.edulis. Точки -- это отдельные популяции.    



Сами по себе ROC-кривые, впрочем, рисовать нет смысла, но имеет смысл рассмотреть величину AUC (area under curve), которая показывает насколько силен наш признак, как дискриминирующий сигнал. 

Если оценить величину AUC в каждой отдельной популяции, то  распределение значений будет отражаться следующим графиком. 

```{r}
library(pROC)

ROC <- data.frame(AUC = rep(NA, length(unique(myt2$pop)) ))

i <- 1
for(pop in unique(myt2$pop)){
  d <- myt2[myt2$pop == pop, ]
  if(sum(d$ind) != 0){
    ROC$AUC[i] <- roc(d$Sp ~ d$ind)$auc
      
  }
  else
    ROC$AUC[i] <-NA

    ROC$pop [i] <- pop
  
  i <- i+1
}


myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)

salinity <- summaryBy(sal_place ~ pop + sea, FUN = function(x) mean(x), data = myt2, keep.names = T)

Spec_freq <- summaryBy(str + Sp2 ~ pop + sea, data = myt2)

dd <- merge(ROC, salinity)
dd <- merge(dd, Spec_freq)
ROC_sal <- dd 

ROC_sal$sal_place <- factor(ROC_sal$sal_place)

levels (ROC_sal$sal_place) = c("fresh", "normal")

ggplot(ROC_sal, aes(x = sal_place, y = AUC, fill = sea)) + geom_boxplot(notch = F) + theme_bw() +
theme(legend.position = "bottom") + labs(x = "Salinity condition") 
```


**At!** В данный анализ не включены точки, где AUC для локальной популяции вычислить не удается. Вот эти точки: `r ROC$pop[is.na(ROC$AUC)]`



Однако все это можно нарисовать и компактнее. ROC-анализ позволяет вычислять доверительные интервалы (бутстреп, но какой именно я пока не разобрался), что позволяет нарисовать вот  такую картинку. 

```{r}
ROC_result <- data.frame(sea = rep(c("white", "barents"), each = 2), sal_place = rep(c("fresh", "normal"), 2), CI_low = NA, AUC = NA, CI_up = NA)

ROC_result[1, 3:5] <- as.numeric(ROC_white_fresh$ci)
ROC_result[2, 3:5] <- as.numeric(ROC_white_normal$ci)
ROC_result[3, 3:5] <- as.numeric(ROC_barents_fresh$ci)
ROC_result[4, 3:5] <- as.numeric(ROC_barents_normal$ci)

ggplot(ROC_result, aes(x = sal_place, y = AUC)) + geom_col(fill = "blue") + geom_errorbar(aes(ymin = CI_low, ymax = CI_up), width = 0.2) + facet_wrap(~sea) + geom_hline(yintercept = 0.5, linetype = 2) + labs(x = "Salinity condition") + theme_bw()
```


Видно, что везде, кроме баренцевоморской части с нормальной соленостью, дискриминирующая сила морфотипа практически одинакова и достаточно высока (около 0.8). 

**NB!** В условиях с нормально соленостью в Баренцевом море AUC = 0.5 не входит в доверительный интервал, что говорит о том, что даже и в этих условиях по язычку определение значимо отличается от простого подбрасывания монетки.

Таким образом, саму возможность использования морфологического сигнала для определения видовой принадлежности мидии можно считать доказанной.

**Предложение** Может с ROC-анализа начать статью? Показать, что все работает, но потом уже копаться в тонкостях с моделями, которые, по сути, показывают все то же самое. 



**Итого** Самое важное из того, что было написано выше - это то, что морфологический признак работает, но работает хорошо в условиях опреснения, а в условиях нормальной океанической солености работать, если и не перестает, то по крайней мере имеет меньшую диагностическую силу. Теперь осталось как-то приспособить это знание к предсказаниям.   


Весь проект имеет смысл если мы можем, зная морфотип мидии, предсказать для нее вероятность быть определенной до вида. К сожалению, природа условной вероятности такова, что мы не можем игнорировать генетическую структуру популяции (долю M.trossulus в популяции), для оценки которой необходимо знать к какому виду относятся мидии. Здесь появляется порочный круг. Разорвать его можно двумя способами:

1. Можно тупо построить модель, описывающую связь между долей T-морфотипа в популяции и долей M.trossulus.
2. Принимая во внимание, что морфологический признак работает, построить модель, связывающую вероятность правильного определения, с долей T-морфотипа в популяции. 


## Способ №1

 Зависимая переменная здесь -- это пропорция M.trossulus в популяции, которая определена от 0 до 1. К сожалению, описать такую связь простой линейной регрессией будет неправильно. Необходимо строить так называемую бета-регрессию, в которой зависимая величина подчиняется не нормальному, а бета-распределению. Ничего страшного, но это надо иметь ввиду.  

```{r}
library(betareg)


prop_T_MT <- summaryBy(Sp2 + ind  ~ pop + sea + sal_place, data = myt2, keep.names = T)
names(prop_T_MT)[4:5] <- c("prop_MT", "Prop_T")

prop_T_MT$prop_MT_adj <-prop_T_MT$prop_MT
prop_T_MT$prop_MT_adj[prop_T_MT$prop_MT_adj == 0] <- 0.00000001 # Это нужно, так как бета распределение не включает 0 и 1 в область определения.


Model_T_MT <- betareg(prop_MT_adj ~ Prop_T*sea*sal_place, data = prop_T_MT) 
```



Вот анализ девиансы для этой модели. 


```{r}
Anova(Model_T_MT)

```

Эту модель явно нужно упростить. Вот такая получилась упрощенная модель. 



```{r}
library(lmtest)

Model_T_MT2 <- betareg(prop_MT_adj ~ Prop_T + sea*sal_place, data = prop_T_MT)  

lrtest(Model_T_MT, Model_T_MT2)
```

Существенных различий между полной и сокращенной моделями нет.

Вот анализ девиансы для сокращенной модели.

```{r}
Anova(Model_T_MT2)
```

Важная особенность полученной модели: коэффициент, связывающий долю T-морфотипа с долей M.trossulus не изменяется от моря к морю и от одних условий солености к другим.  



## Визуализация модели


```{r}

new_data <- prop_T_MT %>% group_by(sea, sal_place) %>% do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 100)))

new_data$fit <- predict(Model_T_MT2, newdata = new_data,  type="response")


ggplot(prop_T_MT, aes(x = Prop_T, y = prop_MT_adj, color = sal_place)) + geom_point(aes(color = sal_place)) + facet_grid( ~ sea) + geom_line(data = new_data, aes(x = Prop_T, y = fit, group = sal_place), size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population", y = "Proportion of M.trossulus", color = "Freshness")



```

Ниже приведены коэффициенты этой модели, пользуясь которыми можно предсказать долю M.trossulus в популяции в зависимости от доли T-морфотипа (надо только помнить, что эти коэффициенты в шкале логитов).  

```{r}
summary(Model_T_MT2)

```

Согласно этим результатам, связь между долей T-морфотипа и долей M.trossulus в популяции описывается следующими уравннеиями.

Юля! ИСправь здесь коэффициенты сама, они были получены на предыдущих данных.



В Белом море неопресненный   участок: $P_{MT} = \frac{e^{-3.1 + 5.8P_T}}{1+e^{-3.1 + 5.8P_T}}$

В Белом море опресненый участок: $P_{MT} = \frac{e^{-3.1 + 5.9P_T}}{1+e^{-3.1 + 5.9P_T}}$


В Баренцевом море неопресненный участок:$P_{MT} = \frac{e^{-4.3 + 5.9P_T}}{1+e^{-4.3 + 5.9P_T}}$

Б Баренцевом море опресненный участок: $P_{MT} = \frac{e^{-2.3 + 5.9P_T}}{1+e^{-2.3 + 5.9P_T}}$





Посмотрим, будет ли работать данная модель на тестовом датасете. 

```{r}
#Наблюдаемая доля T-морфотипа
test_fr_T <- summaryBy( ind ~ sea + sal_place + pop, data = myt3)
names(test_fr_T)[4] <- "Prop_T" 

#Наблюдаемая доля доля M.trossulus
test_fr_MT <- summaryBy( str ~ sea + sal_place + pop, data = myt3)
names(test_fr_MT)[4] <- "Prop_MT_obs"


#Предсказанная доля M.trossulus
test_fr_MT$Prop_MT_predicted <-  predict(Model_T_MT2, newdata = test_fr_T, type = "response")

ggplot(test_fr_MT, aes(x = Prop_MT_obs, y = Prop_MT_predicted)) + geom_point() + geom_abline() + theme_bw() + labs(x = "Observed proportion of M.trossulus", y = "Predicted poportion of M.trossulus")

```

Вроде точки хорошо ложатся вдоль линии Y=X. 

Далее, возьмем величины доли M.trosulus и вычислим на их основе для каждой мидии из тестового датасета вероятность быть правильно идентифицированной. А далее  посмотрим, как эти величины будут соотноситься с баесовскими кривыми, полученными на основе training data set. 

Вот что получается. Каждая точка здесь -- это популяция, для которой вычислена средняя вероятность правильного определения на основе знаний доли T-морфотипа в популяции. 





```{r}
myt3 <- merge(myt3,test_fr_MT) 
# unique(myt3$pop)
myt3 <- merge(myt3,test_fr_T)


myt3$freq_MT <- myt3$Prop_MT_predicted
# myt3$freq_MT <- myt3$Prop_T

myt3$congr_predicted <- predict(Mod_fT_congr3, newdata = myt3, type = "response", re.form = NA)

Plot_test <- ggplot(myt3, aes(x = freq_MT, y = congr_predicted)) + geom_point(aes(color = morph), size = 4) + facet_wrap(~sal_place) + scale_color_manual(values = c("blue", "red")) + geom_line(data = probs_all[probs_all$sea == "barents", ], aes(x = P_MT, y = P_MT_T), color = "red", linetype = 2) + geom_line(data = probs_all[probs_all$sea == "barents", ], aes(x = P_MT, y = P_ME_E), color = "blue", linetype = 2) + theme_bw() + labs(x = "Proportion of M.trossulus or T-morphotype", y = "Probability of correct identification") + scale_x_continuous(breaks = seq(0, 1, 0.1)) + scale_y_continuous(breaks = seq(0, 1, 0.1))

T_morph_labels <- data.frame(freq_MT = rep(seq(0, 1, 0.1), 2), sal_place = rep(c("fresh", "normal"), each = 11), b0 = rep(c(-2.3,-4.3), each = 11), b1 = rep(c(5.9, 5.9), each = 11) ) 

T_morph_labels$freq_T <- round(with(T_morph_labels, (log(freq_MT/(1-freq_MT))-b0)/b1), 1)

T_morph_labels$freq_T[T_morph_labels$freq_T < 0 | T_morph_labels$freq_T > 1] <- NA

Plot_test + geom_text(data = T_morph_labels, aes(x =  freq_MT, y = 0, label = freq_T))

```

















