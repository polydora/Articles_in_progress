Model_T_MT_final_result$p.value <- round(Model_T_MT_final_result$p.value, 4)
kable(Model_T_MT_final_result, col.names = c("Model term", "Estimated value", "SE", "Chi sq.", "p-value"))
new_data <- prop_T_MT %>% group_by(Subset) %>% do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 100)))
predicted <- predict(Model_T_MT_final, newdata = new_data,  type="response", se.fit = TRUE)
new_data$fit <- predicted$fit
new_data$SE <- predicted$se.fit
# ggplot(prop_T_MT, aes(x = Prop_T, y = prop_MT_adj, color = sal_place)) + geom_point(aes(color = sal_place)) + facet_grid( ~ sea) + geom_line(data = new_data, aes(x = Prop_T, y = fit, group = sal_place), size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population", y = "Proportion of M.trossulus", color = "Freshness")
new_data$Subset <- factor(new_data$Subset, levels = c("White", "Barents_fresh", "Barents_normal"))
ggplot(data = new_data, aes(x = Prop_T, y = fit, linetype = Subset))  + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE, fill = Subset),  alpha = 0.2) + geom_line(size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population (PT)", y = "M.trossulus prevalence (MTprev)") + geom_abline() + geom_point(data = prop_T_MT, aes(x = Prop_T, y = Prop_MT, shape = Subset), size = 2) + geom_point(data = prop_T_MT_testing, aes(x = Prop_T, y = Prop_MT), shape = 21, size = 4, fill = "white") + facet_wrap( ~ Subset, ncol = 3) + theme(legend.position = "bottom") + guides(shape = "none")
ggplot(data = new_data, aes(x = Prop_T, y = fit, linetype = Subset))  + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE, fill = Subset),  alpha = 0.2) + geom_line(size = 1) + theme_bw() + labs(x = "Proportion of T-morphotype in population", y = "Proportion of M.trossulus") + geom_abline() + geom_point(data = prop_T_MT, aes(x = Prop_T, y = Prop_MT, shape = Subset), size = 2) + geom_point(data = prop_T_MT_testing, aes(x = Prop_T, y = Prop_MT), shape = 21, size = 4, fill = "white")
#ROC-анализ для каждого выдела
library(pROC)
myt2$Location <- myt2$Subset #Перемменная для кодирования трех выделов
ROC_white <- roc(Sp ~ ind, data = myt2[myt2$Location =="White", ], ci = TRUE)
# ROC_curve_white_fresh <- data.frame(sensitivity = ROC_white_fresh$sensitivities, specif = ROC_white_fresh$specificities, sea = "white", sal_place = "fresh")
# ROC_white_normal <- roc(Sp ~ ind, data = myt2[myt2$Location =="white_normal", ], ci = TRUE)
# ROC_curve_white_normal <- data.frame(sensitivity = ROC_white_normal$sensitivities, specif = ROC_white_normal$specificities, sea = "white", sal_place = "normal")
ROC_barents_normal <- roc(Sp ~ ind, data = myt2[myt2$Location =="Barents_normal", ], ci = TRUE)
# ROC_curve_barents_normal <- data.frame(sensitivity = ROC_barents_normal$sensitivities, specif = ROC_barents_normal$specificities, sea = "barents", sal_place = "normal")
ROC_barents_fresh <- roc(Sp ~ ind, data = myt2[myt2$Location =="Barents_fresh", ], ci = TRUE)
# ROC_curve_barents_fresh <- data.frame(sensitivity = ROC_barents_fresh$sensitivities, specif = ROC_barents_fresh$specificities, sea = "barents", sal_place = "fresh")
# #ROC-кривые, вычисленные специализированной функцией
# ROC_curves <- rbind(ROC_curve_white_fresh, ROC_curve_white_normal, ROC_curve_barents_fresh, ROC_curve_barents_normal)
#
# Сравнение AUC для разных сабсетов
# roc.test(ROC_barents_normal, ROC_barents_fresh, paired = FALSE)
# roc.test(ROC_barents_normal, ROC_white, paired = FALSE)
# roc.test(ROC_barents_fresh, ROC_white, paired = FALSE)
ROC_result <- data.frame(Subset = c("White", "Barents_fresh", "Barents_normal"),  CI_low = NA, AUC = NA, CI_up = NA)
ROC_result[1, 2:4] <- as.numeric(ROC_white$ci)
ROC_result[2, 2:4] <- as.numeric(ROC_barents_fresh$ci)
ROC_result[3, 2:4] <- as.numeric(ROC_barents_normal$ci)
ggplot(ROC_result, aes(x = Subset, y = AUC)) + geom_col(fill = "blue") + geom_errorbar(aes(ymin = CI_low, ymax = CI_up), width = 0.2) + geom_hline(yintercept = 0.5, linetype = 2) + theme_bw() + geom_text(aes(y = c(0.9,  0.9, 0.7), label = c("a", "a", "b")))
myt2_reduced <- myt2
# myt2_reduced <- myt2[!(myt2$pop %in% c("nm", "padan", "umba_06", "umba_bridge", "umba_pioner", "vor2")), ]
# unique(myt2$pop)
Mod_fT_congr <- glmer(congr ~ morph * freq_MT*Subset + (1 | pop), data = myt2_reduced, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
# Проверка на сверхдисперсию
overdisp_fun(Mod_fT_congr)
drop1(Mod_fT_congr, test = "Chi")
Mod_fT_congr2 <- update(Mod_fT_congr, .~.-morph:freq_MT:Subset )
drop1(Mod_fT_congr2, test = "Chi")
# Mod_fT_congr3 <- update(Mod_fT_congr2, .~.-freq_MT:sal_place )
# drop1(Mod_fT_congr3, test = "Chi")
#
# Mod_fT_congr4 <- update(Mod_fT_congr3, .~.-sea:sal_place)
# drop1(Mod_fT_congr4, test = "Chi")
#
# Mod_fT_congr5 <- update(Mod_fT_congr4, .~.-morph:sea)
# drop1(Mod_fT_congr5, test = "Chi")
Mod_fT_congr_fin <- Mod_fT_congr2
AIC(Mod_fT_congr,Mod_fT_congr_fin)
Anova(Mod_fT_congr_fin)
tidy(Mod_fT_congr_fin)
newdata <- myt2_reduced %>% group_by(Subset, morph) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))
# Предсказанные значеня в шкале вероятностей
newdata$fit <- predict(Mod_fT_congr_fin, newdata = newdata, type = "response", re.form = NA)
# Предсказанные значеня в шкале логитов
newdata$fit_eta <- predict(Mod_fT_congr_fin, newdata = newdata, re.form = NA)
# Вычисление доверительного инеравала
# formula((Mod_fT_congr_fin))
X <- model.matrix(  ~ morph + freq_MT + Subset + morph:freq_MT +
morph:Subset + freq_MT:Subset, data = newdata) #Модельная матрица для визуализации
# Ошибки в шкале логитов
newdata$se_eta <- sqrt(diag(X %*% vcov(Mod_fT_congr_fin) %*% t(X)))
logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация
# Границы доверительных интервалов в масштабах вероятностей
newdata$lwr <- logit_back(newdata$fit_eta - 2 * newdata$se_eta)
newdata$upr <- logit_back(newdata$fit_eta + 2 * newdata$se_eta)
# newdata$lwr <- probit_back(newdata$fit_eta - 2 * newdata$se_eta)
# newdata$upr <- probit_back(newdata$fit_eta + 2 * newdata$se_eta)
Pl_fit <- ggplot(newdata, aes(x = freq_MT, y = fit)) + geom_ribbon(aes(ymin = lwr, ymax = upr, group = morph), alpha = 0.2)  + geom_line(aes(color = morph), size=1) + facet_wrap( ~ Subset) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification \n PPV and NPV", x = "M.trossulus prevalence \n (MTprev)", color = "Morphotype") + theme(legend.position = "bottom")
Pl_fit
correct_prop <- myt2_reduced %>% group_by(Subset,  pop, morph) %>%  do(data.frame(Prop_correct = mean(.$congr), freq_MT = mean(.$freq_MT) ))
Pl_fit_init_data <- Pl_fit + geom_point(data = correct_prop, aes(x = freq_MT, y = Prop_correct, color = morph), size = 1)
Pl_fit_init_data
# Функция для вычисления условных вероятностей
probs_calc <- function(variable = "Subset", place = "White") {
n <- which(names(myt2_reduced) == variable)
d <- myt2_reduced[myt2_reduced[,n] == place, ]
dd <- melt(table(d$Sp, d$morph))
freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)
P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
# P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)
P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
# P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)
probs <- data.frame(P_MT = seq(0, 1, 0.01), P_MT_T = NA, P_ME_E = NA)
probs$P_MT_T <- with(probs, (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT)))
probs$P_ME_E <- with(probs, (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)  )
probs[,4] <- place
names(probs)[4] <- variable
probs
}
probs_all <- rbind(probs_calc(place = "White"), probs_calc(place = "Barents_fresh"), probs_calc(place = "Barents_normal") )
#
# probs_all$sea <- ifelse(probs_all$Location == "white_normal" | probs_all$Location == "white_fresh", "white", "barents")
#
# probs_all$sal_place <- ifelse(probs_all$Location == "barents_normal" | probs_all$Location == "white_normal", "normal", "fresh")
########################### Вычисление таблицы со всеми показателями для регионов
probs_calc_3 <- function(variable = "Subset", place = "White", P_MT = 0.5) {
n <- which(names(myt2_reduced) == variable)
d <- myt2_reduced[myt2_reduced[,n] == place, ]
dd <- melt(table(d$Sp, d$morph))
freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)
P_T_MT <- round(with(data = freq_dd, M.trossulus[2] /(M.trossulus[2] + M.trossulus[1])), 2)
P_T_ME <- round(with(data = freq_dd, M.edulis[2] /(M.edulis[2] + M.edulis[1])), 2)
# P_ME <- round(with(data = freq_dd, sum(M.edulis) /(sum(freq_dd[,-1]))), 2)
P_E_ME <- round(with(data = freq_dd, M.edulis[1] /(M.edulis[1] + M.edulis[2])), 2)
P_E_MT <- round(with(data = freq_dd, M.trossulus[1] /(M.trossulus[1] + M.trossulus[2])), 2)
# P_MT <- round(with(data = freq_dd, sum(M.trossulus) /(sum(freq_dd[,-1]))), 2)
P_MT_T <- (P_T_MT*P_MT)/(P_T_MT*P_MT + P_T_ME*(1-P_MT))
P_ME_E <- (P_E_ME*(1-P_MT))/(P_E_ME*(1-P_MT) + P_E_MT*P_MT)
c(P_MT_T, P_ME_E)
}
freq_calc2 <- function(variable = "Subset", place = "Barents_fresh"){
n <- which(names(myt2_reduced) == variable)
d <- myt2_reduced[myt2_reduced[,n] == place, ]
dd <- melt(table(d$Sp, d$morph))
freq_dd <- dcast(data = dd, formula = Var2 ~ Var1)
#Вероятность встретить M,trossulus среди Т морфотипа оценка условной веротяности P_MT|T
P_MT_T <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.edulis[2])
#Вероятность встретить M.edulis среди E морфотипа
P_ME_E <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])
#Вероятность встретить M.trossulus среди E морфотипа
P_MT_E <- freq_dd$M.trossulus[1]/(freq_dd$M.edulis[1] + freq_dd$M.trossulus[1])
#Вероятность встретить M.edulis среди T морфотипа
P_ME_T <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.trossulus[2])
#Вероятность встретить T морфотп среди M.trossulus морфотипа
P_T_MT <- freq_dd$M.trossulus[2]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])
#Вероятность встретить E морфотп среди M.trossulus морфотипа
P_E_MT <- freq_dd$M.trossulus[1]/(freq_dd$M.trossulus[2] + freq_dd$M.trossulus[1])
#Вероятность встретить T морфотп среди M.edulis морфотипа
P_T_ME <- freq_dd$M.edulis[2]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])
#Вероятность встретить E морфотп среди M.edlis морфотипа
P_E_ME <- freq_dd$M.edulis[1]/(freq_dd$M.edulis[2] + freq_dd$M.edulis[1])
#Вероятность встретить M.trossulus любого морфотипа
P_MT   <- sum(freq_dd$M.trossulus)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
#Вероятность встретить M.edulis любого морфотипа
P_ME   <- sum(freq_dd$M.edulis)/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
#Вероятность встретить M.trossulus T морфотипа
P_MT_of_T   <- (freq_dd$M.trossulus[2])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
#Вероятность встретить M.trossulus E морфотипа
P_MT_of_E   <- (freq_dd$M.trossulus[1])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
#Вероятность встретить M.edulis T морфотипа
P_ME_of_T   <- (freq_dd$M.edulis[2])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
#Вероятность встретить M.edulis E морфотипа
P_ME_of_E   <- (freq_dd$M.edulis[1])/(sum(freq_dd$M.trossulus) + sum(freq_dd$M.edulis))
#Вероятность встретить  E морфотип
P_E   <- sum(freq_dd[1, -1])/sum(freq_dd[,-1])
#Вероятность встретить  T морфотип
P_T   <- sum(freq_dd[2, -1])/sum(freq_dd[,-1])
props <- c(P_MT_T, P_ME_E, P_MT_E, P_ME_T, P_T_MT, P_E_MT, P_T_ME,  P_E_ME, P_MT, P_ME, P_MT_of_T, P_MT_of_E, P_ME_of_T, P_ME_of_E, P_E, P_T)
names(props) <- c("P_MT_T", "P_ME_E", "P_MT_E", "P_ME_T", "P_T_MT", "P_E_MT", "P_T_ME",  "P_E_ME", "P_MT", "P_ME", "P_MT_of_T", "P_MT_of_E", "P_ME_of_T", "P_ME_of_E", "P_E", "P_T")
props
}
All_freq <- data.frame(Barents_normal = freq_calc2(place = "Barents_normal"),
Barents_fresh = freq_calc2(place = "Barents_fresh"),
White = freq_calc2(place = "White"))
tAll_freq <- as.data.frame(t(All_freq))
tAll_freq$Location <- rownames(tAll_freq)
###########################
#### Вводится коррекция в соответствии с тем, что P_MT_T = congr_T/P_T
newdata$Location <- newdata$Subset
newdata_and_freq <- merge(newdata, tAll_freq, by = "Location")
newdata_and_freq$fit_corrected <- ifelse(newdata_and_freq$morph == "T_m",newdata_and_freq$fit / newdata_and_freq$P_T, newdata_and_freq$fit / (1 - newdata_and_freq$P_T) )
Pl_fit_corrected <- ggplot(newdata_and_freq, aes(x = freq_MT, y = fit_corrected)) + geom_line(aes(color = morph), size=1) + facet_grid(sea ~ sal_place) + scale_color_manual(values = c("blue", "red")) + theme_bw() + xlim(0,1)  + labs(y = "Probability of correct identification", x = "Proportion of M.trossulus", color = "Morphotype") + theme(legend.position = "bottom")
Pl_fit_init_data_bayes <- Pl_fit_init_data + geom_line(data = probs_all, aes(x = P_MT,  y = P_MT_T), color = "red", linetype = 2) + geom_line(data = probs_all, aes(x = P_MT,  y = P_ME_E), color = "blue", linetype = 2)
Pl_fit_init_data_bayes
correct_prop_test <- myt3 %>% group_by(Subset,  pop, morph) %>%  do(data.frame(Prop_correct = mean(.$congr), freq_MT = mean(.$freq_MT) ))
Pl_fit_init_data_bayes_test <- Pl_fit_init_data_bayes + geom_point(data = correct_prop_test, aes(x = freq_MT, y = Prop_correct, color = morph), size = 3)
#
# All_freq$Probability_type <- row.names(All_freq)
# All_freq_melt <- melt(All_freq, variable.name = "Subset", value.name = "P")
# All_freq_melt$P <- round(All_freq_melt$P, 2)
#
# All_freq_melt <- All_freq_melt[All_freq_melt$Probability_type %in% c("P_T_MT", "P_E_MT", "P_T_ME", "P_E_ME"), ]
#
# All_freq_melt$X <- rep(c(0.4, 0.6), 3, each = 2)
# All_freq_melt$Y <- rep(c(0.1, 0.2), 6)
freq <- as.data.frame(table(myt2_reduced$Sp2, myt2_reduced$ind, myt2_reduced$Subset))
freq$Var1 <- ifelse(freq$Var1 == "1", "MT", "ME")
freq$Var2 <- ifelse(freq$Var2 == "1", "T", "E")
All_freq_melt <- melt(freq,  id.vars = c("Var1", "Var2", "Var3") )
names(All_freq_melt)[3] <- "Subset"
names(All_freq_melt)[1] <- "Genotype"
names(All_freq_melt)[2] <- "Morphotype"
All_freq_melt$Y <- rep(c(0.1, 0.2), each = 2, 3)
All_freq_melt$X <- rep(c(0.65, 0.5), 6)
lab <- data.frame(Subset = rep(c("Barents_fresh", "Barents_normal", "White"), each = 2))
lab$labs <- rep(c("MT", "ME"), 3)
lab$X = rep(c(0.5, 0.65), 3)
lab$Y <- 0.25
lab2 <- data.frame(Subset = rep(c("Barents_fresh", "Barents_normal", "White"), each = 2))
lab2$labs <- rep(c("T", "E"), 3)
lab2$Y = rep(c(0.2, 0.1), 3)
lab2$X <- 0.4
Pl_fit_init_data_bayes + geom_rect(aes(xmin = 0.35, xmax = 0.75, ymin = 0.05, ymax = 0.29), fill = "white", color = "black") + geom_text(data =  All_freq_melt, aes(x=X, y=Y, label = value), size = 3) +  geom_text(data =  lab, aes(x=X, y=Y, label = labs), size = 3) + geom_text(data =  lab2, aes(x=X, y=Y, label = labs), size = 3)
Prop_T_test <-  myt3 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(ind))
Prop_T_test$freq_MT <- predict(Model_T_MT_final, newdata = Prop_T_test, type = "response")
myt3_test <- data.frame(Subset = myt3$Subset, morph = myt3$morph, pop = myt3$pop, str = myt3$str)
myt3_test_all <- merge(myt3_test, Prop_T_test)
myt3_test_all$Predicted <- predict(Mod_fT_congr_fin, newdata = myt3_test_all, type = "response", re.form = NA)
myt3_test_all$str_predicted <- ifelse(myt3_test_all$morph == "T_m", myt3_test_all$Predicted, (1-myt3_test_all$Predicted))
myt3_test_all$Sp_observed <- ifelse(myt3_test_all$str >= 0.5, 1, 0)
library("jmuOutlier")
Cors_str_predicted <- myt3_test_all %>% group_by(Subset) %>% summarise(Cor = cor(str_predicted, str, method = "spearman"), p = perm.cor.test(str_predicted, str, method = "spearman")[[4]])
myt3_test_all_stat <- myt3_test_all %>% group_by(Subset, pop, morph, str_predicted) %>% summarise(Median_str = median(str))
ggplot(myt3_test_all_stat, aes(x = str_predicted, y = Median_str)) + geom_point(size = 4, shape = 21, aes(fill = morph)) + facet_wrap(~Subset) + geom_abline() + theme_bw() + scale_fill_manual(values = c( "blue", "red")) + labs(x = "Predicted probability to be identified as M.trossulus", y = "Median of observed Structure scores", fill = "Morphotype") + geom_text(data = Cors_str_predicted, aes(x = 0.1, y = 0.9, label = paste("Cor = ",round(Cor, 2), ", p-value = ", round(p *2, 4)) ), hjust = "inward") + theme(legend.position = "bottom")
#
# Mod_correctness_test <- glmer(Sp_observed ~ str_predicted*Subset + (1|pop), data = myt3_test_all, family = binomial(link = "logit"))
#
# # overdisp(Mod_correctness_test)
#
# # drop1(Mod_correctness_test, test = "Chi")
#
#
#
# newdata <- myt3_test_all %>% group_by(Subset) %>% do(data.frame(str_predicted = seq(min(.$str_predicted), max(.$str_predicted), length.out = 100)))
#
# # Предсказанные значеня в шкале вероятностей
# newdata$fit <- predict(Mod_correctness_test, newdata = newdata, type = "response", re.form = NA)
#
# # Предсказанные значеня в шкале логитов
# newdata$fit_eta <- predict(Mod_correctness_test, newdata = newdata, re.form = NA)
#
# # Вычисление доверительного инеравала
#
# # formula((Mod_fT_congr_fin))
#
# X <- model.matrix(  ~ str_predicted*Subset, data = newdata) #Модельная матрица для визуализации
#
#
# # Ошибки в шкале логитов
# newdata$se_eta <- sqrt(diag(X %*% vcov(Mod_correctness_test) %*% t(X)))
#
# logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация
#
# # Границы доверительных интервалов в масштабах вероятностей
# newdata$lwr <- logit_back(newdata$fit_eta - 2 * newdata$se_eta)
# newdata$upr <- logit_back(newdata$fit_eta + 2 * newdata$se_eta)
#
# # newdata$lwr <- probit_back(newdata$fit_eta - 2 * newdata$se_eta)
# # newdata$upr <- probit_back(newdata$fit_eta + 2 * newdata$se_eta)
#
# freq_MT_test <- myt3_test_all %>% group_by(Subset, pop, morph, str_predicted) %>% summarise(freq_MT = mean(Sp_observed))
#
# ggplot(newdata, aes(x = str_predicted, y = fit)) +
#   geom_ribbon(aes(ymin = lwr, ymax = upr, group = Subset), alpha = 0.2) +
#   geom_line(size=1) +
#   geom_point(data = freq_MT_test, aes(x = str_predicted,  y = freq_MT, color = morph), size = 4 ) +
#   facet_wrap( ~ Subset)  +
#   scale_color_manual(values = c("blue", "red"))+
#   geom_abline()+
#   theme_bw() +
#   xlim(0,1)  +
#   labs(x = "Predicted probability to be MT", y = "Observed probability to be MT") + theme(legend.position = "bottom")
#
#
#
a = 0.5 #то как эдулисы гнобят троссулус
b = 0  #то как  троссулус гнобят эдулисов
for(i in 1:nrow(pop_simulated))  pop_simulated[i, 2:5] <- simulate_pop(P_MT = pop_simulated$P_MT[i], P_T_MT = P_T_MT_glob, P_E_ME = P_E_ME_glob)
pop_simulated$P_T_MT <- with(pop_simulated, N_T_MT/(N_T_MT + N_E_MT))
pop_simulated$P_E_MT <- 1 - pop_simulated$P_T_MT
pop_simulated$P_E_ME <- with(pop_simulated, N_E_ME/(N_T_ME + N_E_ME))
pop_simulated$P_T_ME <- 1 - pop_simulated$P_E_ME
pop_simulated$P_MT_comp <- with(pop_simulated, (N_T_MT + N_E_MT - a*(N_T_ME + N_E_ME))/(N_T_MT + N_E_MT + N_T_ME + N_E_ME - a*(N_T_ME + N_E_ME)))
pop_simulated$P_ME_comp <- with(pop_simulated, (N_T_ME + N_E_ME - b*(N_T_MT + N_E_MT))/(N_T_MT + N_E_MT + N_T_ME + N_E_ME - b*(N_T_MT + N_E_MT)))
pop_simulated$P_MT_T <- with(pop_simulated, P_T_MT*P_MT/(P_T_MT*P_MT + P_T_ME*(1-P_MT)))
pop_simulated$P_MT_T_comp <- with(pop_simulated, P_T_MT*P_MT_comp/(P_T_MT*P_MT_comp + P_T_ME*(1-P_MT_comp)))
pop_simulated$P_ME_E <- with(pop_simulated, P_E_ME*(1-P_MT)/(P_E_ME*(1-P_MT) + P_E_MT*P_MT))
pop_simulated$P_ME_E_comp <- with(pop_simulated, P_E_ME*P_ME_comp/(P_E_ME*P_ME_comp + P_E_MT*P_MT_comp))
ggplot(pop_simulated, aes(x = P_MT)) + geom_line(aes(y = P_MT_T), color = "red", linetype = 2) + geom_line(aes(y = P_ME_E), color = "blue", linetype = 2) + geom_point(aes(x = P_MT, y = P_MT_T_comp), color = "red") + geom_point(aes(x = P_MT, y = P_ME_E_comp), color = "blue") + ylim(0,1) + xlim(0,1)  + geom_smooth(aes(x = P_MT, y = P_MT_T_comp),  method = "glm", method.args = list(family = "binomial"), color = "red")  + geom_smooth(aes(x = P_MT, y = P_ME_E_comp),  method = "glm", method.args = list(family = "binomial"), color = "blue") + labs(x = "Proportion of MT without competition", y = "Correct identification")
a = 0.5 #то как эдулисы гнобят троссулус
b = 0.5  #то как  троссулус гнобят эдулисов
for(i in 1:nrow(pop_simulated))  pop_simulated[i, 2:5] <- simulate_pop(P_MT = pop_simulated$P_MT[i], P_T_MT = P_T_MT_glob, P_E_ME = P_E_ME_glob)
pop_simulated$P_T_MT <- with(pop_simulated, N_T_MT/(N_T_MT + N_E_MT))
pop_simulated$P_E_MT <- 1 - pop_simulated$P_T_MT
pop_simulated$P_E_ME <- with(pop_simulated, N_E_ME/(N_T_ME + N_E_ME))
pop_simulated$P_T_ME <- 1 - pop_simulated$P_E_ME
pop_simulated$P_MT_comp <- with(pop_simulated, (N_T_MT + N_E_MT - a*(N_T_ME + N_E_ME))/(N_T_MT + N_E_MT + N_T_ME + N_E_ME - a*(N_T_ME + N_E_ME)))
pop_simulated$P_ME_comp <- with(pop_simulated, (N_T_ME + N_E_ME - b*(N_T_MT + N_E_MT))/(N_T_MT + N_E_MT + N_T_ME + N_E_ME - b*(N_T_MT + N_E_MT)))
pop_simulated$P_MT_T <- with(pop_simulated, P_T_MT*P_MT/(P_T_MT*P_MT + P_T_ME*(1-P_MT)))
pop_simulated$P_MT_T_comp <- with(pop_simulated, P_T_MT*P_MT_comp/(P_T_MT*P_MT_comp + P_T_ME*(1-P_MT_comp)))
pop_simulated$P_ME_E <- with(pop_simulated, P_E_ME*(1-P_MT)/(P_E_ME*(1-P_MT) + P_E_MT*P_MT))
pop_simulated$P_ME_E_comp <- with(pop_simulated, P_E_ME*P_ME_comp/(P_E_ME*P_ME_comp + P_E_MT*P_MT_comp))
ggplot(pop_simulated, aes(x = P_MT)) + geom_line(aes(y = P_MT_T), color = "red", linetype = 2) + geom_line(aes(y = P_ME_E), color = "blue", linetype = 2) + geom_point(aes(x = P_MT, y = P_MT_T_comp), color = "red") + geom_point(aes(x = P_MT, y = P_ME_E_comp), color = "blue") + ylim(0,1) + xlim(0,1)  + geom_smooth(aes(x = P_MT, y = P_MT_T_comp),  method = "glm", method.args = list(family = "binomial"), color = "red")  + geom_smooth(aes(x = P_MT, y = P_ME_E_comp),  method = "glm", method.args = list(family = "binomial"), color = "blue") + labs(x = "Proportion of MT without competition", y = "Correct identification")
a = 0.5 #то как эдулисы гнобят троссулус
b = 0.3  #то как  троссулус гнобят эдулисов
for(i in 1:nrow(pop_simulated))  pop_simulated[i, 2:5] <- simulate_pop(P_MT = pop_simulated$P_MT[i], P_T_MT = P_T_MT_glob, P_E_ME = P_E_ME_glob)
pop_simulated$P_T_MT <- with(pop_simulated, N_T_MT/(N_T_MT + N_E_MT))
pop_simulated$P_E_MT <- 1 - pop_simulated$P_T_MT
pop_simulated$P_E_ME <- with(pop_simulated, N_E_ME/(N_T_ME + N_E_ME))
pop_simulated$P_T_ME <- 1 - pop_simulated$P_E_ME
pop_simulated$P_MT_comp <- with(pop_simulated, (N_T_MT + N_E_MT - a*(N_T_ME + N_E_ME))/(N_T_MT + N_E_MT + N_T_ME + N_E_ME - a*(N_T_ME + N_E_ME)))
pop_simulated$P_ME_comp <- with(pop_simulated, (N_T_ME + N_E_ME - b*(N_T_MT + N_E_MT))/(N_T_MT + N_E_MT + N_T_ME + N_E_ME - b*(N_T_MT + N_E_MT)))
pop_simulated$P_MT_T <- with(pop_simulated, P_T_MT*P_MT/(P_T_MT*P_MT + P_T_ME*(1-P_MT)))
pop_simulated$P_MT_T_comp <- with(pop_simulated, P_T_MT*P_MT_comp/(P_T_MT*P_MT_comp + P_T_ME*(1-P_MT_comp)))
pop_simulated$P_ME_E <- with(pop_simulated, P_E_ME*(1-P_MT)/(P_E_ME*(1-P_MT) + P_E_MT*P_MT))
pop_simulated$P_ME_E_comp <- with(pop_simulated, P_E_ME*P_ME_comp/(P_E_ME*P_ME_comp + P_E_MT*P_MT_comp))
ggplot(pop_simulated, aes(x = P_MT)) + geom_line(aes(y = P_MT_T), color = "red", linetype = 2) + geom_line(aes(y = P_ME_E), color = "blue", linetype = 2) + geom_point(aes(x = P_MT, y = P_MT_T_comp), color = "red") + geom_point(aes(x = P_MT, y = P_ME_E_comp), color = "blue") + ylim(0,1) + xlim(0,1)  + geom_smooth(aes(x = P_MT, y = P_MT_T_comp),  method = "glm", method.args = list(family = "binomial"), color = "red")  + geom_smooth(aes(x = P_MT, y = P_ME_E_comp),  method = "glm", method.args = list(family = "binomial"), color = "blue") + labs(x = "Proportion of MT without competition", y = "Correct identification")
a = 0.5 #то как эдулисы гнобят троссулус
b = 0.2  #то как  троссулус гнобят эдулисов
for(i in 1:nrow(pop_simulated))  pop_simulated[i, 2:5] <- simulate_pop(P_MT = pop_simulated$P_MT[i], P_T_MT = P_T_MT_glob, P_E_ME = P_E_ME_glob)
pop_simulated$P_T_MT <- with(pop_simulated, N_T_MT/(N_T_MT + N_E_MT))
pop_simulated$P_E_MT <- 1 - pop_simulated$P_T_MT
pop_simulated$P_E_ME <- with(pop_simulated, N_E_ME/(N_T_ME + N_E_ME))
pop_simulated$P_T_ME <- 1 - pop_simulated$P_E_ME
pop_simulated$P_MT_comp <- with(pop_simulated, (N_T_MT + N_E_MT - a*(N_T_ME + N_E_ME))/(N_T_MT + N_E_MT + N_T_ME + N_E_ME - a*(N_T_ME + N_E_ME)))
pop_simulated$P_ME_comp <- with(pop_simulated, (N_T_ME + N_E_ME - b*(N_T_MT + N_E_MT))/(N_T_MT + N_E_MT + N_T_ME + N_E_ME - b*(N_T_MT + N_E_MT)))
pop_simulated$P_MT_T <- with(pop_simulated, P_T_MT*P_MT/(P_T_MT*P_MT + P_T_ME*(1-P_MT)))
pop_simulated$P_MT_T_comp <- with(pop_simulated, P_T_MT*P_MT_comp/(P_T_MT*P_MT_comp + P_T_ME*(1-P_MT_comp)))
pop_simulated$P_ME_E <- with(pop_simulated, P_E_ME*(1-P_MT)/(P_E_ME*(1-P_MT) + P_E_MT*P_MT))
pop_simulated$P_ME_E_comp <- with(pop_simulated, P_E_ME*P_ME_comp/(P_E_ME*P_ME_comp + P_E_MT*P_MT_comp))
ggplot(pop_simulated, aes(x = P_MT)) + geom_line(aes(y = P_MT_T), color = "red", linetype = 2) + geom_line(aes(y = P_ME_E), color = "blue", linetype = 2) + geom_point(aes(x = P_MT, y = P_MT_T_comp), color = "red") + geom_point(aes(x = P_MT, y = P_ME_E_comp), color = "blue") + ylim(0,1) + xlim(0,1)  + geom_smooth(aes(x = P_MT, y = P_MT_T_comp),  method = "glm", method.args = list(family = "binomial"), color = "red")  + geom_smooth(aes(x = P_MT, y = P_ME_E_comp),  method = "glm", method.args = list(family = "binomial"), color = "blue") + labs(x = "Proportion of MT without competition", y = "Correct identification")
myt <- read.table("data_salinity3.csv", header = T, sep = ";")
unique(myt$pop)
myt <- read.table("data_salinity3.csv", header = T, sep = ";")
myt
myt <- read.table("data_salinity3.csv", header = T, sep = ",")
myt
unique(myt$pop)
myt$Sp [myt$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt$Sp [myt$str <= 0.5] <- "M.edulis"
myt$Sp <- factor(myt$Sp)
myt$sal_place <- factor(myt$sal_place)
str(myt$sal_place)
# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]
# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)
#Оставляем только данные, на основе, которых строится модель
myt3 <- myt2[myt2$dataset == "testing", ]
myt2 <- myt2[myt2$dataset == "training", ]
myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )
# Частота M.trossulus в популяции, вычисленная как срденее значение structure
freq_MT <- summaryBy( str ~ pop, data = myt2)
library(ggplot2)
library(dplyr)
names(myt2)
# Частота M.trossulus в популяции, вычисленная как срденее значение structure
freq_MT <- myt %>% group_by(pop) %>% summarise(freq_MT = mean(str))
freq_MT
names(myt2)
# Частота M.trossulus в популяции, вычисленная как срденее значение structure
freq_MT <- myt %>% group_by(sal_place, pop) %>% summarise(freq_MT = mean(str))
freq_MT
myt2 <- merge(myt2, freq_MT)
myt2
myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)
myt2$Location <- paste(myt2$sea,"_", myt2$sal_place, sep = "") #Перемменная для кодирования четырех выделов
myt3$Location <- paste(myt3$sea,"_", myt3$sal_place, sep = "") #Перемменная для кодирования четырех выделов
myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )
myt2 <- myt2[!(myt2$dataset %in% c("testing")), ]
myt2 %>% group_by(sal_place, pop) %>% summarise(N_MT = sum(Sp2 == 1), M_ME = sum(Sp2 == 0), freq_MT = mean(str))
myt2 %>% group_by(Location, pop) %>% summarise(N_MT = sum(Sp2 == 1), M_ME = sum(Sp2 == 0), freq_MT = mean(str))
myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1), M_ME = sum(Sp2 == 0), N_T_MT = sum(Sp2 == 1 & ind == 1))
myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1), M_ME = sum(Sp2 == 0), N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0))
myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), M_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_E_MT = sum(Sp2 == 1 & ind == 0))
myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), M_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops <- myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), M_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops$P_T_MT <- with(pops, N_T_MT/NT)
pops
pops$P_T_MT <- with(pops, N_T_MT/N_T)
pops
with(pops, N_T_MT/N_T)
pops$P_T_MT <- with(pops, N_T_MT/N_T)
pops
pops$P_T_MT <- pops$N_T_MT / pops$N_T
pops$P_T_MT <- pops$N_T_MT / pops$N_MT
pops
pops$P_T_MT <- with(pops, N_T_MT / N_MT)
pops
pops$P_E_MT <- with(pops, N_E_MT / N_MT)
pops
pops$P_E_ME <- with(pops, N_E_ME / N_ME)
pops <- myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), M_NE = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops$P_T_MT <- with(pops, N_T_MT / N_MT)
pops$P_E_MT <- with(pops, N_E_MT / N_MT)
pops$P_E_ME <- with(pops, N_E_ME / N_ME)
pops
pops <- myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), N_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops$P_T_MT <- with(pops, N_T_MT / N_MT)
pops$P_E_MT <- with(pops, N_E_MT / N_MT)
pops$P_E_ME <- with(pops, N_E_ME / N_ME)
pops$P_T_ME <- with(pops, N_T_ME / N_ME)
pops
ggplot(pops, aes(x = P_T_MT, y = P_E_ME)) + geom_point()
ggplot(pops, aes(x = P_E_ME, y = P_T_MT)) + geom_point()
ggplot(pops, aes(x = P_E_ME, y = P_T_MT)) + geom_point()
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point()
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point() + geom_abline()
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point() + geom_abline() + facet_wrap(~Location)
names(myt2)
pops <- myt2 %>% group_by(sal_place2, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), N_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops
sal_place
pops <- myt2 %>% group_by(sal_place, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), N_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops
pops <- myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), N_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops$P_T_MT <- with(pops, N_T_MT / N_MT)
pops$P_E_MT <- with(pops, N_E_MT / N_MT)
pops$P_E_ME <- with(pops, N_E_ME / N_ME)
pops$P_T_ME <- with(pops, N_T_ME / N_ME)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point() + geom_abline() + facet_wrap(~Location)
pops
pops$AUC <- with(pops, mean(c(P_T_ME, (1-P_E_ME)) )
pops$AUC <- with(pops, mean(c(P_T_ME, (1-P_E_ME))))
pops$AUC <- with(pops, mean(c(P_T_ME, (1-P_E_ME))))
pops
pops$AUC <- with(pops, (P_T_MT+P_E_ME)/2)
pops
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point() + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_T), color = "blue") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT), color = "blue") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT), color = "blue") + geom_point(aes(size = N_ME), color = "yellow") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT), color = "blue", alpha = 0.5) + geom_point(aes(size = N_ME), color = "yellow") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT), color = "blue", alpha = 0.5) + geom_point(aes(size = N_ME), color = "yellow", alpha = 0.5) + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT), shape = 21, fil = "blue", alpha = 0.5) + geom_point(aes(size = N_ME), shape = 21, fill = "yellow", alpha = 0.5) + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT), shape = 21, fill = "blue", alpha = 0.5) + geom_point(aes(size = N_ME), shape = 21, fill = "yellow", alpha = 0.5) + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT+N_ME), shape = 21, fill = "blue") + geom_point(aes(size = P_MT), shape = 21, fill = "yellow") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT+N_ME), shape = 21, fill = "blue") + geom_point(aes(size = N_MT), shape = 21, fill = "yellow") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT+N_ME), shape = 21, fill = "black") + geom_point(aes(size = N_MT), shape = 21, fill = "white") + geom_abline() + facet_wrap(~Location)
pops$P_T_MT <- with(pops, N_T_MT / N_MT)
pops$P_E_MT <- with(pops, N_E_MT / N_MT)
pops$P_T_ME <- with(pops, N_T_ME / N_ME)
pops$P_E_ME <- with(pops, N_E_ME / N_ME)
pops$AUC <- with(pops, (P_T_MT+P_E_ME)/2)
pops
colSums(pops)
pops
ggplot(pops, aes(x = (1-P_E_ME), y = T_ME)) + geom_point()
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_ME)) + geom_point()
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT+N_ME), shape = 21, fill = "black") + geom_point(aes(size = N_MT), shape = 21, fill = "white") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT+N_ME), shape = 21, fill = "white") + geom_point(aes(size = N_MT), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
pops
pops <- myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), N_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops$P_T_MT <- with(pops, N_T_MT / N_MT)
pops$P_E_MT <- with(pops, N_E_MT / N_MT)
pops$P_E_ME <- with(pops, N_E_ME / N_ME)
pops$P_T_ME <- with(pops, N_T_ME / N_ME)
pops
View(pops)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT))  + geom_point(aes(size = N_MT), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT+N_ME), shape = 21, fill = "white")  + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT/N_ME), shape = 21, fill = "white")  + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT+N_ME), shape = 21, fill = "white") + geom_point(aes(size = N_MT), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = N_MT+N_ME), shape = 21, fill = "white") + geom_point(aes(size = P_MT), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = order(N_MT+N_ME), shape = 21, fill = "white") + geom_point(aes(size = P_MT), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = order(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(size = P_MT), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = order(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(size = P_MT), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = order(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(size = order(P_MT)), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = order(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(size = order(N_MT)), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
order(pops$)
order(pops$N_MT)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = order(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(size = order(_MT)), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = order(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(size = order(_MT)), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = order(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(size = order(N_MT)), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = sqrt(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(size = sqrt(N_MT)), shape = 21, fill = "black") + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = sqrt(N_MT+N_ME)), shape = 21, fill = "white") + geom_point(aes(fill = sqrt(N_MT)), shape = 21) + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = sqrt(N_MT+N_ME), fill = sqrt(N_MT)), shape = 21)  + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = sqrt(N_MT+N_ME), fill = sqrt(N_MT)), shape = 21)  + geom_abline() + facet_wrap(~Location) + scale_fill_continuous(high = "black", low = "white" )
pops <- myt2 %>% group_by(Location, pop) %>% summarise(freq_MT = mean(str), N_MT = sum(Sp2 == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), N_ME = sum(Sp2 == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pops$P_T_MT <- with(pops, N_T_MT / N_MT)
pops$P_E_MT <- with(pops, N_E_MT / N_MT)
pops$P_E_ME <- with(pops, N_E_ME / N_ME)
pops$P_T_ME <- with(pops, N_T_ME / N_ME)
pops$AUC <- with(pops, (P_T_MT+P_E_ME)/2)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = sqrt(N_MT+N_ME), fill = sqrt(freq_MT)), shape = 21)  + geom_abline() + facet_wrap(~Location) + scale_fill_continuous(high = "black", low = "white" )
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = sqrt(N_MT+N_ME), fill = (freq_MT)), shape = 21)  + geom_abline() + facet_wrap(~Location) + scale_fill_continuous(high = "black", low = "white" )
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = sqrt(N_MT+N_ME), fill = (freq_MT)), shape = 21)  + geom_abline() + facet_wrap(~Location) + scale_fill_continuous(high = "black", low = "white" ) + geom_point(data = pops[pops$N_MT == 0, ], aes(y=-0.1))
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_MT)) + geom_point(aes(size = sqrt(N_MT+N_ME), fill = (freq_MT)), shape = 21)  + geom_abline() + facet_wrap(~Location) + scale_fill_continuous(high = "black", low = "white" ) + geom_point(data = pops[pops$N_MT == 0, ], aes(y=-0.1, x = (1-P_E_ME) ))
pops[pops$N_MT == 0, ]
pops$AUC <- with(pops, (P_T_MT+P_E_ME)/2)
ggplot(pops, aes(x = freq_MT, y = AUC)) + geom_point()  + geom_abline() + facet_wrap(~Location)
ggplot(pops, aes(x = freq_MT, y = AUC)) + geom_point()  + facet_wrap(~Location)
ggplot(pops, aes(x = (1-P_E_ME), y = P_T_ME)) + geom_text(aes(label = pop))
ggplot(pops, aes(x = freq_MT, y = AUC)) + geom_point()  + facet_wrap(~Location) + geom_text(aes(label = pop))
ggplot(pops, aes(x = freq_MT, y = AUC)) + facet_wrap(~Location) + geom_text(aes(label = pop))
ggplot(pops, aes(x = freq_MT, y = AUC)) + facet_wrap(~Location) + geom_text(aes(label = pop)) + geom_smooth(method= "lm")
ggplot(pops, aes(x = freq_MT, y = AUC)) + facet_wrap(~Location) + geom_text(aes(label = pop)) + geom_smooth(method= "lm")
ggplot(pops [pops$pop != "banka", ], aes(x = freq_MT, y = AUC)) + facet_wrap(~Location) + geom_text(aes(label = pop)) + geom_smooth(method= "lm")
vain_Z <- read.csv("Vainola_Z.csv", header = T)
vain_Z
vain_Z <- read.csv("Vainola_Z.csv", header = T)
vain_Z
vain_Z <- read.csv("Vainola_Z.csv", header = T)
vain_Z
vain_Z <- read.csv("Vainola_Z.csv", header = T)
vain_Z
vain_M <- read.csv("Vainola_morph.csv", header = T)
vain_M
library(dplyr)
vain_Z$Z <- with(vain_Z, a/l)
vain_Z
library(ggplot2)
ggplot(vain_Z, aes(x = Z)) + geom_histogram()
names(vain_Z)
ggplot(vain_Z, aes(x = Z)) + geom_histogram() + facet_wrap(~Place)
ggplot(vain_Z, aes(x = Z)) + geom_histogram() + facet_wrap(Year~Place)
vain_Z <- read.csv("Vainola_Z.csv", header = T)
vain_M <- read.csv("Vainola_morph.csv", header = T)
vain_Z$Z <- with(vain_Z, a/l)
names(vain_Z)
ggplot(vain_Z[vain_Z$Place %in% c("Lim", "Vhg"), ], aes(x = Z)) + geom_histogram() + facet_wrap(Year~Place)
ggplot(vain_Z[vain_Z$Place %in% c("Lim", "Vhg"), ], aes(x = Z)) + geom_histogram() + facet_grid(Year~Place)
ggplot(vain_Z[vain_Z$Place %in% c("Lim", "Vhg"), ], aes(x = Z)) + geom_histogram(binwidth = .1) + facet_grid(Year~Place)
ggplot(vain_Z[!(vain_Z$Place %in% c("Lim", "Vhg")), ], aes(x = Z)) + geom_histogram(binwidth = .1) + facet_grid(Year~Place)
ggplot(vain_Z[!(vain_Z$Place %in% c("Lim", "Vhg")), ], aes(x = Z)) + geom_histogram(binwidth = .1)
