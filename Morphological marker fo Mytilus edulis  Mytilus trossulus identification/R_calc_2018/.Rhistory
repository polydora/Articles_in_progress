selected_pop <- melt(selected_pop, id.vars = c("Subset", "n_pop"))$value
myt4 <- myt2[myt2$pop %in% selected_pop, ] #новый testing dataset for the White sea
myt3 <- rbind(myt3, myt4)
myt2 <- myt2[!(myt2$pop %in% selected_pop), ] #новый modelling dataset
myt3_print <- myt3 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), Ptros = round(mean(Sp == "M.trossulus"), 2 ))
kable(myt3_print)
myt2_print <- myt2 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), Ptros = round(mean(Sp == "M.trossulus"), 2 ))
kable(myt2_print)
# Функция для вычисления P_T_MT и P_T_ME в заданном датасете (БУБЛИК) ####
donat <- function(df){
P_MT <- sum(df$Sp == "M.trossulus")
P_T_MT <- sum(df$Sp == "M.trossulus" & df$morph == "T_m")/P_MT
P_ME <- sum(df$Sp == "M.edulis")
P_T_ME <- sum(df$Sp == "M.edulis" & df$morph == "T_m")/P_ME
c(P_T_MT, P_T_ME)
}
########################################3
#Функция для "ленивого" калькулятора №1 который строит зависимость Ptros от P_T
# На входе параметры бублика
calc1 <- function(P_T_MT, P_T_ME){
result <- data.frame(P_T = seq(0, 1, 0.01))
result$Ptros <- (result$P_T - P_T_ME)/(P_T_MT - P_T_ME)
result <- result[result$P_T <= P_T_MT & result$P_T >= P_T_ME, ]
result
}
# Функция для вычисления баесовских вероятностей по данным из бублика
calc2 <- function(P_T_MT, P_T_ME){
result <- data.frame(freq_MT = seq(0, 1, 0.01))
result$P_MT_T <- (P_T_MT * result$freq_MT)/(P_T_MT * result$freq_MT + P_T_ME*(1-result$freq_MT))
result$P_ME_E <- ((1 - P_T_ME) * (1 - result$freq_MT))/(1 - P_T_ME + result$freq_MT * (P_T_ME - P_T_MT))
result
}
########################################3
# Фунция для определения похожести между эмпирическим и теоретическими моделями для МОДЕЛИ 5 (Ptros vs P_T)
perms2 <- function(df = myt2[myt2$Subset == "W", ], ...) {
require(dplyr)
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
perm_pairs$Delta[i] <- max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2])))
W <- donat(df_selected)
calc1_predict_W <- calc1(W[1], W[2])
names(calc1_predict_W) <- c("Prop_T", "Ptros_predicted" )
Model_prediction <- expand.grid(Subset = unique(df_selected$Subset), Prop_T = seq(0, 1, 0.01))
Model_prediction$Predict <- predict(Model_5_final, newdata = Model_prediction, type = "response")
all_prediction <- merge(calc1_predict_W, Model_prediction, by = c("Prop_T"))
perm_pairs$Goodness[i] <- 1/(mean((all_prediction$Predict - all_prediction$Ptros_predicted)^2))
}
perm_pairs
}
# Фунция для определения похожести между эмпирическими и теоретическими моделями для МОДЕЛИ 4 (Congr vs Ptros; Morph)
perms4 <- function(df = myt2[myt2$Subset == "W", ], ...) {
require(dplyr)
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
# perm_pairs$Delta[i] <- abs(means$freq_MT[1] - means$freq_MT[2])
perm_pairs$Delta[i] <- max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2])))
W <- donat(df_selected)
calc2_predict_W <- calc2(W[1], W[2])
names(calc2_predict_W) <- c("freq_MT", "T_m",  "E_m")
calc2_predict_W <- melt(calc2_predict_W, id.vars = "freq_MT" )
names(calc2_predict_W) <- c("freq_MT", "morph", "Bayes_predict")
Model_prediction <- expand.grid(Subset = unique(df_selected$Subset),  morph = levels(df_selected$morph), freq_MT = seq(0, 1, 0.01))
Model_prediction$Predict <- predict(Model_4_final, newdata = Model_prediction, type = "response",  re.form = NA )
all_prediction <- merge(calc2_predict_W, Model_prediction, by = c("freq_MT", "morph"))
perm_pairs$Goodness[i] <- 1/mean((all_prediction$Bayes_predict - all_prediction$Predict)^2, na.rm = T)
perm_pairs$pop[i] <- unique(as.character(df_selected$pop))
}
perm_pairs
}
## Функция для поиска ниболее различающихся выборок
max_dif <- function(df = myt2, Subset = "W", ...) {
require(dplyr)
df = df[df$Subset %in% Subset, ]
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
perm_pairs$Delta[i] <- max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2])))
}
max_dif <- perm_pairs[which.max(perm_pairs$Delta), ]
c(max_dif$First, max_dif$Second)
}
max_mix <- function(df = myt2, Subset = "W", ...) {
require(dplyr)
df = df[df$Subset %in% Subset, ]
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
perm_pairs$Delta[i] <- max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2])))
}
max_mix <- perm_pairs[which.min(abs(perm_pairs$Delta - 0.25)), ]
c(max_mix$First, max_mix$Second)
}
### Функция для описания структуры калибровочных выборок
calib_str <- function(df = myt2, pop1, pop2){
df =df[df$pop %in% c(pop1, pop2), ]
df$Subset <- factor(df$Subset)
str_calib <- df %>% group_by(pop, Subset) %>% summarize(N_E = sum(Sp == "M.edulis"), N_T = sum(Sp ==  "M.trossulus"), P_T_ME = mean(Sp == "M.edulis" & morph == "T_m"), P_T_MT = mean(Sp == "M.trossulus" & morph == "T_m"), Ptros = mean(freq_MT) )
str_calib
}
########################################
# Функция для обратной трансформации логитов
logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация
# Функция для оценки сверхдисперсии в моделях GLM
overdisp_fun <- function(model) {
rdf <- df.residual(model)  # Число степеней свободы N - p
if (inherits(model, 'negbin')) rdf <- rdf - 1 ## учитываем k в NegBin GLMM
rp <- residuals(model,type='pearson') # Пирсоновские остатки
Pearson.chisq <- sum(rp^2) # Сумма квадратов остатков, подчиняется Хи-квадрат распределению
prat <- Pearson.chisq/rdf  # Отношение суммы квадратов остатков к числу степеней свободы
pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE) # Уровень значимости
c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)        # Вывод результатов
}
##### Theme for ggplot ######
theme_set(theme_bw() + theme(axis.title.x = element_text(size = 10), axis.title.y = element_text(size = 10), axis.text= element_text(size = 10), legend.position = "none" , title = element_text(size = 10)))
ptop_T_MT <- myt2 %>% group_by(Subset, pop) %>% summarize(Prop_T = mean(Prop_T), MT = sum(Sp2), N = n())
Model_5_full <- glm(cbind(MT, (N-MT)) ~  Prop_T * Subset, data = ptop_T_MT, family = binomial(link = "logit"))
overdisp_fun(Model_5_full)
Model_5_final <- Model_5_full
Model_5_final_summary <- tidy(Model_5_final)
Model_5_R2 <- r.squaredGLMM(Model_5_final)[1,1]
Model_5_R2
Model_5_final_summary
Model_5_R2 <- r.squaredGLMM(Model_5_final)[1,1]
Model_5_R2
Model_5_final_summary
ptop_T_MT <- myt2_reduced %>% group_by(Subset, pop) %>% summarize(Prop_T = mean(Prop_T), MT = sum(Sp2), N = n())
Model_5_full <- glm(cbind(MT, (N-MT)) ~  Prop_T * Subset, data = ptop_T_MT, family = binomial(link = "logit"))
overdisp_fun(Model_5_full)
drop1(Model_5_full, test = "Chi")
Model_5_final <- Model_5_full
new_data5 <- myt2_reduced %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(Prop_T) ) %>% group_by(Subset) %>%  do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 10)))
predicted5 <- predict(Model_5_final, newdata = new_data5,  type="response", se.fit = T)
new_data5$fit <- predicted5$fit
new_data5$SE <- predicted5$se.fit
Pl_mod5 <- ggplot(new_data5, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) + facet_wrap(~Subset) + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = myt2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
init_data_Model_5 <- myt2 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(morph == "T_m"),  freq_MT = mean(Sp == "M.trossulus"), N = n())
Pl_mod5_with_initial_data <- Pl_mod5 + geom_point(data = init_data_Model_5, aes( y = freq_MT), shape = 21 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n")
Pl_mod5_with_initial_data
Pl_mod5 <- ggplot(new_data5, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) + facet_wrap(~Subset) + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = myt2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
init_data_Model_5 <- myt2 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(morph == "T_m"),  freq_MT = mean(Sp == "M.trossulus"), N = n())
Pl_mod5_with_initial_data <- Pl_mod5 + geom_point(data = init_data_Model_5, aes( y = freq_MT), shape = 21 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n")
Pl_mod5_with_initial_data
myt <- read.table("data_salinity3.csv", header = T, sep = ",")
# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]
# Подразделяем данные на сабсеты
myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "fresh"] <- "BL"
myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "normal"] <- "BH"
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "normal"] <- "W"
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "fresh"] <- "W"
myt2$Subset[myt2$sea == "Baltic"] <- "BALT"
myt2$Subset[myt2$sea == "GOM"] <- "GOM"
myt2$Subset[myt2$sea == "Norway"] <- "NORW"
myt2$Subset[myt2$sea == "Scotland"] <- "SCOT"
myt2$Subset <- factor(myt2$Subset, levels = c("W", "BL", "BH", "NORW", "BALT", "SCOT", "GOM" ))
levels(myt2$Subset)
# Вводим обозначения
myt2$Sp [myt2$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt2$Sp [myt2$str <= 0.5] <- "M.edulis"
myt2$Sp <- factor(myt2$Sp)
# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)
# Бинарное обозначение видов
myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)
#Correct identification
myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )
# Частота M.trossulus в популяции
freq_MT <- myt2 %>% group_by(pop) %>% summarise(freq_MT = mean(Sp2))
myt2 <- merge(myt2, freq_MT)
# Частота T-морфотипа в популяции
Prop_T <- myt2 %>% group_by(pop) %>% summarise(Prop_T = mean(ind))
myt2 <- merge(myt2, Prop_T)
# testing data set
myt3 <- myt2[myt2$dataset == "testing" | myt2$pop %in% c("kovda", "rya", "chupa", "umba_pil"),  ]
#modelling data set
myt2 <- myt2[! myt2$pop %in% unique(myt3$pop), ]
levels(myt2$Subset)
# Модели для сравнения geographical datasets
myt2_reduced <- myt2[myt2$Subset %in% c("W", "BL", "BH", "GOM", "BALT"), ]
myt2_reduced$Subset <- factor(myt2_reduced$Subset)
levels(myt2_reduced$Subset)
ptop_T_MT <- myt2_reduced %>% group_by(Subset, pop) %>% summarize(Prop_T = mean(Prop_T), MT = sum(Sp2), N = n())
Model_5_full <- glm(cbind(MT, (N-MT)) ~  Prop_T * Subset, data = ptop_T_MT, family = binomial(link = "logit"))
Model_5_final <- Model_5_full
new_data5 <- myt2_reduced %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(Prop_T) ) %>% group_by(Subset) %>%  do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 10)))
predicted5 <- predict(Model_5_final, newdata = new_data5,  type="response", se.fit = T)
new_data5$fit <- predicted5$fit
new_data5$SE <- predicted5$se.fit
Pl_mod5 <- ggplot(new_data5, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) + facet_wrap(~Subset) + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = myt2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
init_data_Model_5 <- myt2 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(morph == "T_m"),  freq_MT = mean(Sp == "M.trossulus"), N = n())
Pl_mod5_with_initial_data <- Pl_mod5 + geom_point(data = init_data_Model_5, aes( y = freq_MT), shape = 21 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n")
Model_5_final_diag <- fortify(Model_5_final)
ggplot(Model_5_final_diag, aes(x = .fitted, y = .stdresid)) + geom_point() + geom_smooth()
Pl_mod5_with_initial_data
library("optimx")
Model_4_full_geogr <- glmer(congr ~ morph * freq_MT * Subset + (1 | pop), data = myt2_reduced, family = binomial(link = "logit"), control=glmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))
overdisp_fun(Model_4_full_geogr)
summary(Model_4_full_geogr)
r.squaredGLMM(Model_4_final)
drop1(Model_4_full_geogr)
Model_4_full_geogr2 <- update(Model_4_full_geogr, . ~ . - morph:freq_MT:Subset)
drop1(Model_4_full_geogr2)
Model_4_final <- Model_4_full_geogr2
new_data4 <- myt2_reduced %>% group_by(Subset, morph) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))
# Предсказанные значеня в шкале вероятностей
new_data4$fit <- predict(Model_4_final, newdata = new_data4, type = "response", re.form = NA)
# Предсказанные значеня в шкале логитов
new_data4$fit_eta <- predict(Model_4_final, newdata = new_data4, re.form = NA)
# Вычисление доверительного инеравала
formula(Model_4_final)
X <- model.matrix(  ~ morph + freq_MT + Subset + morph:freq_MT + morph:Subset + freq_MT:Subset, data = new_data4) #Модельная матрица для визуализации
# Ошибки в шкале логитов
new_data4$se_eta <- sqrt(diag(X %*% vcov(Model_4_final) %*% t(X)))
new_data4$lwr <- logit_back(new_data4$fit_eta - 1.96 * new_data4$se_eta)
new_data4$upr <- logit_back(new_data4$fit_eta + 1.96 * new_data4$se_eta)
Pl_mod4 <- ggplot(new_data4, aes(x = freq_MT)) +
geom_ribbon(aes(ymin = lwr, ymax = upr, group = morph), alpha = 0.1)  +
geom_line(aes(y = fit, color = morph), size=1, linetype = 2) +
geom_rug(data = myt2_reduced, inherit.aes = FALSE,  aes(x = freq_MT), size = 0.1) +
scale_color_manual(values = c("blue", "red")) +
scale_fill_manual(values = c("blue", "red"))  +
xlim(0,1)  +
facet_wrap( ~ Subset)
pr_value_M <- myt2 %>% group_by(Subset, pop) %>% summarise(freq_MT = mean(freq_MT), N_T = sum(ind == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), N_E = sum(ind == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pr_value_M$PMT_T <- with(pr_value_M, N_T_MT / N_T)
pr_value_M$PMT_E <- with(pr_value_M, N_E_MT / N_T)
pr_value_M$PME_E <- with(pr_value_M, N_E_ME / N_E)
pr_value_M$PME_T <- with(pr_value_M, N_T_ME / N_E)
Pl_mod4_with_initial_data <- Pl_mod4 + geom_segment(data = pr_value_M, aes(x = freq_MT, y = PME_E, xend = freq_MT, yend = PMT_T), color="darkgrey") +
geom_hline(data = pr_value_M, aes(yintercept=0.5), color="black") +
geom_point(data = pr_value_M, aes(y = PME_E), fill = "white", shape = 21) +
geom_point(data = pr_value_M, aes(y = PMT_T), fill = "black", shape = 21) +
labs(y =  "Proportions of correct species \n identification by morphotypes", x = "Proportion of M. trossulus", fill = "")+
ylim(0,1) +
xlim(0,1)
Pl_mod4_with_initial_data
Pl_mod5_with_initial_data
library(mgcv)
Mod_GAM_str_Ptros <- gam(cong ~ s(str, freq_MT, by = Subset), data = myt2_reduced)
Mod_GAM_str_Ptros <- gam(congr ~ s(str, freq_MT, by = Subset), data = myt2_reduced)
plot(Mod_GAM_str_Ptros)
Mod_GAM_str_Ptros <- gam(congr ~ s(freq_MT, str, by = Subset), data = myt2_reduced)
plot(Mod_GAM_str_Ptros, pages = 1)
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.1), str = seq(0, 1, 0.1))
new_gam_data
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data)
Mod_GAM_str_Ptros <- gam(congr ~ s(freq_MT, str, by = Subset), data = myt2_reduced, family = "binomial")
plot(Mod_GAM_str_Ptros, pages = 1)
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.1), str = seq(0, 1, 0.1))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data)
ggplot(new_gam_data, aes(x = freq_MT, y = str, color = predict)) + geom_tile()
ggplot(new_gam_data, aes(x = freq_MT, y = str, color = predict)) + geom_tile() + facet_wrap(~Subset)
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset)
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset)
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.01), str = seq(0, 1, 0.01))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset)
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue")
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str))
myt2_reduced
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str))
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, fill = congr))
Mod_GAM_str_Ptros <- gam(congr ~ s(freq_MT, str, by = Subset, k = 10), data = myt2_reduced, family = "binomial")
plot(Mod_GAM_str_Ptros, pages = 1)
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.01), str = seq(0, 1, 0.01))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, fill = congr))
ggplot(new_gam_data, aes(x = freq_MT, y = str, fill = predict)) + geom_tile() + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr))
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr))
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + scale_color_manual(values = c("yellow", "red"))
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + scale_color_manual(values = c("yellow", "red"))
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr))
Mod_GAM_str_Ptros <- gam(congr ~ s(freq_MT, str, by = Subset, k = 20), data = myt2_reduced, family = "binomial")
plot(Mod_GAM_str_Ptros, pages = 1)
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.01), str = seq(0, 1, 0.01))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr))
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced, aes(x = freq_MT, y = str))
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced, aes(x = freq_MT, y = str), color = "yellow")
Mod_GAM_str_Ptros <- gam(congr ~ s(freq_MT, str, by = Subset), data = myt2_reduced, family = "binomial")
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.01), str = seq(0, 1, 0.01))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + facet_wrap(~Subset) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced, aes(x = freq_MT, y = str), color = "yellow")
Mod_GAM_str_Ptros <- gam(congr ~ s(freq_MT, str), data = myt2_reduced, family = "binomial")
new_gam_data <- expand.grid(freq_MT = seq(0, 1, 0.01), str = seq(0, 1, 0.01))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced, aes(x = freq_MT, y = str), color = "yellow")
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced[myt2_reduced$congr == 1, ], aes(x = freq_MT, y = str), color = "yellow")
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced[myt2_reduced$congr == 1, ], aes(x = freq_MT, y = str), color = "yellow") + facet_wrap(~Subset)
Mod_GAM_str_Ptros <- gam(congr ~ s(freq_MT, str, by = Subset), data = myt2_reduced, family = "binomial")
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.01), str = seq(0, 1, 0.01))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced[myt2_reduced$congr == 1, ], aes(x = freq_MT, y = str), color = "yellow") + facet_wrap(~Subset)
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.05), str = seq(0, 1, 0.05))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced[myt2_reduced$congr == 1, ], aes(x = freq_MT, y = str), color = "yellow") + facet_wrap(~Subset)
Mod_GAM_str_Ptros <- gam(ind ~ s(freq_MT, str, by = Subset), data = myt2_reduced, family = "binomial")
myt2_reduced
Mod_GAM_str_Ptros <- gam(ind ~ s(freq_MT, str, by = Subset), data = myt2_reduced, family = "binomial")
table(myt2_reduced$ind)
# В этом скрипте приведена обработка данных, включающих все георафические данные
library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)
library(pROC)
library(betareg)
library(lmtest)
library(broom)
library(MuMIn)
library(gridExtra)
library(mgcv)
#### Data reading and initial preparation #####
myt <- read.table("data_salinity3.csv", header = T, sep = ",")
# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]
# Подразделяем данные на сабсеты
myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "fresh"] <- "BL"
myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "normal"] <- "BH"
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "normal"] <- "W"
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "fresh"] <- "W"
myt2$Subset[myt2$sea == "Baltic"] <- "BALT"
myt2$Subset[myt2$sea == "GOM"] <- "GOM"
myt2$Subset[myt2$sea == "Norway"] <- "NORW"
myt2$Subset[myt2$sea == "Scotland"] <- "SCOT"
myt2$Subset <- factor(myt2$Subset, levels = c("W", "BL", "BH", "NORW", "BALT", "SCOT", "GOM" ))
levels(myt2$Subset)
# Вводим обозначения
myt2$Sp [myt2$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt2$Sp [myt2$str <= 0.5] <- "M.edulis"
myt2$Sp <- factor(myt2$Sp)
# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)
# Бинарное обозначение видов
myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)
#Correct identification
myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )
# Частота M.trossulus в популяции
freq_MT <- myt2 %>% group_by(pop) %>% summarise(freq_MT = mean(Sp2))
myt2 <- merge(myt2, freq_MT)
# Частота T-морфотипа в популяции
Prop_T <- myt2 %>% group_by(pop) %>% summarise(Prop_T = mean(ind))
myt2 <- merge(myt2, Prop_T)
# Разделяем на тестовые и моделинговые датасеты
#
# # Извлекаем из беломорского материала тестовую выборку
# #В формальную тестовую выборку  попадают точки наиболее близкие к 20%, 40%, 60% и 80% freq_MT
#
# selected_pop <- myt2[myt2$Subset == "W", ] %>% group_by(Subset, pop) %>% summarise(freq_MT = mean(freq_MT)) %>% group_by(Subset) %>% arrange(freq_MT, .by_group = TRUE) %>% mutate(dif_20 = (freq_MT - 0.2)^2, dif_40 = (freq_MT - 0.4)^2, dif_60 = (freq_MT - 0.6)^2, dif_80 = (freq_MT - 0.8)^2)  %>% group_by(Subset)  %>% summarize (n_pop =n(), q_20_pop = nth(pop, which.min(dif_20)), q_40_pop = nth(pop, which.min(dif_40)), q_60_pop = nth(pop, which.min(dif_60)), q_80_pop = nth(pop, which.min(dif_80)))
#
# selected_pop <- melt(selected_pop, id.vars = c("Subset", "n_pop"))$value
#
# testing data set
myt3 <- myt2[myt2$dataset == "testing" | myt2$pop %in% c("kovda", "rya", "chupa", "umba_pil"),  ]
#modelling data set
myt2 <- myt2[! myt2$pop %in% unique(myt3$pop), ]
levels(myt2$Subset)
# Модели для сравнения geographical datasets
myt2_reduced <- myt2[myt2$Subset %in% c("W", "BL", "BH", "GOM", "BALT"), ]
myt2_reduced$Subset <- factor(myt2_reduced$Subset)
levels(myt2_reduced$Subset)
Mod_GAM_str_Ptros <- gam(ind ~ s(freq_MT, str, by = Subset), data = myt2_reduced, family = "binomial")
table(myt2_reduced$ind)
new_gam_data <- expand.grid(Subset = unique(myt2_reduced$Subset), freq_MT = seq(0, 1, 0.05), str = seq(0, 1, 0.05))
new_gam_data$predict <- predict(Mod_GAM_str_Ptros, newdata = new_gam_data, type = "response")
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + geom_density2d(data = myt2_reduced[myt2_reduced$congr == 1, ], aes(x = freq_MT, y = str), color = "yellow") + facet_wrap(~Subset)
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = congr)) + facet_wrap(~Subset)
ggplot(new_gam_data, aes(x = freq_MT, y = str)) + geom_tile(aes(fill = predict)) + scale_fill_gradient(low = "white", high = "blue") + geom_point(data = myt2_reduced, aes(x = freq_MT, y = str, color = ind)) + facet_wrap(~Subset)
Pl_mod4_with_initial_data
Pl_mod4
# В этом скрипте приведена обработка данных, включающих все георафические данные
library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)
library(pROC)
library(betareg)
library(lmtest)
library(broom)
library(MuMIn)
library(gridExtra)
library(mgcv)
Pl_mod4_with_initial_data
Pl_mod4_with_initial_data <- Pl_mod4 + geom_segment(data = pr_value_M, aes(x = freq_MT, y = PME_E, xend = freq_MT, yend = PMT_T), color="darkgrey") +
geom_hline(data = pr_value_M, aes(yintercept=0.5), color="black") +
geom_point(data = pr_value_M, aes(y = PME_E), fill = "white", shape = 21) +
geom_point(data = pr_value_M, aes(y = PMT_T), fill = "black", shape = 21) +
labs(y =  "Proportions of correct species \n identification by morphotypes", x = "Proportion of M. trossulus", fill = "")+
ylim(0,1) +
xlim(0,1) +
theme_bw()
Pl_mod4_with_initial_data
Pl_mod4_with_initial_data
Pl_mod5_with_initial_data
Pl_mod5_with_initial_data <- Pl_mod5 + geom_point(data = init_data_Model_5, aes( y = freq_MT), shape = 21 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n") + theme_bw()
Pl_mod5_with_initial_data
Model_5_final_diag
qplot(x =ptop_T_MT$pop, y = Model_5_final_diag$.cooksd)
ggplot(Model_5_final_diag, aes(y = .fitted, x = .stdresid)) + geom_point() + geom_smooth()
qplot(y =ptop_T_MT$pop, x = Model_5_final_diag$.cooksd)
Model_5_final_diag$pop <- ptop_T_MT$pop
Model_5_final_diag$pop[order(Model_5_final_diag$.cooksd)]
Model_5_final_diag[order(Model_5_final_diag$.cooksd, decreasing = T), c("pop", ".cooksd")]
ptop_T_MT <- ptop_T_MT[! ptop_T_MT$pop %in% c("Limh88", "CBCP"), ]
Model_5_full <- glm(cbind(MT, (N-MT)) ~  Prop_T * Subset, data = ptop_T_MT, family = binomial(link = "logit"))
Model_5_final <- Model_5_full
new_data5 <- myt2_reduced %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(Prop_T) ) %>% group_by(Subset) %>%  do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 10)))
predicted5 <- predict(Model_5_final, newdata = new_data5,  type="response", se.fit = T)
new_data5$fit <- predicted5$fit
new_data5$SE <- predicted5$se.fit
Pl_mod5 <- ggplot(new_data5, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) + facet_wrap(~Subset) + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = myt2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
init_data_Model_5 <- myt2 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(morph == "T_m"),  freq_MT = mean(Sp == "M.trossulus"), N = n())
Pl_mod5_with_initial_data <- Pl_mod5 + geom_point(data = init_data_Model_5, aes( y = freq_MT), shape = 21 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n") + theme_bw()
Model_5_final_diag <- fortify(Model_5_final)
Model_5_final_diag$pop <- ptop_T_MT$pop
Model_5_final_diag[order(Model_5_final_diag$.cooksd, decreasing = T), c("pop", ".cooksd")]
qplot(y =ptop_T_MT$pop, x = Model_5_final_diag$.cooksd)
ggplot(Model_5_final_diag, aes(x = .fitted, y = .stdresid)) + geom_point() + geom_smooth()
Pl_mod5_with_initial_data
ptop_T_MT <- myt2_reduced %>% group_by(Subset, pop) %>% summarize(Prop_T = mean(Prop_T), MT = sum(Sp2), N = n())
# ptop_T_MT <- ptop_T_MT[! ptop_T_MT$pop %in% c("Limh88", "CBCP"), ]
Model_5_full <- glm(cbind(MT, (N-MT)) ~  Prop_T * Subset, data = ptop_T_MT, family = binomial(link = "logit"))
#
# Model_5_full <- glm(Sp2 ~  Prop_T * Subset, data = myt2_reduced, family = binomial(link = "logit"))
#  overdisp_fun(Model_5_full)
# drop1(Model_5_full, test = "Chi")
# Model_5_1 <- update(Model_5_full, . ~ . - Prop_T:Subset)
# drop1(Model_5_1, test = "Chi")
Model_5_final <- Model_5_full
new_data5 <- myt2_reduced %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(Prop_T) ) %>% group_by(Subset) %>%  do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 10)))
predicted5 <- predict(Model_5_final, newdata = new_data5,  type="response", se.fit = T)
new_data5$fit <- predicted5$fit
new_data5$SE <- predicted5$se.fit
Pl_mod5 <- ggplot(new_data5, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) + facet_wrap(~Subset) + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = myt2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
init_data_Model_5 <- myt2 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(morph == "T_m"),  freq_MT = mean(Sp == "M.trossulus"), N = n())
Pl_mod5_with_initial_data <- Pl_mod5 + geom_point(data = init_data_Model_5, aes( y = freq_MT), shape = 21 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n") + theme_bw()
Model_5_final_diag <- fortify(Model_5_final)
Model_5_final_diag$pop <- ptop_T_MT$pop
Model_5_final_diag[order(Model_5_final_diag$.cooksd, decreasing = T), c("pop", ".cooksd")]
Pl_mod5_with_initial_data
ptop_T_MT <- myt2_reduced %>% group_by(Subset, pop) %>% summarize(Prop_T = mean(Prop_T), MT = sum(Sp2), N = n())
ptop_T_MT <- ptop_T_MT[! ptop_T_MT$pop %in% c("Limh88", "CBCP"), ]
Model_5_full <- glm(cbind(MT, (N-MT)) ~  Prop_T * Subset, data = ptop_T_MT, family = binomial(link = "logit"))
Model_5_final <- Model_5_full
new_data5 <- myt2_reduced %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(Prop_T) ) %>% group_by(Subset) %>%  do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 10)))
predicted5 <- predict(Model_5_final, newdata = new_data5,  type="response", se.fit = T)
new_data5$fit <- predicted5$fit
new_data5$SE <- predicted5$se.fit
Pl_mod5 <- ggplot(new_data5, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) + facet_wrap(~Subset) + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = myt2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
init_data_Model_5 <- myt2 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(morph == "T_m"),  freq_MT = mean(Sp == "M.trossulus"), N = n())
init_data_Model_5 <- init_data_Model_5[init_data_Model_5$pop %in% c("Limh88", "CBCP"),  ]
Pl_mod5_with_initial_data <- Pl_mod5 + geom_point(data = init_data_Model_5, aes( y = freq_MT), shape = 21 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n") + theme_bw()
Pl_mod5_with_initial_data
ptop_T_MT <- myt2_reduced %>% group_by(Subset, pop) %>% summarize(Prop_T = mean(Prop_T), MT = sum(Sp2), N = n())
# ptop_T_MT <- ptop_T_MT[! ptop_T_MT$pop %in% c("Limh88", "CBCP"), ]
Model_5_full <- glm(cbind(MT, (N-MT)) ~  Prop_T * Subset, data = ptop_T_MT, family = binomial(link = "logit"))
#
# Model_5_full <- glm(Sp2 ~  Prop_T * Subset, data = myt2_reduced, family = binomial(link = "logit"))
#  overdisp_fun(Model_5_full)
# drop1(Model_5_full, test = "Chi")
# Model_5_1 <- update(Model_5_full, . ~ . - Prop_T:Subset)
# drop1(Model_5_1, test = "Chi")
Model_5_final <- Model_5_full
new_data5 <- myt2_reduced %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(Prop_T) ) %>% group_by(Subset) %>%  do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 10)))
predicted5 <- predict(Model_5_final, newdata = new_data5,  type="response", se.fit = T)
new_data5$fit <- predicted5$fit
new_data5$SE <- predicted5$se.fit
Pl_mod5 <- ggplot(new_data5, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) + facet_wrap(~Subset) + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = myt2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
init_data_Model_5 <- myt2 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(morph == "T_m"),  freq_MT = mean(Sp == "M.trossulus"), N = n())
# init_data_Model_5 <- init_data_Model_5[init_data_Model_5$pop %in% c("Limh88", "CBCP"),  ]
Pl_mod5_with_initial_data <- Pl_mod5 + geom_point(data = init_data_Model_5, aes( y = freq_MT), shape = 21 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n") + theme_bw()
Pl_mod5_with_initial_data
Pl_mod4_with_initial_data
