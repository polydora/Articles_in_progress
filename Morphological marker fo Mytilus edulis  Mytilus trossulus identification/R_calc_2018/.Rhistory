overdisp_fun <- function(model) {
rdf <- df.residual(model)  # Число степеней свободы N - p
if (inherits(model, 'negbin')) rdf <- rdf - 1 ## учитываем k в NegBin GLMM
rp <- residuals(model,type='pearson') # Пирсоновские остатки
Pearson.chisq <- sum(rp^2) # Сумма квадратов остатков, подчиняется Хи-квадрат распределению
prat <- Pearson.chisq/rdf  # Отношение суммы квадратов остатков к числу степеней свободы
pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE) # Уровень значимости
c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)        # Вывод результатов
}
Pl_teor_empir_6 <- ggplot(perms4(df = mixed_data, regr_model = Model_6_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
perms2 <- function(df = myt2[myt2$Subset == "W", ], regr_model = Model_5_final, ...) {
require(dplyr)
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
perm_pairs$Delta[i] <- max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2])))
W <- donat(df_selected)
calc1_predict_W <- calc1(W[1], W[2])
names(calc1_predict_W) <- c("Prop_T", "Ptros_predicted" )
Model_prediction <- expand.grid(Subset = unique(df_selected$Subset), Prop_T = seq(0, 1, 0.01))
Model_prediction$Predict <- predict(regr_model, newdata = Model_prediction, type = "response")
all_prediction <- merge(calc1_predict_W, Model_prediction, by = c("Prop_T"))
perm_pairs$Goodness[i] <- 1/(mean((all_prediction$Predict - all_prediction$Ptros_predicted)^2))
}
perm_pairs
}
Pl_teor_empir_6 <- ggplot(perms4(df = mixed_data, regr_model = Model_6_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
Pl_teor_empir_6 <- ggplot(perms4(df = mixed_data, regr_model = Model_6_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
Pl_teor_empir_7 <- ggplot(perms2(df = mixed_data, regr_model = Model_7_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
# Фунция для определения похожести между эмпирическими и теоретическими моделями для МОДЕЛИ 4 (Congr vs Ptros; Morph)
perms4 <- function(df = myt2[myt2$Subset == "W", regr_model =  Model_4_final, ...) {
# Фунция для определения похожести между эмпирическими и теоретическими моделями для МОДЕЛИ 4 (Congr vs Ptros; Morph)
perms4 <- function(df = myt2[myt2$Subset == "W"], regr_model =  Model_4_final, ...) {
require(dplyr)
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
# perm_pairs$Delta[i] <- abs(means$freq_MT[1] - means$freq_MT[2])
perm_pairs$Delta[i] <- max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2])))
W <- donat(df_selected)
calc2_predict_W <- calc2(W[1], W[2])
names(calc2_predict_W) <- c("freq_MT", "T_m",  "E_m")
calc2_predict_W <- melt(calc2_predict_W, id.vars = "freq_MT" )
names(calc2_predict_W) <- c("freq_MT", "morph", "Bayes_predict")
Model_prediction <- expand.grid(Subset = unique(df_selected$Subset),  morph = levels(df_selected$morph), freq_MT = seq(0, 1, 0.01))
Model_prediction$Predict <- predict(regr_model, newdata = Model_prediction, type = "response",  re.form = NA )
all_prediction <- merge(calc2_predict_W, Model_prediction, by = c("freq_MT", "morph"))
perm_pairs$Goodness[i] <- 1/mean((all_prediction$Bayes_predict - all_prediction$Predict)^2, na.rm = T)
perm_pairs$pop[i] <- unique(as.character(df_selected$pop))
}
perm_pairs
}
Pl_teor_empir_6 <- ggplot(perms4(df = mixed_data, regr_model = Model_6_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
Pl_teor_empir_6 <- Pl_teor_empir_6 + ggtitle("Regression Model 6 \nvs Theoretical model Eq 1, Eq 2")
Pl_teor_empir_6
mixed_data
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = mixed_data, Subset = c("W", "BL"))
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = mixed_data, Subset = c("WBL"))
# Популяции наиболее смешанные
pops_max_mix <- max_mix(df = mixed_data, Subset = c("WBL"))
# Бублики для наиболее различных по стуртуре популяций
donat_max_dif <- donat(df = mixed_data[mixed_data$pop %in% pops_max_diff, ])
# Бублики для наиболее смешанных популяций
donat_max_mix <- donat(df = mixed_data[mixed_data$pop %in% pops_max_mix, ])
# Описание структуры калибровочных популяций
calc1_calib_pop_str <- calib_str(df = mixed_data, pop1 = pops_max_diff [1], pop2 = pops_max_diff [2])
calc2_calib_pop_str <- calib_str(df = mixed_data, pop1 = pops_max_mix [1], pop2 = pops_max_mix [2])
calc1_W <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
calc1_B <- calc1(donat_max_mix[1], donat_max_mix[2]) #Предсказания калькулятора 1 на основе наиболее смешанных популяций
myt5 <- myt3[myt3$Subset %in% c("W", "BL"), ]
myt5
myt5
myt5 <- myt3[myt3$Subset %in% c("WBL"), ]
myt5
Pl_calc1_mod7 <- Pl_mod7 + geom_line(data = calc1_W, aes(x = P_T, y = Ptros), color = "blue", size = 1) + geom_line(data = calc1_B, aes(x = P_T, y = Ptros), color = "gray")  + geom_point(data = myt5, aes(x = Prop_T, y = freq_MT), size = 4, color = "red")  + labs(x = "Proportion of T-morphotype", y = "Proportion of M.trossulus \n")
Pl_calc1_mod7
Pl_mod7
mixed_data <- myt2[myt2$Subset %in% c("WBL"), ]
Model_WBL_full <- glmer(congr ~ morph * freq_MT + (1 | pop), data = mixed_data, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Model_6_final <- Model_6_full
=======
#
# drop1(Model_6_full_geogr)
# Model_6_full_geogr2 <- update(Model_6_full_geogr, . ~ . - morph:freq_MT:Subset)
# drop1(Model_6_full_geogr2)
Model_6_final <- Model_6_full_geogr
new_data6 <- myt2_reduced %>% group_by(Subset, morph) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))
# Предсказанные значеня в шкале вероятностей
new_data6$fit <- predict(Model_6_final, newdata = new_data6, type = "response", re.form = NA)
# Предсказанные значеня в шкале логитов
new_data6$fit_eta <- predict(Model_6_final, newdata = new_data6, re.form = NA)
# Вычисление доверительного инеравала
# formula(Model_6_final)
X <- model.matrix(  ~ morph * freq_MT * Subset, data = new_data6) #Модельная матрица для визуализации
# Ошибки в шкале логитов
new_data6$se_eta <- sqrt(diag(X %*% vcov(Model_6_final) %*% t(X)))
new_data6$lwr <- logit_back(new_data6$fit_eta - 1.96 * new_data6$se_eta)
new_data6$upr <- logit_back(new_data6$fit_eta + 1.96 * new_data6$se_eta)
Pl_mod6 <- ggplot(new_data6, aes(x = freq_MT)) +
geom_ribbon(aes(ymin = lwr, ymax = upr, group = morph), alpha = 0.1)  +
geom_line(aes(y = fit, color = morph), size=1, linetype = 2) +
geom_rug(data = myt2_reduced, inherit.aes = FALSE,  aes(x = freq_MT), size = 0.1) +
scale_color_manual(values = c("blue", "red")) +
scale_fill_manual(values = c("blue", "red"))  +
xlim(0,1)  +
facet_wrap( ~ Subset) +
guides(color = "none")
pr_value_M <- myt2 %>% group_by(Subset, pop) %>% summarise(freq_MT = mean(freq_MT), N_T = sum(ind == 1),  N_T_MT = sum(Sp2 == 1 & ind == 1), N_E_MT = sum(Sp2 == 1 & ind == 0), N_E = sum(ind == 0), N_E_ME = sum(Sp2 == 0 & ind == 0), N_T_ME = sum(Sp2 == 0 & ind == 1))
pr_value_M$PMT_T <- with(pr_value_M, N_T_MT / N_T)
pr_value_M$PMT_E <- with(pr_value_M, N_E_MT / N_T)
pr_value_M$PME_E <- with(pr_value_M, N_E_ME / N_E)
pr_value_M$PME_T <- with(pr_value_M, N_T_ME / N_E)
Pl_mod6_with_initial_data <- Pl_mod6 + geom_segment(data = pr_value_M, aes(x = freq_MT, y = PME_E, xend = freq_MT, yend = PMT_T), color="darkgrey") +
geom_hline(data = pr_value_M, aes(yintercept=0.5), color="black") +
geom_point(data = pr_value_M, aes(y = PME_E), fill = "white", shape = 21) +
geom_point(data = pr_value_M, aes(y = PMT_T), fill = "black", shape = 21) +
labs(y =  "Proportions of correct species \n identification by morphotypes", x = "Proportion of M. trossulus", fill = "")+
ylim(0,1) +
xlim(0,1) +
theme_bw()
ptop_T_MT <- myt2_reduced %>% group_by(Subset, pop) %>% summarize(Prop_T = mean(Prop_T), MT = sum(Sp2), N = n())
# ptop_T_MT <- ptop_T_MT[! ptop_T_MT$pop %in% c("Limh88", "CBCP"), ]
Model_7_full <- glm(cbind(MT, (N-MT)) ~  Prop_T * Subset, data = ptop_T_MT, family = binomial(link = "logit"))
#
# Model_7_full <- glm(Sp2 ~  Prop_T * Subset, data = myt2_reduced, family = binomial(link = "logit"))
#  overdisp_fun(Model_7_full)
# drop1(Model_7_full, test = "Chi")
# Model_7_1 <- update(Model_7_full, . ~ . - Prop_T:Subset)
# drop1(Model_7_1, test = "Chi")
Model_7_final <- Model_7_full
new_data5 <- myt2_reduced %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(Prop_T) ) %>% group_by(Subset) %>%  do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 10)))
predicted5 <- predict(Model_7_final, newdata = new_data5,  type="response", se.fit = T)
new_data5$fit <- predicted5$fit
new_data5$SE <- predicted5$se.fit
Pl_mod7 <- ggplot(new_data5, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) + facet_wrap(~Subset) + geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = myt2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
init_data_Model_7 <- myt2 %>% group_by(Subset, pop) %>% summarise(Prop_T = mean(morph == "T_m"),  freq_MT = mean(Sp == "M.trossulus"), N = n())
# init_data_Model_7 <- init_data_Model_7[init_data_Model_7$pop %in% c("Limh88", "CBCP"),  ]
Pl_mod7_with_initial_data <- Pl_mod7 + geom_point(data = init_data_Model_7, aes( y = freq_MT), shape = 21, size = 2 ) + scale_fill_continuous(low = "white", high = "black") + labs(x = "Proportion of mussels with T-morphotype", y = "Proportion of M.trossulus \n") + theme_bw()
## Визуализация новой модели с объединенными датасетами
mixed_data <- myt2[myt2$Subset %in% c("WBL"), ]
#
#
# #########################
#
Model_WBL_full <- glmer(congr ~ morph * freq_MT + (1 | pop), data = mixed_data, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
# overdisp_fun(Model_6_full)
# drop1(Model_7_full, test = "Chi")
Model_6_final <- Model_6_full
## Визуализация новой модели с объединенными датасетами
mixed_data <- myt2[myt2$Subset %in% c("WBL"), ]
#
#
# #########################
#
Model_WBL_full <- glmer(congr ~ morph * freq_MT + (1 | pop), data = mixed_data, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
# overdisp_fun(Model_6_full)
# drop1(Model_7_full, test = "Chi")
Model_6_final <- Model_WBL_full
>>>>>>> 936353f66a7106e9fdddad96842ab68a4d940d5b
Model_6_final_summary <- tidy(Model_6_final)
Model_6_final_summary <- Model_6_final_summary[,!(names(Model_6_final_summary) %in% c("group"))]
Model_6_final_R2_m <- r.squaredGLMM(Model_6_final)[1,1]
Model_6_final_R2_c <- r.squaredGLMM(Model_6_final)[1, 2]
new_data6 <-mixed_data %>% group_by(morph) %>% do(data.frame(freq_MT = seq(min(.$freq_MT), max(.$freq_MT), length.out = 100)))
# Предсказанные значеня в шкале вероятностей
new_data6$fit <- predict(Model_6_final, newdata = new_data6, type = "response", re.form = NA)
# Предсказанные значеня в шкале логитов
new_data6$fit_eta <- predict(Model_6_final, newdata = new_data6, re.form = NA)
<<<<<<< HEAD
=======
# Вычисление доверительного инеравала
>>>>>>> 936353f66a7106e9fdddad96842ab68a4d940d5b
X <- model.matrix(  ~ morph * freq_MT, data = new_data6) #Модельная матрица для визуализации
# Ошибки в шкале логитов
new_data6$se_eta <- sqrt(diag(X %*% vcov(Model_6_final) %*% t(X)))
new_data6$lwr <- logit_back(new_data6$fit_eta - 1.96 * new_data6$se_eta)
new_data6$upr <- logit_back(new_data6$fit_eta + 1.96 * new_data6$se_eta)
Pl_mod6 <- ggplot(new_data6, aes(x = freq_MT)) +
geom_ribbon(aes(ymin = lwr, ymax = upr, group = morph), alpha = 0.1)  +
geom_line(aes(y = fit, color = morph), size=1, linetype = 2) +
geom_rug(data = candidat_data_2, inherit.aes = FALSE,  aes(x = freq_MT), size = 0.1) +
scale_color_manual(values = c("blue", "red")) +
scale_fill_manual(values = c("blue", "red"))  +
xlim(0,1)
<<<<<<< HEAD
Pl_mod6
Model_7 <- glm(Sp2 ~  Prop_T , data = mixed_data, family = binomial(link = "logit"))
=======
Model_7 <- glm(Sp2 ~  Prop_T , data = mixed_data, family = binomial(link = "logit"))
# overdisp_fun(Model_7)
>>>>>>> 936353f66a7106e9fdddad96842ab68a4d940d5b
Model_7_final <- Model_7
Model_7_final_summary <- tidy(Model_7_final)
Model_7_R2 <- r.squaredGLMM(Model_7_final)[1,1]
new_data7 <- mixed_data %>% group_by(pop) %>% summarise(Prop_T = mean(Prop_T) ) %>%  do(data.frame(Prop_T = seq(min(.$Prop_T), max(.$Prop_T), length.out = 100)))
predicted7 <- predict(Model_7_final, newdata = new_data7,  type="response", se.fit = T)
new_data7$fit <- predicted7$fit
new_data7$SE <- predicted7$se.fit
Pl_mod7 <- ggplot(new_data7, aes(x = Prop_T, y = fit)) + geom_line(linetype = 2, color = "red", size = 1) +  geom_ribbon(aes(ymin = fit - 1.96*SE, ymax = fit + 1.96*SE), alpha = 0.1) + xlim(0, 1) + ylim(0, 1) +  geom_rug(data = candidat_data_2, inherit.aes = FALSE,  aes(x = Prop_T), size = 0.1) + geom_abline()
Pl_mod7
<<<<<<< HEAD
Pl_calc1_mod7 <- Pl_mod7 + geom_line(data = calc1_W, aes(x = P_T, y = Ptros), color = "blue", size = 1) + geom_line(data = calc1_B, aes(x = P_T, y = Ptros), color = "gray")  + geom_point(data = myt5, aes(x = Prop_T, y = freq_MT), size = 4, color = "red")  + labs(x = "Proportion of T-morphotype", y = "Proportion of M.trossulus \n")
Pl_calc1_mod7
=======
mixed_data <- myt2[myt2$Subset %in% c("WBL"), ]
Pl_teor_empir_7 <- ggplot(perms2(df = mixed_data, regr_model = Model_7_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
Pl_teor_empir_7 <- Pl_teor_empir_7 + ggtitle("Regression Model 8 \nvs Theoretical model Eq 3")
Pl_teor_empir_6 <- ggplot(perms4(df = mixed_data, regr_model = Model_6_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
# Pl_teor_empir_6 <- Pl_teor_empir_6 + ggtitle("Regression Model 6 \nvs Theoretical model Eq 1, Eq 2")
mixed_data <- myt2[myt2$Subset %in% c("WBL"), ]
Pl_teor_empir_7 <- ggplot(perms2(df = mixed_data, regr_model = Model_7_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
Pl_teor_empir_7 <- Pl_teor_empir_7 + ggtitle("Regression Model 8 \nvs Theoretical model Eq 3")
Pl_teor_empir_6 <- ggplot(perms4(df = mixed_data, regr_model = Model_6_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
# Pl_teor_empir_6 <- Pl_teor_empir_6 + ggtitle("Regression Model 6 \nvs Theoretical model Eq 1, Eq 2")
# Визуализация модели 7 и ленивого калькулятора 1, основанного на выборках максимально далеких по генетической структуре.
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = mixed_data, Subset = c("WBL"))
# Популяции наиболее смешанные
pops_max_mix <- max_mix(df = mixed_data, Subset = c("WBL"))
# Бублики для наиболее различных по стуртуре популяций
donat_max_dif <- donat(df = mixed_data[mixed_data$pop %in% pops_max_diff, ])
# Бублики для наиболее смешанных популяций
donat_max_mix <- donat(df = mixed_data[mixed_data$pop %in% pops_max_mix, ])
# Описание структуры калибровочных популяций
calc1_calib_pop_str <- calib_str(df = mixed_data, pop1 = pops_max_diff [1], pop2 = pops_max_diff [2])
calc2_calib_pop_str <- calib_str(df = mixed_data, pop1 = pops_max_mix [1], pop2 = pops_max_mix [2])
calc1_W <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
calc1_B <- calc1(donat_max_mix[1], donat_max_mix[2]) #Предсказания калькулятора 1 на основе наиболее смешанных популяций
# coef_calc1_W  <- coef(lm(Ptros ~ P_T, data = calc1_W )) #Коэффицинты для теоретичекой модели, описывющей калькулятор 1
myt5 <- myt3[myt3$Subset %in% c("WBL"), ]
Pl_calc1_mod7 <- Pl_mod7 + geom_line(data = calc1_W, aes(x = P_T, y = Ptros), color = "blue", size = 1) + geom_line(data = calc1_B, aes(x = P_T, y = Ptros), color = "gray")  + geom_point(data = myt5, aes(x = Prop_T, y = freq_MT), size = 4, color = "red")  + labs(x = "Proportion of T-morphotype", y = "Proportion of M.trossulus \n")
# Визуализация модели 4 и ленивого калькулятора 2, основанного на выборках максимально смешанных.
>>>>>>> 936353f66a7106e9fdddad96842ab68a4d940d5b
calc2_W <- calc2(donat_max_mix[1], donat_max_mix[2])
calc2_B <- calc2(donat_max_dif[1], donat_max_dif[2])
# Числа, необходимые для вычсления предсказанных значений для калькулятора №2
coef_calc2 <- mixed_data[mixed_data$pop %in% calc2_calib_pop_str$pop, ] %>% summarise(P_T_ME = mean(Sp == "M.edulis" & morph == "T_m"), P_T_MT = mean(Sp == "M.trossulus" & morph == "T_m"))
<<<<<<< HEAD
coef_calc2
testing_congr <- myt5 %>% group_by(pop, morph) %>% summarize(Pcorrect = mean(congr == 1), freq_MT = mean(freq_MT))
Pl_calc2_mod6 <- Pl_mod6 + geom_line(data = calc2_W, aes(x = freq_MT, y = P_MT_T), color = "red", size = 2) + geom_line(data = calc2_W, aes(x = freq_MT, y = P_ME_E), color = "blue", size = 2) + geom_line(data = calc2_B, aes(x = freq_MT, y = P_MT_T), color = "gray") + geom_line(data = calc2_B, aes(x = freq_MT, y = P_ME_E), color = "gray") + geom_point(data = testing_congr, aes(x = freq_MT, y = Pcorrect, fill = morph), shape = 24, size = 3, position = position_dodge(width = 0) ) + labs(x = "Proportion of M.trossulus", y = "Probability of \ncorrect identification ")
Pl_calc2_mod6
grid.arrange(Pl_teor_empir_6, Pl_teor_empir_7, Pl_calc1_mod6, Pl_calc2_mod7, nrow =2)
Pl_calc2_mod6 <- Pl_mod6 + geom_line(data = calc2_W, aes(x = freq_MT, y = P_MT_T), color = "red", size = 2) + geom_line(data = calc2_W, aes(x = freq_MT, y = P_ME_E), color = "blue", size = 2) + geom_line(data = calc2_B, aes(x = freq_MT, y = P_MT_T), color = "gray") + geom_line(data = calc2_B, aes(x = freq_MT, y = P_ME_E), color = "gray") + geom_point(data = testing_congr, aes(x = freq_MT, y = Pcorrect, fill = morph), shape = 24, size = 3, position = position_dodge(width = 0) ) + labs(x = "Proportion of M.trossulus", y = "Probability of \ncorrect identification ")
grid.arrange(Pl_teor_empir_6, Pl_teor_empir_7, Pl_calc1_mod7, Pl_calc2_mod6, nrow =2)
grid.arrange(Pl_teor_empir_7, Pl_teor_empir_6, Pl_calc1_mod7, Pl_calc2_mod6, nrow =2)
Pl_teor_empir_6 <- ggplot(perms4(df = mixed_data, regr_model = Model_6_final), aes(x = Delta, y = Goodness)) + geom_point(size = 0.1) + geom_smooth(se = F) + labs(y = "Goodness \n")
grid.arrange(Pl_teor_empir_7, Pl_teor_empir_6, Pl_calc1_mod7, Pl_calc2_mod6, nrow =2)
grid.arrange(Pl_teor_empir_7, Pl_teor_empir_6, Pl_calc1_mod7, Pl_calc2_mod6, nrow =2)
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = mixed_data, Subset = c("GOM"))
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = myt2, Subset = c("GOM"))
pops_max_diff
=======
testing_congr <- myt5 %>% group_by(pop, morph) %>% summarize(Pcorrect = mean(congr == 1), freq_MT = mean(freq_MT))
Pl_calc2_mod6 <- Pl_mod6 + geom_line(data = calc2_W, aes(x = freq_MT, y = P_MT_T), color = "red", size = 2) + geom_line(data = calc2_W, aes(x = freq_MT, y = P_ME_E), color = "blue", size = 2) + geom_line(data = calc2_B, aes(x = freq_MT, y = P_MT_T), color = "gray") + geom_line(data = calc2_B, aes(x = freq_MT, y = P_ME_E), color = "gray") + geom_point(data = testing_congr, aes(x = freq_MT, y = Pcorrect, fill = morph), shape = 24, size = 3, position = position_dodge(width = 0) ) + labs(x = "Proportion of M.trossulus", y = "Probability of \ncorrect identification ")
grid.arrange(Pl_teor_empir_7, Pl_teor_empir_6, Pl_calc1_mod7, Pl_calc2_mod6, nrow =2)
T
empty_row <- rep(NA, 7)
all_calibr <- rbind(empty_row, as.data.frame(calc1_calib_pop_str), empty_row, as.data.frame(calc2_calib_pop_str))
all_calibr$P_T_ME <- round(all_calibr$P_T_ME, 2)
all_calibr$P_T_MT <- round(all_calibr$P_T_MT, 2)
all_calibr$Ptros <- round(all_calibr$Ptros, 2)
all_calibr$pop <- as.character(all_calibr$pop)
all_calibr$pop[is.na(all_calibr$pop)] <- c("**Theoretical model 1**", "**Theoretical model 2**")
kable(all_calibr)
# Визуализация модели 7 и ленивого калькулятора 1, основанного на выборках максимально далеких по генетической структуре.
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = myt2, Subset = c("GOM"))
>>>>>>> 936353f66a7106e9fdddad96842ab68a4d940d5b
# Популяции наиболее смешанные
pops_max_mix <- max_mix(df = myt2, Subset = c("GOM"))
# Бублики для наиболее различных по стуртуре популяций
donat_max_dif <- donat(df = myt2[myt2$pop %in% pops_max_diff, ])
# Бублики для наиболее смешанных популяций
donat_max_mix <- donat(df = myt2[myt2$pop %in% pops_max_mix, ])
# Описание структуры калибровочных популяций
calc1_calib_pop_str <- calib_str(df = myt2, pop1 = pops_max_diff [1], pop2 = pops_max_diff [2])
calc2_calib_pop_str <- calib_str(df = myt2, pop1 = pops_max_mix [1], pop2 = pops_max_mix [2])
<<<<<<< HEAD
calc1_W <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
calc1_B <- calc1(donat_max_mix[1], donat_max_mix[2]) #Предсказания калькулятора 1 на основе наиболее смешанных популяций
calc1_W
calc1_W
calc1_B
ggplot(calc1_GOM, aes(x = P_T, y = Ptros)) + geom_line()
calc1_GOM <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
ggplot(calc1_GOM, aes(x = P_T, y = Ptros)) + geom_line()
calc1_GOM_good <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
calc1_GOM_bad <- calc1(donat_max_mix[1], donat_max_mix[2]) #Предсказания калькулятора 1 на основе наиболее смешанных популяций
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line() + geom_line(data = calc1_GOM_bad)
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray")
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray") + geom_point(data = myt2[myt2$pop %in% pops_max_diff, ], aes(x = Prop_T, y = freq_MT))
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray") + geom_point(data = init_data_Model_7, aes(x = Prop_T, y = freq_MT), shape = 21, size = 2 )
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray") + geom_point(data = init_data_Model_7[init_data_Model_7$Subset == "GOM", ], aes(x = Prop_T, y = freq_MT), shape = 21, size = 2 )
myt2_WBL
nrow(myt2_WBL)
length(unique(myt2_WBL$pop))
((29^2)-29)/2
Pl_mod6_with_initial_data
Pl_mod7_with_initial_data
residuals(Model_2_final)
qplot(y = residuals(Model_2_final), x = myt2$size)
qplot(y = residuals(Model_2_final), x = myt2$size[!is.na(myt2$myt2$size)])
fortify(Model_2_final)
fortify(Model_2_final)
Model_2_final
fortify(Model_2_final)
fortify(Model_2_final
fortify(Model_2_final)
fortify(Model_2_final)
=======
calc1_GOM_good <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
calc1_GOM_bad <- calc1(donat_max_mix[1], donat_max_mix[2]) #Предсказания калькулятора 1 на основе наиболее смешанных популяций
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray") + geom_point(data = init_data_Model_7[init_data_Model_7$Subset == "GOM", ], aes(x = Prop_T, y = freq_MT), shape = 21, size = 2 )
# coef_calc1_W  <- coef(lm(Ptros ~ P_T, data = calc1_W )) #Коэффицинты для теоретичекой модели, описывющей калькулятор 1
# Визуализация модели 7 и ленивого калькулятора 1, основанного на выборках максимально далеких по генетической структуре.
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = myt2, Subset = c("BALT"))
# Популяции наиболее смешанные
pops_max_mix <- max_mix(df = myt2, Subset = c("BALT"))
# Бублики для наиболее различных по стуртуре популяций
donat_max_dif <- donat(df = myt2[myt2$pop %in% pops_max_diff, ])
# Бублики для наиболее смешанных популяций
donat_max_mix <- donat(df = myt2[myt2$pop %in% pops_max_mix, ])
# Описание структуры калибровочных популяций
calc1_calib_pop_str <- calib_str(df = myt2, pop1 = pops_max_diff [1], pop2 = pops_max_diff [2])
calc2_calib_pop_str <- calib_str(df = myt2, pop1 = pops_max_mix [1], pop2 = pops_max_mix [2])
calc1_GOM_good <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
calc1_GOM_bad <- calc1(donat_max_mix[1], donat_max_mix[2]) #Предсказания калькулятора 1 на основе наиболее смешанных популяций
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray") + geom_point(data = init_data_Model_7[init_data_Model_7$Subset == "GOM", ], aes(x = Prop_T, y = freq_MT), shape = 21, size = 2 )
# coef_calc1_W  <- coef(lm(Ptros ~ P_T, data = calc1_W )) #Коэффицинты для теоретичекой модели, описывющей калькулятор 1
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray") + geom_point(data = init_data_Model_7[init_data_Model_7$Subset == "BALT", ], aes(x = Prop_T, y = freq_MT), shape = 21, size = 2 )
# Визуализация модели 7 и ленивого калькулятора 1, основанного на выборках максимально далеких по генетической структуре.
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = myt2, Subset = c("SCOT"))
# Популяции наиболее смешанные
pops_max_mix <- max_mix(df = myt2, Subset = c("SCOT"))
# Бублики для наиболее различных по стуртуре популяций
donat_max_dif <- donat(df = myt2[myt2$pop %in% pops_max_diff, ])
# Бублики для наиболее смешанных популяций
donat_max_mix <- donat(df = myt2[myt2$pop %in% pops_max_mix, ])
# Описание структуры калибровочных популяций
calc1_calib_pop_str <- calib_str(df = myt2, pop1 = pops_max_diff [1], pop2 = pops_max_diff [2])
calc2_calib_pop_str <- calib_str(df = myt2, pop1 = pops_max_mix [1], pop2 = pops_max_mix [2])
calc1_GOM_good <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
calc1_GOM_bad <- calc1(donat_max_mix[1], donat_max_mix[2]) #Предсказания калькулятора 1 на основе наиболее смешанных популяций
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray") + geom_point(data = init_data_Model_7[init_data_Model_7$Subset == "SCOT", ], aes(x = Prop_T, y = freq_MT), shape = 21, size = 2 )
# coef_calc1_W  <- coef(lm(Ptros ~ P_T, data = calc1_W )) #Коэффицинты для теоретичекой модели, описывющей калькулятор 1
Subset <- "GOM"
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = myt2, Subset = c(Subset))
# Визуализация модели 7 и ленивого калькулятора 1, основанного на выборках максимально далеких по генетической структуре.
Subset <- "GOM"
# Популяции наиболее различные по генетической структуре
pops_max_diff <- max_dif(df = myt2, Subset = c(Subset))
# Популяции наиболее смешанные
pops_max_mix <- max_mix(df = myt2, Subset = c(Subset))
# Бублики для наиболее различных по стуртуре популяций
donat_max_dif <- donat(df = myt2[myt2$pop %in% pops_max_diff, ])
# Бублики для наиболее смешанных популяций
donat_max_mix <- donat(df = myt2[myt2$pop %in% pops_max_mix, ])
# Описание структуры калибровочных популяций
calc1_calib_pop_str <- calib_str(df = myt2, pop1 = pops_max_diff [1], pop2 = pops_max_diff [2])
calc2_calib_pop_str <- calib_str(df = myt2, pop1 = pops_max_mix [1], pop2 = pops_max_mix [2])
calc1_GOM_good <- calc1(donat_max_dif[1], donat_max_dif[2]) #Предсказания калькулятора 1 на основе наиболее различных по генетической структуре популяций
calc1_GOM_bad <- calc1(donat_max_mix[1], donat_max_mix[2]) #Предсказания калькулятора 1 на основе наиболее смешанных популяций
ggplot(calc1_GOM_good, aes(x = P_T, y = Ptros)) + geom_line(color = "blue") + geom_line(data = calc1_GOM_bad, color = "gray") + geom_point(data = init_data_Model_7[init_data_Model_7$Subset == Subset, ], aes(x = Prop_T, y = freq_MT), shape = 21, size = 2 )
# coef_calc1_W  <- coef(lm(Ptros ~ P_T, data = calc1_W )) #Коэффицинты для теоретичекой модели, описывющей калькулятор 1
myt_X <- myt2[myt2$Subset %in% c("WBL", "BH"), ]
is.na(myt_X$size)
sum(is.na(myt_X$size))
sum(!is.na(myt_X$size))
Mod_X <- glmer(ind ~ size*Sp2*Subset + (1|pop), data = myt_X, family = "binomial")
Mod_X <- glmer(ind ~ size*Sp2*Subset + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Mod_X_rs <- glmer(ind ~ size*Subset + (1 + size|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
myt_X$Sp
myt_X$Sp2
Mod_X <- glmer(ind ~ size*Sp*Subset + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Mod_X_rs <- glmer(ind ~ size*Sp*Subset + (1 + size|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Mod_X <- glmer(ind ~ scale(size)*Sp*Subset + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Mod_X_rs <- glmer(ind ~ scale(size)*Sp*Subset + (1 + size|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
AIC(Mod_X, Mod_X_rs)
resid_cor2
resid_cor
ggplot(new_data_size, aes(x = size, y = Predict, group = pop)) + geom_line() + facet_wrap(~Subset)
Mod_X_rs <- glmer(ind ~ scale(size)*Sp*Subset + (1 + size|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)))
Mod_X <- glmer(ind ~ scale(size)*Sp + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Mod_X_rs <- glmer(ind ~ scale(size)*Sp + (1 + size|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)))
AIC(Mod_X, Mod_X_rs)
summary(Mod_X_rs)
Mod_X <- glmer(ind ~ Sp*Subset + Size + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Mod_X <- glmer(ind ~ Sp*Subset + size + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Mod_X_rs <- glmer(ind ~ Sp*Subset + size + (1 + size|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e6)))
AIC(Mod_X, Mod_X_rs)
summary(Mod_X_rs)
r.squaredGLMM(Mod_X_rs)
Mod_X <- glmer(ind ~ Sp*Subset * size + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))
Mod_X <- glmer(ind ~ Sp*Subset * size + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))
library("optimx")
Mod_X <- glmer(ind ~ Sp*Subset * size + (1|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))
Mod_X_rs <- glmer(ind ~ Sp*Subset * size + (1 + size|pop), data = myt_X, family = "binomial", control=glmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)))
AIC(Mod_X, Mod_X_rs)
summary(Mod_X)
library(doBy)
myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~ Sp + size, data = .))
myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~ Sp + size, family = "binomial", data = .))
myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~ size, family = "binomial", data = .))
myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~ Sp + size, family = "binomial", data = .))
table(myt_X$pop, myt_X$Sp)
myt_X <- myt2[myt2$Subset %in% c("WBL", "BH"), ]
myt_X$pop <- factor(myt_X$pop)
unique(myt_X$pop)
table(myt_X$pop, myt_X$Sp)
myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~  size, family = "binomial", data = .))
dd <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~  size, family = "binomial", data = .))
str(dd)
dd$model
myt_X$Sp$AIC
myt_X$Sp
dd$model$AIC
dd$model
summary(dd$model)
dd %>% tidy(model)
size_models <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~  size, family = "binomial", data = .))
size_models %>% tidy(model)
size_models_res <- size_models %>% tidy(model)
size_models_res
size_models_res$term
size_models_res[size_models_res$term != "(Intercept)"]
size_models_res[size_models_res$term != "(Intercept)", ]
size_models_res_slope <- size_models_res[size_models_res$term != "(Intercept)", ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "hochberg")
size_models_res_slope
View(size_models_res_slope)
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models_res_slope[size_models_res_slope$p.value < 0.05, ]
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~  Sp + size, family = "binomial", data = .))
table(myt_X$pop, myt_X$Sp)
size_models <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~  size, family = "binomial", data = .))
size_models_res <- size_models %>% tidy(model)
size_models_res_slope <- size_models_res[size_models_res$term != "(Intercept)", ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "hochberg")
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models_res_slope[size_models_res_slope$p.value < 0.05, ]
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(congr ~  size, family = "binomial", data = .))
size_models_res <- size_models %>% tidy(model)
size_models_res_slope <- size_models_res[size_models_res$term != "(Intercept)", ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "hochberg")
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models_res_slope[size_models_res_slope$p.value < 0.05, ]
size_models <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(congr ~  size, family = "binomial", data = .))
size_models <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~  size, family = "binomial", data = .))
size_models_res <- size_models %>% tidy(model)
size_models_res_slope <- size_models_res[size_models_res$term != "(Intercept)", ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "hochberg")
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
myt_X %>% group_by(Subset, pop) %>% summarise(rang = range(size))
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(siz))
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))[pop == "umba",]
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))[myt_X$pop == "umba",]
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "umba")
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "banka")
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "berzakol")
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "abram")
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "seredina_sub")
size_models <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~  size, family = "binomial", data = .))
size_models_res <- size_models %>% tidy(model)
size_models_res_slope <- size_models_res[size_models_res$term != "(Intercept)", ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "hochberg")
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "ustie_sub")
size_models <- myt2 %>% group_by(Subset, pop) %>% do(model = glm(ind ~  size, family = "binomial", data = .))
size_models <- myt_X %>% group_by(Subset, pop) %>% do(model = glm(ind ~  size, family = "binomial", data = .))
size_models_res <- size_models %>% tidy(model)
size_models_res_slope <- size_models_res[size_models_res$term != "(Intercept)", ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "hochberg")
size_models_res_slope
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "ustie_sub")
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models_res_slope[size_models_res_slope$p.value < 0.05, ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "bonferroni")
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "hochberg")
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "ustie_sub")
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "BH")
myt_X %>% group_by(Subset, pop) %>% summarise(min = min(size), max = max(size))%>% filter(pop == "ustie_sub")
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
size_models_res_slope$p_adj <- p.adjust(size_models_res_slope$p.value, method = "hochberg")
size_models_res_slope[size_models_res_slope$p_adj < 0.05, ]
>>>>>>> 936353f66a7106e9fdddad96842ab68a4d940d5b
