calc2_predict_W <- calc2(W[1], W[2])
names(calc2_predict_W) <- c("freq_MT", "T_m",  "E_m")
calc2_predict_W <- melt(calc2_predict_W, id.vars = "freq_MT" )
names(calc2_predict_W) <- c("freq_MT", "morph", "Bayes_predict")
Model_prediction <- expand.grid(Subset = unique(df_selected$Subset),  morph = levels(df_selected$morph), freq_MT = seq(0, 1, 0.01))
Model_prediction$Predict <- predict(regr_model, newdata = Model_prediction, type = "response",  re.form = NA )
all_prediction <- merge(calc2_predict_W, Model_prediction, by = c("freq_MT", "morph"))
perm_pairs$Goodness[i] <- 1/mean((all_prediction$Bayes_predict - all_prediction$Predict)^2, na.rm = T)
perm_pairs$pop[i] <- unique(as.character(df_selected$pop))
}
perm_pairs
}
## Функция для поиска ниболее различающихся выборок по генетической струкутре
max_dif <- function(df = myt2, Subset = "W", ...) {
require(dplyr)
df = df[df$Subset %in% Subset, ]
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
perm_pairs$Delta[i] <-
max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2]))) +
min(c(means$freq_MT[1],means$freq_MT[2])) *(1 - max(c(means$freq_MT[1],means$freq_MT[2])))
}
max_dif <- perm_pairs[which.max(perm_pairs$Delta), ]
c(max_dif$First, max_dif$Second)
}
## Функция для поиска ниболее различающихся выборок по частоте T-морфотипа
max_dif_T <- function(df = myt2, Subset = "W", ...) {
require(dplyr)
df = df[df$Subset %in% Subset, ]
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_T = mean(Prop_T))
perm_pairs$Delta[i] <-
max(c(means$freq_T[1],means$freq_T[2])) *(1 - min(c(means$freq_T[1],means$freq_T[2]))) +
min(c(means$freq_T[1],means$freq_T[2])) *(1 - max(c(means$freq_T[1],means$freq_T[2])))
}
max_dif <- perm_pairs[which.max(perm_pairs$Delta), ]
c(max_dif$First, max_dif$Second)
}
# Функция для поиска выборок наиболее смешанных по генетической структуре
max_mix <- function(df = myt2, Subset = "W", ...) {
require(dplyr)
df = df[df$Subset %in% Subset, ]
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_MT = mean(freq_MT))
perm_pairs$Delta[i] <-
max(c(means$freq_MT[1],means$freq_MT[2])) *(1 - min(c(means$freq_MT[1],means$freq_MT[2]))) +
min(c(means$freq_MT[1],means$freq_MT[2])) *(1 - max(c(means$freq_MT[1],means$freq_MT[2])))
}
max_mix <- perm_pairs[which.min(abs(perm_pairs$Delta - 0.5)), ]
c(max_mix$First, max_mix$Second)
}
# Функция для поиска выборок наиболее смешанных по частоте T-морфотипа
max_mix_T <- function(df = myt2, Subset = "W", ...) {
require(dplyr)
df = df[df$Subset %in% Subset, ]
df$pop <- as.character(df$pop)
perm_pairs <- expand.grid(First = unique(df$pop), Second = unique(df$pop))
perm_pairs <- perm_pairs[perm_pairs$First != perm_pairs$Second,]
perm_pairs <- perm_pairs[perm_pairs$Second != perm_pairs$First,]
perm_pairs$First <- as.character(perm_pairs$First)
perm_pairs$Second <- as.character(perm_pairs$Second)
perm_pairs$Delta <- NA
for(i in 1:nrow(perm_pairs)){
df_selected <- df[df$pop %in% c(perm_pairs$First[i], perm_pairs$Second[i]),]
means <- df_selected %>% group_by(pop) %>% summarise(freq_T = mean(Prop_T))
perm_pairs$Delta[i] <-
max(c(means$freq_T[1],means$freq_T[2])) *(1 - min(c(means$freq_T[1],means$freq_T[2]))) +
min(c(means$freq_T[1],means$freq_T[2])) *(1 - max(c(means$freq_T[1],means$freq_T[2])))
}
max_mix <- perm_pairs[which.min(abs(perm_pairs$Delta - 0.5)), ]
c(max_mix$First, max_mix$Second)
}
### Функция для описания структуры калибровочных выборок
calib_str <- function(df = myt2, pop1, pop2){
df =df[df$pop %in% c(pop1, pop2), ]
df$Subset <- factor(df$Subset)
str_calib <- df %>% group_by(pop, Subset) %>% summarize(N_E = sum(Sp == "M.edulis"), N_T = sum(Sp ==  "M.trossulus"), P_T_ME = mean(Sp == "M.edulis" & morph == "T_m"), P_T_MT = mean(Sp == "M.trossulus" & morph == "T_m"), Ptros = mean(freq_MT) )
str_calib
}
########################################
# Функция для обратной трансформации логитов
logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация
# Функция для оценки сверхдисперсии в моделях GLM
overdisp_fun <- function(model) {
rdf <- df.residual(model)  # Число степеней свободы N - p
if (inherits(model, 'negbin')) rdf <- rdf - 1 ## учитываем k в NegBin GLMM
rp <- residuals(model,type='pearson') # Пирсоновские остатки
Pearson.chisq <- sum(rp^2) # Сумма квадратов остатков, подчиняется Хи-квадрат распределению
prat <- Pearson.chisq/rdf  # Отношение суммы квадратов остатков к числу степеней свободы
pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE) # Уровень значимости
c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)        # Вывод результатов
}
# Chunk 6
##### Theme for ggplot ######
theme_set(theme_bw() + theme(axis.title.x = element_text(size = 10), axis.title.y = element_text(size = 10), axis.text= element_text(size = 10), legend.position = "none" , title = element_text(size = 10)))
# Chunk 7
#### Data reading and initial preparation #####
myt <- read.table("data_salinity3.csv", header = T, sep = ",")
# Оставляем только мидий, у которых есть оценка морфотипа
myt2_all <- myt[!is.na(myt$ind), ]
### Объединяем популяции в данных Сары #####
# myt2_all$pop2 <- myt2_all$pop
#
# myt2_all$pop[myt2_all$pop %in% c("CBCP", "CBSC")] <- "CB"
#
# myt2_all$pop[myt2_all$pop %in% c("MDRE",   "MDRW")] <- "MDR"
# Подразделяем данные на сабсеты
myt2_all$Subset[myt2_all$sea == "barents" & myt2_all$sal_place == "fresh"] <- "WBL"
myt2_all$Subset[myt2_all$sea == "barents" & myt2_all$sal_place == "normal"] <- "BH"
myt2_all$Subset[myt2_all$sea == "white" & myt2_all$sal_place == "normal"] <- "WBL"
myt2_all$Subset[myt2_all$sea == "white" & myt2_all$sal_place == "fresh"] <- "WBL"
myt2_all$Subset[myt2_all$sea == "Baltic"] <- "BALT"
myt2_all$Subset[myt2_all$sea == "GOM"] <- "GOM"
myt2_all$Subset[myt2_all$sea == "Norway"] <- "NORW"
myt2_all$Subset[myt2_all$sea == "Scotland"] <- "SCOT"
myt2_all$Subset <- factor(myt2_all$Subset, levels = c("WBL", "BH", "NORW", "BALT", "SCOT", "GOM" ))
# Вводим обозначения
myt2_all$Sp [myt2_all$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt2_all$Sp [myt2_all$str <= 0.5] <- "M.edulis"
myt2_all$Sp <- factor(myt2_all$Sp)
# Вводим обозначения для морфотипов
myt2_all$morph <- ifelse(myt2_all$ind == 1, "T_m", "E_m")
myt2_all$morph <- factor(myt2_all$morph)
# Бинарное обозначение видов
myt2_all$Sp2 <- ifelse(myt2_all$Sp == "M.trossulus", 1, 0)
#Correct identification
myt2_all$congr <- ifelse((myt2_all$ind == 1 & myt2_all$Sp == "M.trossulus") | (myt2_all$ind == 0 & myt2_all$Sp == "M.edulis"), 1, 0   )
# Частота M.trossulus в популяции
freq_MT <- myt2_all %>% group_by(pop) %>% summarise(freq_MT = mean(Sp2))
myt2_all <- merge(myt2_all, freq_MT)
# Частота T-морфотипа в популяции
Prop_T <- myt2_all %>% group_by(pop) %>% summarise(Prop_T = mean(ind))
myt2_all <- merge(myt2_all, Prop_T)
# Chunk 8
Eq3 <- function(PT, donat){
P_T_edu <- donat[2]
P_T_tros <- donat[1]
b1 <- 1/(P_T_tros - P_T_edu)
b0 <- b1*P_T_edu
# predictor <- b1*PT - b0
#
# Ptros <- exp(predictor)/(1 + exp(predictor))
Ptros = (PT - P_T_edu)/ ((P_T_tros) -  P_T_edu)
Ptros <- ifelse(Ptros <0 | Ptros >1 , NA, Ptros)
Ptros
}
Eq1 <- function(Ptros, donat){
P_T_MT <- donat[1]
P_T_ME <- donat[2]
P_MT_T <- (P_T_MT * Ptros)/(P_T_MT * Ptros + P_T_ME*(1-Ptros))
P_MT_T
}
Eq2 <- function(Ptros, donat){
P_T_MT <- donat[1]
P_T_ME <- donat[2]
P_ME_E <- ((1 - P_T_ME) * (1 - Ptros))/(1 - P_T_ME + Ptros * (P_T_ME - P_T_MT))
P_ME_E
}
# Предсказания по уравнениям, для случая, когда в качестве калибровочных выборок берутся максимально различные и мексимально смешанные выборки по частоте T-морфотипа
predict_obs_Eq123_T <- function(Set, pop_max_diff, pop_max_mix){
donat_all <- donat(df = myt2_all[myt2_all$Subset == Set, ])
donat_max_diff <- donat(myt2_all[myt2_all$pop %in% pop_max_diff, ])
donat_max_mix <- donat(myt2_all[myt2_all$pop %in% pop_max_mix, ])
df <- myt2_all %>% filter(Subset == Set) %>% group_by(pop) %>% summarise(PT = mean(ind == 1), Ptros_obs = mean(Sp == "M.trossulus"), N_edu = sum(Sp == "M.edulis"), N_tros = sum(Sp == "M.trossulus"), Set = unique(Subset)) %>%
mutate(Ptros_Eq3_diff = Eq3(PT, donat_max_diff),
Ptros_Eq3_mix = Eq3(PT, donat_max_mix),
Ptros_Eq3_all = Eq3(PT, donat_all),
P_MT_T_Eq1_all_diff = Eq1(Ptros_Eq3_diff, donat_max_diff),
P_MT_T_Eq1_diff_mix = Eq1(Ptros_Eq3_diff, donat_max_mix),
P_MT_T_Eq1_diff_all = Eq1(Ptros_Eq3_diff, donat_all),
P_MT_T_Eq1_mix_diff = Eq1(Ptros_Eq3_mix, donat_max_diff),
P_MT_T_Eq1_mix_mix = Eq1(Ptros_Eq3_mix, donat_max_mix),
P_MT_T_Eq1_mix_all = Eq1(Ptros_Eq3_mix, donat_all),
P_MT_T_Eq1_all_diff = Eq1(Ptros_Eq3_all, donat_max_diff),
P_MT_T_Eq1_all_mix = Eq1(Ptros_Eq3_all, donat_max_mix),
P_MT_T_Eq1_all_all = Eq1(Ptros_Eq3_all, donat_all),
P_ME_E_Eq2_all_diff = Eq2(Ptros_Eq3_diff, donat_max_diff),
P_ME_E_Eq2_diff_mix = Eq2(Ptros_Eq3_diff, donat_max_mix),
P_ME_E_Eq2_diff_all = Eq2(Ptros_Eq3_diff, donat_all),
P_ME_E_Eq2_mix_diff = Eq2(Ptros_Eq3_mix, donat_max_diff),
P_ME_E_Eq2_mix_mix = Eq2(Ptros_Eq3_mix, donat_max_mix),
P_ME_E_Eq2_mix_all = Eq2(Ptros_Eq3_mix, donat_all),
P_ME_E_Eq2_all_diff = Eq2(Ptros_Eq3_all, donat_max_diff),
P_ME_E_Eq2_all_mix = Eq2(Ptros_Eq3_all, donat_max_mix),
P_ME_E_Eq2_all_all = Eq2(Ptros_Eq3_all, donat_all))
df2 <- myt2_all %>% filter(Subset == Set, morph == "T_m") %>% group_by(pop) %>% summarise(P_MT_T_obs = mean(ind == 1 & Sp == "M.trossulus"))
df3 <- myt2_all %>% filter(Subset == Set, morph == "E_m") %>% group_by(pop) %>% summarise(P_ME_E_obs = mean(ind == 0 & Sp == "M.edulis"))
dd <- merge(df, df2, all = T)
ddd <- merge(dd, df3, all = T)
df_final <- ddd
df_final$max_mix <- 0
df_final$max_dif <- 0
max_dif_pop <- max_dif_T(df = myt2_all, Subset = Set)
max_mix_pop <- max_mix_T(df = myt2_all, Subset = Set)
df_final$max_dif [df_final$pop %in% max_dif_pop] <- 1
df_final$max_mix [df_final$pop %in% max_mix_pop] <- 1
df_final$Set = Set
result <- df_final
result
}
# Chunk 9
# Популяции с наиболлее смешенными частотами T-морфотипа и результаты генотипирования для них
# Ручной поиск наилучшей популяции
# Критерий отбора
#  max_dif объем генотипированных особей максимальный + наиболее различающаяся частота T-morphotype
# max_mix объем генотипированных особей максимальный + частота T-morphotype наиболее близка к среднему между P_T_tros и P_T_edu значению
pop_max_diff_WBL <- c("ivan2", "zmis")
donat_max_diff_WBL <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_WBL, ])
pop_max_diff_BH <- c("ivan_us", "seredina")
donat_max_diff_BH <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_BH, ])
pop_max_diff_GOM <- c("VH", "CBE")
donat_max_diff_GOM <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_GOM, ])
pop_max_diff_BALT <- c("kast05", "Solvesborg")
donat_max_diff_BALT <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_BALT, ])
pop_max_diff_NORW <- c("Esp04", "Bergen_MV")
donat_max_diff_NORW <- donat(df = myt2_all[myt2_all$pop %in% pop_max_diff_NORW, ])
pop_max_mix_WBL <- c("belok")
donat_max_mix_WBL <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_WBL, ])
pop_max_mix_BH <- "seredina_sub"
donat_max_mix_BH <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_BH, ])
pop_max_mix_GOM <- "MDRW"
donat_max_mix_GOM <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_GOM, ])
pop_max_mix_BALT <- "kast87"
donat_max_mix_BALT <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_BALT, ])
pop_max_mix_NORW <- "Berg_new"
donat_max_mix_NORW <- donat(df = myt2_all[myt2_all$pop %in% pop_max_mix_NORW, ])
WBL_T <- as.data.frame(predict_obs_Eq123_T("WBL", pop_max_diff_WBL, pop_max_mix_WBL))
BH_T <-  as.data.frame(predict_obs_Eq123_T("BH", pop_max_diff_BH, pop_max_mix_BH))
GOM_T <- as.data.frame(predict_obs_Eq123_T("GOM", pop_max_diff_GOM, pop_max_mix_GOM))
BALT_T <- as.data.frame(predict_obs_Eq123_T("BALT", pop_max_diff_BALT, pop_max_mix_BALT))
NORW_T <- as.data.frame(predict_obs_Eq123_T("NORW", pop_max_diff_NORW, pop_max_mix_NORW))
all_obs_predict_T <- rbind(WBL_T, BH_T, GOM_T, BALT_T, NORW_T)
all_obs_predict_T_work <- all_obs_predict_T %>% select(Set, pop, PT, Ptros_obs, N_edu, N_tros, P_MT_T_obs,P_ME_E_obs, Ptros_Eq3_diff, P_MT_T_Eq1_diff_mix, P_ME_E_Eq2_diff_mix )
summary_predict_observ <- all_obs_predict_T_work %>% group_by(Set) %>% summarise(PT_mean = mean(PT), n_pop = length(pop),
n_out = sum(is.na(Ptros_Eq3_diff)),
Prop_out = round(n_out/n_pop*100, 1),
SS_eq3 = round(sum( ((Ptros_obs -Ptros_Eq3_diff)^2)/(n_pop - n_out), na.rm = T), 2),
SS_edu_eq2 = round(sum( ((P_ME_E_obs - P_ME_E_Eq2_diff_mix)^2)/(n_pop - n_out), na.rm = T), 2),
SS_tros_eq1 = round(sum( ((P_MT_T_obs - P_MT_T_Eq1_diff_mix)^2)/(n_pop - n_out), na.rm = T), 2)
)
summary_predict_observ$Set <- factor(summary_predict_observ$Set, levels = c("WBL", "BH", "GOM", "BALT", "NORW"))
summary_predict_observ$dif_pop1 <- c(pop_max_diff_BALT[1], pop_max_diff_BH[1], pop_max_diff_GOM[1], pop_max_diff_NORW[1], pop_max_diff_WBL[1])
summary_predict_observ$dif_pop2 <- c(pop_max_diff_BALT[2], pop_max_diff_BH[2], pop_max_diff_GOM[2], pop_max_diff_NORW[2], pop_max_diff_WBL[2])
summary_predict_observ$mix_pop <- c(pop_max_mix_BALT, pop_max_mix_BH, pop_max_mix_GOM, pop_max_mix_NORW, pop_max_mix_WBL)
summary_predict_observ$dif_pops <- paste(summary_predict_observ$dif_pop1, summary_predict_observ$dif_pop2)
dd <- summary_predict_observ %>% group_by(Set) %>%  summarise(T_tros_eq3 = donat(myt2_all[myt2_all$pop %in% c(dif_pop1, dif_pop2), ])[1],
T_edu_eq3 = donat(myt2_all[myt2_all$pop %in% c(dif_pop1, dif_pop2), ])[2],
T_tros_eq12 = donat(myt2_all[myt2_all$pop %in% c(mix_pop), ])[1],
T_edu_eq12 = donat(myt2_all[myt2_all$pop %in% c(mix_pop), ])[2])
summary_predict_observ <- merge(dd, summary_predict_observ, by = "Set")
summary_predict_observ$PT_05 <- with(summary_predict_observ, (T_tros_eq3 + T_edu_eq3)/2 )
summary_predict_observ
summary_predict_observ <- all_obs_predict_T_work %>% group_by(Set) %>% summarise(PT_mean = mean(PT), n_pop = length(pop),
n_out = sum(is.na(Ptros_Eq3_diff)),
Prop_out = round(n_out/n_pop*100, 1),
SS_eq3 = round(sum( ((Ptros_obs -Ptros_Eq3_diff)^2)/(n_pop - n_out), na.rm = T), 2),
SS_edu_eq2 = round(sum( ((P_ME_E_obs - P_ME_E_Eq2_diff_mix)^2)/(n_pop - n_out), na.rm = T), 2),
SS_tros_eq1 = round(sum( ((P_MT_T_obs - P_MT_T_Eq1_diff_mix)^2)/(n_pop - n_out), na.rm = T), 2)
)
summary_predict_observ$Set <- factor(summary_predict_observ$Set, levels = c("WBL", "BH", "GOM", "BALT", "NORW"))
summary_predict_observ$dif_pop1 <- c(pop_max_diff_BALT[1], pop_max_diff_BH[1], pop_max_diff_GOM[1], pop_max_diff_NORW[1], pop_max_diff_WBL[1])
summary_predict_observ$dif_pop2 <- c(pop_max_diff_BALT[2], pop_max_diff_BH[2], pop_max_diff_GOM[2], pop_max_diff_NORW[2], pop_max_diff_WBL[2])
summary_predict_observ$mix_pop <- c(pop_max_mix_BALT, pop_max_mix_BH, pop_max_mix_GOM, pop_max_mix_NORW, pop_max_mix_WBL)
summary_predict_observ$dif_pops <- paste(summary_predict_observ$dif_pop1, summary_predict_observ$dif_pop2)
dd <- summary_predict_observ %>% group_by(Set) %>%  summarise(T_tros_eq3 = donat(myt2_all[myt2_all$pop %in% c(dif_pop1, dif_pop2), ])[1],
T_edu_eq3 = donat(myt2_all[myt2_all$pop %in% c(dif_pop1, dif_pop2), ])[2],
T_tros_eq12 = donat(myt2_all[myt2_all$pop %in% c(mix_pop), ])[1],
T_edu_eq12 = donat(myt2_all[myt2_all$pop %in% c(mix_pop), ])[2])
summary_predict_observ <- merge(dd, summary_predict_observ, by = "Set")
# summary_predict_observ$PT_05 <- with(summary_predict_observ, (T_tros_eq3 + T_edu_eq3)/2 )
summary_predict_observ
str(summary_predict_observ)
Pl_Eq1_2_diff_mix_ME <-
ggplot(data = all_obs_predict_T_work %>% filter(N_edu > n_select) %>% filter((1-PT) > PT_minor ), aes(x = P_ME_E_obs, y = P_ME_E_Eq2_diff_mix, size = 1 - PT, shape = Set)) +
geom_point(fill = "blue") +
geom_abline()  + xlim(0,1) + ylim(0,1) +
facet_wrap(~Set, nrow = 1)  +
theme(strip.text = element_blank()) +
labs(x = "P(edu|E) observed", y = "P(edu|E) predicted by Eq2") +
scale_shape_manual(values = c(21, 22, 23, 24, 25)) +
scale_size_continuous(breaks = c(0.1, 0.5, 0.9), range = c(0.1, 3))
options(scipen = 10, digits=5)
all_obs_predict_T_work$Set <- factor(all_obs_predict_T_work$Set, levels = c("WBL", "BH", "GOM", "BALT", "NORW"))
Pl_Eq3 <- all_obs_predict_T_work %>%  ggplot(aes(x = Ptros_obs, shape = Set)) + geom_point(size = 3, fill = "black")  + theme(legend.position = "bottom")   + geom_abline() + scale_shape_manual(values = c(21, 22, 23, 24, 25))
Pl_Eq3_diff <- Pl_Eq3 + aes(y = Ptros_Eq3_diff) + guides(shape ="none", color = "none") + xlim(0,1) + ylim(0,1) + facet_wrap(~Set, nrow = 1) + labs(x = "Ptros observed", y = "Ptros predicted by Eq3")
Pl_Eq3_diff <- Pl_Eq3_diff + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 0.98, label = paste("MSS = ", SS_eq3, "\nLost pop = ", n_out )), size = 3)
# Количество генотипированных особей
n_select <- 0
# Порог для отсечения возможности предсказания. Эта величина появляется так как мы знаем, что для минорного генотипа предсказания маловероятны. То есть мы отбираем те пробы, в которых морфотип, соответствующий виду не будет минорным
PT_minor <- 0
PT_minor_plot <- 0.2
all_obs_predict_T_work$Minor_T <- with(all_obs_predict_T_work, ifelse( PT < PT_minor_plot,  1, 0))
all_obs_predict_T_work$Minor_E <- with(all_obs_predict_T_work, ifelse( (1 - PT) < PT_minor_plot,  1, 0))
Pl_Eq1_2_diff_mix_ME <-
ggplot(data = all_obs_predict_T_work %>% filter(N_edu > n_select) %>% filter((1-PT) > PT_minor ), aes(x = P_ME_E_obs, y = P_ME_E_Eq2_diff_mix, size = 1 - PT, shape = Set)) +
geom_point(fill = "blue") +
geom_abline()  + xlim(0,1) + ylim(0,1) +
facet_wrap(~Set, nrow = 1)  +
theme(strip.text = element_blank()) +
labs(x = "P(edu|E) observed", y = "P(edu|E) predicted by Eq2") +
scale_shape_manual(values = c(21, 22, 23, 24, 25)) +
scale_size_continuous(breaks = c(0.1, 0.5, 0.9), range = c(0.1, 3))
Pl_Eq1_2_diff_mix_ME <- Pl_Eq1_2_diff_mix_ME + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 1, label = paste("MSS = ", SS_edu_eq2 )), size = 3)
# + geom_point(data = all_obs_predict_T_work %>% filter( Minor_E == 1),  size = 1, shape = 21, color = "yellow", fill = "yellow")
Pl_Eq1_2_diff_mix_MT <-
ggplot(data = all_obs_predict_T_work %>% filter(N_tros > n_select) %>% filter(PT > PT_minor), aes(x = P_MT_T_obs, y = P_MT_T_Eq1_diff_mix, size = PT, shape = Set)) +
geom_point(fill = "red") +
geom_abline()  + xlim(0,1) + ylim(0,1) +
facet_wrap(~Set, nrow = 1) +
theme(strip.text = element_blank())+
labs(x = "P(tros|T) observed ", y = "P(tros|T) predicted by Eq1") +
scale_shape_manual(values = c(21, 22, 23, 24, 25)) +
scale_size_continuous(breaks = c(0.1, 0.5, 0.9), )
Pl_Eq1_2_diff_mix_MT <- Pl_Eq1_2_diff_mix_MT + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 1, label = paste("MSS = ", SS_tros_eq1 )), size = 3)
# + geom_point(data = all_obs_predict_T_work %>% filter( Minor_T == 1),  size = 1, shape = 21, color = "yellow" , fill = "yellow")
grid.arrange(Pl_Eq3_diff, Pl_Eq1_2_diff_mix_ME, Pl_Eq1_2_diff_mix_MT, nrow = 3)
options(scipen = 10, digits=5)
all_obs_predict_T_work$Set <- factor(all_obs_predict_T_work$Set, levels = c("WBL", "BH", "GOM", "BALT", "NORW"))
Pl_Eq3 <- all_obs_predict_T_work %>%  ggplot(aes(x = Ptros_obs, shape = Set)) + geom_point(size = 3, fill = "black")  + theme(legend.position = "bottom")   + geom_abline() + scale_shape_manual(values = c(21, 22, 23, 24, 25))
Pl_Eq3_diff <- Pl_Eq3 + aes(y = Ptros_Eq3_diff) + guides(shape ="none", color = "none") + xlim(0,1) + ylim(0,1) + facet_wrap(~Set, nrow = 1) + labs(x = "Ptros observed", y = "Ptros predicted by Eq3")
Pl_Eq3_diff <- Pl_Eq3_diff + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 0.98, label = paste("MSS = ", SS_eq3, "\nLost pop = ", n_out )), size = 3)
# Количество генотипированных особей
n_select <- 0
# Порог для отсечения возможности предсказания. Эта величина появляется так как мы знаем, что для минорного генотипа предсказания маловероятны. То есть мы отбираем те пробы, в которых морфотип, соответствующий виду не будет минорным
PT_minor <- 0
PT_minor_plot <- 0.2
all_obs_predict_T_work$Minor_T <- with(all_obs_predict_T_work, ifelse( PT < PT_minor_plot,  1, 0))
all_obs_predict_T_work$Minor_E <- with(all_obs_predict_T_work, ifelse( (1 - PT) < PT_minor_plot,  1, 0))
Pl_Eq1_2_diff_mix_ME <-
ggplot(data = all_obs_predict_T_work %>% filter(N_edu > n_select) %>% filter((1-PT) > PT_minor ), aes(x = P_ME_E_obs, y = P_ME_E_Eq2_diff_mix, size = 1 - PT, shape = Set)) +
geom_point(fill = "blue") +
geom_abline()  + xlim(0,1) + ylim(0,1) +
facet_wrap(~Set, nrow = 1)  +
theme(strip.text = element_blank()) +
labs(x = "P(edu|E) observed", y = "P(edu|E) predicted by Eq2") +
scale_shape_manual(values = c(21, 22, 23, 24, 25)) +
scale_size_continuous(breaks = c(0.1, 0.5, 0.9), range = c(0.1, 4))
Pl_Eq1_2_diff_mix_ME <- Pl_Eq1_2_diff_mix_ME + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 1, label = paste("MSS = ", SS_edu_eq2 )), size = 3)
# + geom_point(data = all_obs_predict_T_work %>% filter( Minor_E == 1),  size = 1, shape = 21, color = "yellow", fill = "yellow")
Pl_Eq1_2_diff_mix_MT <-
ggplot(data = all_obs_predict_T_work %>% filter(N_tros > n_select) %>% filter(PT > PT_minor), aes(x = P_MT_T_obs, y = P_MT_T_Eq1_diff_mix, size = PT, shape = Set)) +
geom_point(fill = "red") +
geom_abline()  + xlim(0,1) + ylim(0,1) +
facet_wrap(~Set, nrow = 1) +
theme(strip.text = element_blank())+
labs(x = "P(tros|T) observed ", y = "P(tros|T) predicted by Eq1") +
scale_shape_manual(values = c(21, 22, 23, 24, 25)) +
scale_size_continuous(breaks = c(0.1, 0.5, 0.9), range = c(0.1, 4) )
Pl_Eq1_2_diff_mix_MT <- Pl_Eq1_2_diff_mix_MT + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 1, label = paste("MSS = ", SS_tros_eq1 )), size = 3)
# + geom_point(data = all_obs_predict_T_work %>% filter( Minor_T == 1),  size = 1, shape = 21, color = "yellow" , fill = "yellow")
grid.arrange(Pl_Eq3_diff, Pl_Eq1_2_diff_mix_ME, Pl_Eq1_2_diff_mix_MT, nrow = 3)
options(scipen = 10, digits=5)
all_obs_predict_T_work$Set <- factor(all_obs_predict_T_work$Set, levels = c("WBL", "BH", "GOM", "BALT", "NORW"))
Pl_Eq3 <- all_obs_predict_T_work %>%  ggplot(aes(x = Ptros_obs, shape = Set)) + geom_point(size = 3, fill = "black")  + theme(legend.position = "bottom")   + geom_abline() + scale_shape_manual(values = c(21, 22, 23, 24, 25))
Pl_Eq3_diff <- Pl_Eq3 + aes(y = Ptros_Eq3_diff) + guides(shape ="none", color = "none") + xlim(0,1) + ylim(0,1) + facet_wrap(~Set, nrow = 1) + labs(x = "Ptros observed", y = "Ptros predicted by Eq3")
Pl_Eq3_diff <- Pl_Eq3_diff + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 0.98, label = paste("MSS = ", SS_eq3, "\nLost pop = ", n_out )), size = 3)
# Количество генотипированных особей
n_select <- 0
# Порог для отсечения возможности предсказания. Эта величина появляется так как мы знаем, что для минорного генотипа предсказания маловероятны. То есть мы отбираем те пробы, в которых морфотип, соответствующий виду не будет минорным
PT_minor <- 0
PT_minor_plot <- 0.2
all_obs_predict_T_work$Minor_T <- with(all_obs_predict_T_work, ifelse( PT < PT_minor_plot,  1, 0))
all_obs_predict_T_work$Minor_E <- with(all_obs_predict_T_work, ifelse( (1 - PT) < PT_minor_plot,  1, 0))
Pl_Eq1_2_diff_mix_ME <-
ggplot(data = all_obs_predict_T_work %>% filter(N_edu > n_select) %>% filter((1-PT) > PT_minor ), aes(x = P_ME_E_obs, y = P_ME_E_Eq2_diff_mix, size = 1 - PT, shape = Set)) +
geom_point(fill = "blue") +
geom_abline()  + xlim(0,1) + ylim(0,1) +
facet_wrap(~Set, nrow = 1)  +
theme(strip.text = element_blank()) +
labs(x = "P(edu|E) observed", y = "P(edu|E) predicted by Eq2") +
scale_shape_manual(values = c(21, 22, 23, 24, 25)) +
scale_size_continuous(breaks = c(0.1, 0.5, 0.9), range = c(0.1, 5))
Pl_Eq1_2_diff_mix_ME <- Pl_Eq1_2_diff_mix_ME + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 1, label = paste("MSS = ", SS_edu_eq2 )), size = 3)
# + geom_point(data = all_obs_predict_T_work %>% filter( Minor_E == 1),  size = 1, shape = 21, color = "yellow", fill = "yellow")
Pl_Eq1_2_diff_mix_MT <-
ggplot(data = all_obs_predict_T_work %>% filter(N_tros > n_select) %>% filter(PT > PT_minor), aes(x = P_MT_T_obs, y = P_MT_T_Eq1_diff_mix, size = PT, shape = Set)) +
geom_point(fill = "red") +
geom_abline()  + xlim(0,1) + ylim(0,1) +
facet_wrap(~Set, nrow = 1) +
theme(strip.text = element_blank())+
labs(x = "P(tros|T) observed ", y = "P(tros|T) predicted by Eq1") +
scale_shape_manual(values = c(21, 22, 23, 24, 25)) +
scale_size_continuous(breaks = c(0.1, 0.5, 0.9), range = c(0.1, 5) )
Pl_Eq1_2_diff_mix_MT <- Pl_Eq1_2_diff_mix_MT + geom_text(data = summary_predict_observ, aes(x = 0.2, y = 1, label = paste("MSS = ", SS_tros_eq1 )), size = 3)
# + geom_point(data = all_obs_predict_T_work %>% filter( Minor_T == 1),  size = 1, shape = 21, color = "yellow" , fill = "yellow")
grid.arrange(Pl_Eq3_diff, Pl_Eq1_2_diff_mix_ME, Pl_Eq1_2_diff_mix_MT, nrow = 3)
summary_predict_observ
summary_predict_observ %>% select(Set, T_tros_eq3, T_edu_eq3, T_tros_eq12, T_edu_eq12, mix_pop, dif_pops)
summary_predict_observ %>% select(Set, T_tros_eq3, T_edu_eq3, T_tros_eq12, T_edu_eq12,  dif_pops, mix_pop)
summary_predict_observ$E_edu_eq3 <- 1 - summary_predict_observ$T_edu_eq3
summary_predict_observ$E_edu_eq12 <- 1 - summary_predict_observ$T_edu_eq12
summary_predict_observ$E_edu_eq3 <- 1 - summary_predict_observ$T_edu_eq3
summary_predict_observ$E_edu_eq12 <- 1 - summary_predict_observ$T_edu_eq12
summary_predict_observ %>% select(Set, T_tros_eq3, E_edu_eq3, T_tros_eq12, E_edu_eq12,  dif_pops, mix_pop)
summary_predict_observ_print <- summary_predict_observ %>% select(Set, dif_pops, T_tros_eq3, E_edu_eq3, mix_pop, T_tros_eq12, E_edu_eq12   )
summary_predict_observ_print
kable(summary_predict_observ_print, col.names = c("Set", "Populations with different PT" , "P(T|tros)", "P(E|edu)", "Population with mean PT", "P'(T|tros)", "P(E|edu)"))
kable(summary_predict_observ_print, align = "lrccrcc" , col.names = c("Set", "Populations with different PT" , "P(T|tros)", "P(E|edu)", "Population with mean PT", "P'(T|tros)", "P(E|edu)"), caption = "Parameters of calibrating samples in each geographic region")
kable(summary_predict_observ_print, align = "lrccrcc", digits = 2 , col.names = c("Set", "Populations with different PT" , "P(T|tros)", "P(E|edu)", "Population with mean PT", "P'(T|tros)", "P(E|edu)"), caption = "Parameters of calibrating samples in each geographic region")
# Chunk 1: setup
library(knitr)
# library(flextable)
opts_chunk$set(echo = FALSE, cache = FALSE, fig.align ="center", warning = FALSE, message = FALSE)
# set pander table-layout options
library(pander)
panderOptions('table.alignment.default', function(df)
ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('table.split.table', Inf)
panderOptions('big.mark', ",")
panderOptions('keep.trailing.zeros', TRUE)
# Chunk 2
library(lme4)
library(ggplot2)
library(reshape2)
library(sjstats)
library(dplyr)
library(car)
library(doBy)
library(pROC)
library(betareg)
library(lmtest)
library(broom)
library(MuMIn)
library(gridExtra)
#### Data reading and initial preparation #####
myt <- read.table("data_salinity3.csv", header = T, sep = ",")
myt_overseas <- myt[myt$dataset == "overseas", ]
myt <- myt[myt$dataset != "overseas", ]
# str(myt)
myt$Sp [myt$str > 0.5] <- "M.trossulus" #Лучше обозначать так!
myt$Sp [myt$str <= 0.5] <- "M.edulis"
myt$Sp <- factor(myt$Sp)
# Оставляем только мидий, у которых есть оценка морфотипа
myt2 <- myt[!is.na(myt$ind), ]
# Вводим обозначения для морфотипов
myt2$morph <- ifelse(myt2$ind == 1, "T_m", "E_m")
myt2$morph <- factor(myt2$morph)
# Бинарное обозначение видов
myt2$Sp2 <- ifelse(myt2$Sp == "M.trossulus", 1, 0)
#Correct identification
myt2$congr <- ifelse((myt2$ind == 1 & myt2$Sp == "M.trossulus") | (myt2$ind == 0 & myt2$Sp == "M.edulis"), 1, 0   )
# Частота M.trossulus в популяции
freq_MT <- myt2 %>% group_by(pop) %>% summarise(freq_MT = mean(Sp2))
myt2 <- merge(myt2, freq_MT)
# Частота T-морфотипа в популяции
Prop_T <- myt2 %>% group_by(pop) %>% summarise(Prop_T = mean(ind))
myt2 <- merge(myt2, Prop_T)
# Подразделяем данные на три сабсета
myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "fresh"] <- "BL"
myt2$Subset[myt2$sea == "barents" & myt2$sal_place == "normal"] <- "BH"
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "normal"] <- "WS"
myt2$Subset[myt2$sea == "white" & myt2$sal_place == "fresh"] <- "WS"
myt2$Subset <- factor(myt2$Subset, levels = c("WS", "BL", "BH"))
#
#Оставляем только данные, на основе, которых строится модель
# myt3 <- myt2[myt2$dataset == "testing", ]
#
# myt2 <- myt2[myt2$dataset == "training", ]
# Извлекаем из беломорского материала тестовую выборку
#В формальную тестовую выборку  попадают точки наиболее близкие к 20%, 40%, 60% и 80% freq_MT
# selected_pop <- myt2[myt2$Subset == "W", ] %>% group_by(Subset, pop) %>% summarise(freq_MT = mean(freq_MT)) %>% group_by(Subset) %>% arrange(freq_MT, .by_group = TRUE) %>% mutate(dif_20 = (freq_MT - 0.2)^2, dif_40 = (freq_MT - 0.4)^2, dif_60 = (freq_MT - 0.6)^2, dif_80 = (freq_MT - 0.8)^2)  %>% group_by(Subset)  %>% summarize (n_pop =n(), q_20_pop = nth(pop, which.min(dif_20)), q_40_pop = nth(pop, which.min(dif_40)), q_60_pop = nth(pop, which.min(dif_60)), q_80_pop = nth(pop, which.min(dif_80)))
# selected_pop <- melt(selected_pop, id.vars = c("Subset", "n_pop"))$value
# myt4 <- myt2[myt2$pop %in% selected_pop, ] #новый testing dataset for the White sea
# myt3 <- rbind(myt3, myt4)
# myt2 <- myt2[!(myt2$pop %in% selected_pop), ] #новый modelling dataset
# Chunk 3
# Таблица с характеристиками тестинговых данных
# myt3_print <- myt3 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), Ptros = round(mean(Sp == "M.trossulus"), 2 ))
# myt3_print_out <- flextable(
#   myt3_print,
#   col_keys = c("Subset",	"Population",	"N_Tm_T",	"N_Em_T",	"N_Tm_E",	"N_Em_E",	"Ptros"))
# kable(myt3_print)
# myt3_print_out
# Таблица с характеристиками моделлинговых данных
myt2_print <- myt2 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), Ptros = round(mean(Sp == "M.trossulus"), 2 ))
myt2_print
# Таблица с характеристиками моделлинговых данных
myt2_print <- myt2 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), N_edu = sum(Sp == "M.edulis"), N_tros = = sum(Sp == "M.trossulus"),   Ptros = round(mean(Sp == "M.trossulus"), 2 ))
# Таблица с характеристиками моделлинговых данных
myt2_print <- myt2 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), N_edu = sum(Sp == "M.edulis"), N_tros = sum(Sp == "M.trossulus"),   Ptros = round(mean(Sp == "M.trossulus"), 2 ))
myt2_print
# Таблица с характеристиками моделлинговых данных
myt2_print <- myt2 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), N_edu = sum(Sp == "M.edulis"), N_tros = sum(Sp == "M.trossulus"),   Ptros = round(mean(Sp == "M.trossulus"), 2 ), PT = round(mean(morph == "T_m"), 2 ))
myt2_print
# Таблица с характеристиками моделлинговых данных
myt2_print <- myt2 %>% group_by(Subset, pop) %>% summarise(N_Tm_T = sum(morph == "T_m" & Sp == "M.trossulus"), N_Em_T = sum(morph == "E_m" & Sp == "M.trossulus"), N_Tm_E = sum(morph == "T_m" & Sp == "M.edulis"), N_Em_E = sum(morph == "E_m" & Sp == "M.edulis"), N_edu = sum(Sp == "M.edulis"), N_tros = sum(Sp == "M.trossulus"), N_total = N_edu + N_tros,   Ptros = round(mean(Sp == "M.trossulus"), 2 ), PT = round(mean(morph == "T_m"), 2 ))
myt2_print
View(myt2_print)
