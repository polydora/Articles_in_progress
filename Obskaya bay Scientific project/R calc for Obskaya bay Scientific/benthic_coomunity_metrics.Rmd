---
title: "Метрики биоразнообразия донных сообществ в условиях изменений экологической лицензии"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = FALSE, message = F, warning = F)

```

<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }
td {  /* Table  */
  font-size: 14px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>





```{r}
library(readxl)
library(ggplot2)
library(dplyr)
library(lubridate)

library(ggmap)
library(mapproj)
library(maps)

library(rgeos) 

library(mapdata)
library(maptools) # Rgshhs
library(PBSmapping)
library(cowplot)
library(mgcv)
library(ggrepel)
library(png)
library(broom)



theme_set(theme_bw())

# данные по солености из модели


salmod <- read_excel("data/Bottom_salinity_from_model.xls")


salmod <- salmod %>% select(Long, Lat, Depth, Month, Constructed, No) %>% mutate_if(is.character, as.numeric) %>% mutate(Station = salmod$Station, Date = salmod$Date) %>% select(Station, Date, Month, Long, Lat, Depth, Constructed, No)


# Средняя соленость для каждого месяца

salmod_mean <- salmod  %>% group_by(Station, Month) %>% summarise(Depth = mean(Depth), Lat = mean(Lat), Long = mean(Long), Sal_Constructed = mean(Constructed), Sal_No = mean(No), Dif = mean(Constructed - No) ) 

salmod_mean2 <- salmod  %>% group_by(Station) %>% summarise(Depth = mean(Depth), Lat = mean(Lat), Long = mean(Long), Sal_Constructed = mean(Constructed), Sal_No = mean(No), Dif = mean(Constructed - No) ) 
 



# Источники антропогенного воздействия

ports <- data.frame(Name = c("Sabetta", "Terminal"), Lat = c(71.235220, 71.010886), Long = c(72.126754, 73.793525))





#The function for calculation of neares object and distance to it  

nearest_dist <- function(XY, objects = ports, x.name = "Long", y.name = "Lat"){
  XY1 <-as.numeric(XY[,1])
  XY2 <- as.numeric(XY[,2])
  dist <- (acos(sin(XY1*pi/180)*sin(objects[ ,y.name]*pi/180) + cos(XY1*pi/180)*cos(objects[ ,y.name]*pi/180)*cos(XY2*pi/180 - objects[ ,x.name]*pi/180)) * 6371)
  
  MD <- data.frame(Min_dist = min(dist))
  cbind(objects[which(dist == min(dist)), ], MD)
  
}


df_ports <- nearest_dist(XY = salmod_mean[1, c("Lat", "Long")], objects = ports)

for(i in 2:nrow(salmod_mean)) {
  df_ports[i, ] <- nearest_dist(XY = salmod_mean[i, c("Lat", "Long")], objects = ports)
}


salmod_mean$Nearest_Port <- df_ports$Name
salmod_mean$Min_dist <- df_ports$Min_dist

```




```{r}
bent <- read_excel("Data/Obskaya_bay_2020.xlsx", sheet = "Benthos")


bent_B <- bent %>% filter(Type == "Biomass") %>% select(-Type)

bent_N <- bent %>% filter(Type == "Abundance") %>% select(-Type)


Spec_abund <- bent_N %>% select(-Station) %>% colSums(.) %>% t() %>% as.vector() 

spec_total_abund <- data.frame(Sp = bent_N %>% select(-Station) %>% colnames(), Spec_abund)

N_porog <- 0 

spec_selected <- spec_total_abund %>% filter(Spec_abund > N_porog)

bent_short <- bent_N %>% select(Station, spec_selected$Sp)


bent_short <-
  bent_short %>% mutate(Oligochaeta = Oligochaeta_gen._sp. + Oligochaeta_gen._spp.) %>% 
  select(-c(Oligochaeta_gen._sp., Oligochaeta_gen._spp., Oligochaeta_gen._sp._cocons,Senecella_siberica) )



stations <- read_excel("Data/Obskaya_bay_2020.xlsx", sheet = "Station parameters", na = "NA")

# Stations with biological samples
stat_full <- stations %>% filter(Exclude == 0)

stat_full <- as.data.frame(stat_full)





### Данные для модели ######


# Убираем станции с отсутствующими оценками солености

salmod_mean2 <- salmod_mean2 %>% filter(!is.na(salmod_mean2$Sal_No))

bent_short <- bent_short %>% filter(Station %in% salmod_mean2$Station)


bent_short <- bent_short %>% select(-Station)

bent_short <- bent_short[, colSums(bent_short) > 0]


stat_full <- stat_full %>% filter(Station %in% salmod_mean2$Station)




salmod_mean2 <- salmod_mean2  %>% filter(!is.na(salmod_mean2$Sal_No)) 


n <- nrow(bent_short) # Число станций 
ns <- ncol(bent_short)-1 #Число видов




xycoords <- salmod_mean2 %>% select(Station, Long, Lat) %>% select(-Station) %>% as.matrix(.)

colnames(xycoords) = c("x-coordinate","y-coordinate")
rownames(xycoords) = 1:n




Ydata <- bent_short  %>% round(., 0) %>% as.matrix(.)
colnames(Ydata) <- names(bent_short)
rownames(Ydata) = 1:n

Ydata <- log(Ydata + 1)

# Ydata <- sqrt(Ydata)


Xdata_No <- salmod_mean2 %>% select(Sal_No, Depth) 

colnames(Xdata_No) <- c("Sal", "Depth")


Xdata_Constructed <- salmod_mean2 %>% select(Sal_Constructed, Depth)

colnames(Xdata_Constructed) <- c("Sal", "Depth", "Dist")


Xdata_initial <- stat_full %>% mutate (Sal = (Bottom_Salinity_Aug_20), Depth = (Depth_aug_20 + Depth_sep_20)/2 ) %>% select(Sal, Depth) 

colnames(Xdata_initial) <- c("Sal", "Depth")


```




## Постановка проблемы

Для проведения мониторинга сообществ необходимо разработать метрики, отражающие изменение биоразнообразия. Предполагается, что в основе заключений будут лежать повторяющиеся с определенной периодичностью описания сообществ (мониторинг). В случае с бентосными сообществами - взятие количественных проб на некоторой стандартной сети станций. Необходимо разработать  подходы к оценке изменений, которые давали бы информацию об изменениях минимально зависящую от статистического шума, связанного с неучтенными исследователями факторами. 

Самый очевидный подход заключается в сравнении "сырых" данных, полученных в один из сезонов, с данными, полученными в другой сезон наблюдения. Этот подход прост и позволяет быстро выявить изменения в каких-то комплексных параметрах, например, в общей биомассе сообщества (далее такие метрики будем обозначать, как **Метрики 1 типа**). Однако такой подход имеет ряд недостатков. Во-первых, даже при очень высокой точности позиционирования станций, разброс их расположения может достигать нескольких метров. Это потенциально может привести к тому, что новое описание будет отличаться от предыдущего вследствие пространственных, а не временных, отличий сообществ в двух точках взятия проб. Пространственные различия будут приняты за временные. Во-вторых, сообщество может быть, в целом, устойчиво, но демонстрировать флуктуации с частотой меньше периода мониторинга. При проведении переописания сообществ отбор проб может попасть в иную фазу, нежели предыдущее описание. В итоге различия между двумя выборками могут быть трактованы как следствие какого-то антропогенного воздействия, которого на самом деле не было. Этот механизм появления ложноположительных результатов может работать не только в отношении сообщества, но и в отношении абиотических параметров. Например, соленость может, в целом, закономерно изменяться в пространстве, формируя стабильный градиент. Однако в результате нагонных ветров, приливно-отливных циклов и т.п. соленость, измеренная в один период мониторинга может отличаться от солености, измеренной в другой период наблюдений.


В связи с этим, более перспективным видится иной подход. Кратко его суть сводится к тому, чтобы проведя отбор проб в год $t$, получить модель, описывающую связь каких-то показателей сообщества  с параметрами биотопа. Показатели сообщества могут быть как одномерные (общая численность, общая биомасса, индексы видового разнообразия), так и многомерные (матрица обилий отдельных видов). Параметры биотопа представлены в виде градиентов условий среды, в которых формируется сообщество. Такие градиенты принято называть экологической лицензией. Модель, описывающая связь сообщества с лицензией, будет предсказывать некоторую ожидаемую структуру сообщества в рамках данной лицензии. При повторном наблюдении в год $t+1$ такая модель должна быть построена вновь. При сравнении сообществ, описанных в год $t$ и $t+1$, сравниваться должны предсказания двух моделей. Статистическая значимость различий будет оцениваться на основе оценки соотношений предсказанных моделями величин и величины остатков. На практике для вынесения суждения об изменениях в сообществах будет строится не две независимые модели, а одна, в которой будет рассматриваться связь биотического показателя с парамтерами среды и в качестве дискретного предиктора будет включен период сбора материала. В простейшем случае, когда анализируемая величина представлена одномерным вектором значений а из всех параметров среды рассматривается только один фактор, анализ сводится к построению стандартной общей линейной модели (general linear model). В этой модели непрерывным предиктором выступает фактор среды, а дискретным предиктором - период сбора ($t$ vs $t+1$). Такие метрики далее будем обозначать, как **Метрики 2 типа**.  


Любое воздействие (антропогенное, климатическое и т.п.), если оно достаточно мощное, приводит изменению экологической лицензии биотопа. В результате изменения экологической лицензии происходит изменение и структуры сообщества, которое проявляется не только в изменении обилия популяций отдельных видов в соответствии с их экофизиологическими реакциями на факторы среды, но и в изменении характера взаимоотношений между членами сообществ. Последнее тоже может привести к существенным изменениям обилия популяций отдельных видов из-за повышения/снижения межвидовой конкуренции или повышения/понижения интенсивности трофических связей. Указанное обстоятельство заставляет моделировать поведение сообщества целиком, как изменение некоторой многомерной функции в ответ на изменение лицензии. Для построения подобных моделей адаптирована концепция  Joint Species Distribution Modelling (JSDM). Метрики, основанные на таком подходе будем обозначать, как **Метрики 3 типа**.

## Метрики 1 типа
Для оценки изменений, сообщество "редуцируется" до некоторой одномерной величины, которая может быть оценена в каждой пробе. Наиболее очевидные показатели: суммарная биомасса бентоса ($B_{total}$), суммарная численность всех организмов ($N_{total}$) или один из индексов видового разнообразия (Diversity index). В качестве поcледнего наиболее удобен индекс Шеннона:

$$
H = -\sum{\frac{N_i}{N_{total}}log_2(\frac{N_i}{N_{total}})}
$$

Любой их этих показателей может быть получен для каждой пробы. Далее эти показатели усредняются для $t$ и $t+1$. Различия средних могут быть выражены в процентах от начльного состояния. Если есть необходимость статистических сравнений, то они могут быть проведены с помощью t-критерия Стьюдента. 

## Метрики 2 типа
Для этих метрик сообщество также должно быть редуцировано до тех же обобщенных величин, что и в предыдущем случае. Однако для применения этого подхода пробы должны быть взяты, в некотором градиенте среды, который характеризует экологическую лицензию. Например, в случае Обской губы очевидным фактором должен быть градиент солености. То есть, при планировании мониторинга станции должны быть расположены так, чтобы они попадали и в разные участки градиента солености, которая закономерно увеличивается с юга на север. Чем больше предикторов будет включено в модель, тем точнее будет оценка изменений при сравнении периодов $t$ и $t+1$. 

**NB** *В связи с тем, что одним из потенциальных факторов, приводящих к изменениям могут быть антропогенные влияния (суть которых предсказать невозможно) важным предиктором в такой модели может быть расстояние до ближайшего источника потенциального влияния (например до порта "Сабетта" или терминала "Утренний"). При этом важно, чтобы указанный  предиктор на был коллинеарен другим предикторам, включенным в  модель (например, солености). Для этого сеть мониторинговых станций должна быть организована так, чтобы варьирование расстояния до ближайшего участка антропогенного воздействия не совпадало с варьированием другого фактора (например солености).* 

Для оценки величины изменений в период $t+1$ по сравнению с периодом $t$ необходимо будет вычислить предсказанные моделью величины для каждой из станций в оба периода. Далее можно оценить степень различий на каждой из станций  или в среднем на всем массиве данных. Эти различия могут быть выражены в процентах по отношению к начальному периоду наблюдений.       

Если есть необходимость статистических сравнений, то они могут быть проведены с помощью стандартной процедуры ANCOVA. Графическим отражением модели могут быть линии регрессии, отражающие связи изучаемой характеристики с параметрами среды, включенными в модель. Если изменения в $t+1$ по сравнению с $t$ несущественны, то линии регрессии должны совпасть. 


Продемонстрируем предложенный подход, используя имеющихся массив данных по оценке обилия бентосных организмов (данные по Обской губе, съемка +++ года). В качестве комплексной характеристики сообщества в каждой пробе используем величину индекса Шеннона. Поскольку второй бентосной съемки не было, то для сравнения симулируем искусственный датасет, который отличается от исходного тем, что к каждому показателю обилия того или иного вида была добавлена случайная величина из нормального распределения с параметрами $\mu = 0$ и $\sigma = SD_j$, где $SD_j$ - стандартное отклонение обилий вида $j$.      


```{r}
library(vegan)

set.seed(123456)

bent_short <- as.data.frame(bent_short)

bent_short2 <- as.data.frame(bent_short)


for(j in 1:ncol(bent_short)){
bent_short2 [,j] <- bent_short [,j] + rnorm(n = nrow(bent_short), mean = 0, sd = sd(bent_short[,j]))
  
}


bent_short2[bent_short2<0] <- 0
bent_short2 <- round(bent_short2)

df <- data.frame(Period = c(rep("t1", nrow(bent_short)), rep("t2", nrow(bent_short))), 
                 Salinity = c(Xdata_initial$Sal, (Xdata_initial$Sal) ),
                 H = c(diversity(bent_short), diversity(bent_short2)))


Model <- lm(H ~ Salinity*Period, data = df)

Model_summary <- tidy(Model)

mydata_t1 <- data.frame(Salinity = Xdata_initial$Sal, Period = "t1")

predicted_t1 <- predict(Model, newdata = mydata_t1)


mydata_t2 <- data.frame(Salinity = Xdata_initial$Sal, Period = "t2")

predicted_t2 <- predict(Model, newdata = mydata_t2)

```


```{r}
ggplot(df, aes(x = Salinity, y = H, color = Period)) + geom_point() + geom_smooth(method = "lm") 
```

В данном случае характер связи с параметрами среды не изменился, а видовое разнообразие в период 2 возросло и  отличается от видового разнообразия в период 1, в среднем, на `r round(abs(mean((predicted_t1 - predicted_t2)/predicted_t1)*100),1)` %.  






## Метрики 3 типа

### Теоретические посылки
В теоретической экологии сообщество предстает в виде системы реализованных экологических ниш, упакованных в рамках лицензии. Характер связи вида с параметрами среды (экологическая ниша) может быть описан коэффициентами регрессионной модели, устанавливающей связь обилия вида со значениями факторов среды. В простейшем случае, когда рассматривается один фактор среды и один вид, обилие которого линейно связано с данным фактором, ниша данного вида может быть охарактеризована значениями коэффициентов следующей модели:

$$
N = b_0 + b_1F + \varepsilon
$$

$b_0$, или intercept, характеризует общий уровень обилия вида;
$b_1$, или slope, характеризует связь обилия вида с фактором (F);
$\varepsilon$ - неучтенные моделью отклонения (остатки).

В более сложных вариантах модель может включать большее число коэффициентов. 

Стало быть для характеристики реализованной ниши отдельного вида в рамках экологической лицензии необходимо указать значения коэффициентов $b_0$ и $b_1$. Графическим выражением этой связи будет являться линия регрессии, построенные для каждого вида. 

Представим себе, что коэффициенты  $b_0$ и $b_1$ были оценены в год $T_1$, когда экологическая лицензия данного биотопа, характеризовалась диапазоном единственного фактора  $DF_1$. Если в год $T_2$  значения фактора изменились (например увеличились), то лицензия в данный год будет отражаться величиной $DF_2$. Если при этом коэффициенты $b_0$ и $b_1$ не изменились, то есть характер связи единственного вида с единственным фактором, остался прежним, то это означает, что значительных изменений в отношении данного вида с его биотопом не произошло. Если же значения коэффициентов существенно изменились, то мы можем констатировать существенное влияние этих изменений на реализованную экологическую нишу вида.  Графически это изменение может быть выражено в виде двух регрессионных прямых. При первом сценарии эти прямые совпадают, при втором - нет. 

Такая трактовка экологической ниши (набор коэффициентов регрессионных моделей) позволяет формализовать процедуру прогноза изменений при изменении экологической лицензии (то есть при некоторых воздействиях, повлекших изменение значений фактора $F$). Если реализованная ниша вида не изменяется, то прогноз строится простой экстраполяцией имеющейся модели на новые значения фактора. Качество прогноза зависит только от качества оценок.  Если же коэффициенты меняются, то прогнозы возможны только если мы знаем (или задаем) правило, по которому происходит это изменение. 


Если мы рассматриваем не один вид, а все сообщество целиком, то в рамках концепции JSDM подбор коэффициентов, описывающих реализованные ниши, осуществляется не для каждого вида в отдельности (как серия независимых линейных моделей), а с учетом связей между видами (матрица корреляций) и учетом дизайна сбора материала (наличие случайных группирующих факторов и/или факторов, порождающих пространственные или временные автокорреляции). Потенциально в рамках JSDM можно учесть и филогенетические и функциональные характеристики видов. Однако логика анализа будет более или менее сходной с той, что описана выше для случая одного вида и одного фактора. 

Моделирование связи всего сообщества в целом с факторами лицензии дает еще более гибкий инструмент для оценки влияния тех или иных воздействий на сообщество. Принципиально схема анализа будет такой же, как при работе с метриками 2 типа:

1. Мы строим модель, описывающую связь всего сообщества с ключевыми факторами среды, в модель должен быть фактор "Период".     
2. Получаем предсказания модели для каждого из двух периодов. Программы, позволяющие строить JSDM, позволяют сформировать матрицу предсказанных обилий видов.    
3. Оцениваем различия двух предсказаний. При этом матрицы предсказанных обилий видов можно свернуть в комплексные показатели, например в индекс Шеннона.       


Моделирование с помощью JSDM  дает и еще один инструмент. Этот подход позволят дать оценки изменениям в структуре сообществ, ожидаемым при разных сценариях преобразования биотопа. Например, при проведении гидротехнических мероприятий, которые известным образом изменят условия существования сообществ. Продемонстрируем возможности JSDM для оценки изменений, которые могли быть вызваны в бентосных сообществах Обской губы.   




## Моделирование изменений в Обской губе 

Структура бентосных сообществ Обской губы находится в зависимости от множества факторов (см. отчет +++). Потенциально, изменение любого из них может привести к существенным изменения в структуре сообществ. Однако самым важным градиентом, определяющим варьирование структуры сообществ в этом регионе,    является соленость. Согласно гидрологической модели акватории (INMOM), соленость закономерно варьирует вдоль оси Обской губы. При этом, модель INMOM была рассчитана для двух режимов: нативный (Native), то есть без внесения в рельеф дна изменений, и режим, связанный с дноуглубительными работами (Constricted). 


Согласно этой модели, при сценарии "Constructed" паттерн распределения солености может несколько отличаться от паттерна  в режиме "Native". Если для каждой стандартной станции, на которой проводился отбор бентосных проб, произвести вычисления ожидаемой солености при двух сценариях, то величина отклонения значения солености при режиме "Constructed" от солености в режиме "Native" будет характеризовать степень воздействия гидротехнических работ на соленостный режим в данной географической точке. Введем величину $Dif$

$$
Dif = S_{Constructed} - S_{Native}
$$

Положительное значение будет означать рост солености при проведении гидротехнических работ, отрицательное значение - падение солености.   

Cущественных изменений значений солености не ожидается (Fig. +++). Модальное значение различия солености между двумя сценариями близко к нулю.

```{r}
ggplot(salmod_mean, aes(x = Dif)) + 
  geom_histogram()+
  labs(x = "Difference in salinity for two scenaries (Dif)")
```

Вместе с тем, эти различия демонстрируют некоторый пространственный паттерн. Если оценить расстояние от каждой станции до ближайшего крупного берегового сооружения (порт "Сабетта" или терминал "Утренний"), то можно заметить (Fig. ++), что после проведения гидротехнических работ соленость в большинстве локаций, приближенных к портам, возрастет, а в участках, удаленных от портов, она может как возрасти, так и снизиться.  



```{r}
# ЗАвисимость различий в солености при разных сценариях от расстояния до ближайшего порта
ggplot(salmod_mean, aes(x = Min_dist, y = Dif)) + 
  geom_point() + 
  geom_hline(yintercept = 0) +
  labs(x = "Distance to the nearest port", y = "Dif")


```


Максимальное повышение солености при сценарии "Constructed" по сравнению с соленостью при сценарии "Native" будет наблюдаться в восточой части устья Обской губы. В западной части устья изменения будут минимальны или даже может произойти некоторое опреснение.  

```{r}



# Рисуем карту распределения изменений солености ################

Ob_df <- read.csv("Data/Obskaya_bay_map.csv") # Map poligones


# Coordinate limites 
# Ob_x <- c(71, 79)

Ob_x <- c(71, 75.2)
Ob_y <- c(70, 73.2)



# Sabetta
Sabetta_y <- 71.235220
Sabetta_x <- 72.126754

# Terminal

Terminal_y <- 71.010886
Terminal_x <- 73.793525


Pl_Obskaya_bay <- 
  ggplot(Ob_df, aes(x=long, y=lat, group=group)) +
  geom_polygon(fill = "gray90", colour = "gray20") + 
  coord_map(xlim = Ob_x, ylim = Ob_y) + 
  theme_bw() +  
  theme(axis.title.x = element_blank(),  axis.title.y = element_blank(), plot.background = element_blank(), panel.border = element_blank(), panel.grid = element_blank()) + 
  theme(axis.text.x =element_blank(), axis.text.y= element_blank()) + 
  theme(axis.ticks = element_blank()) +
  geom_point(aes(x = Sabetta_x, y = Sabetta_y), size = 3, shape = 21, fill = "red") + 
  geom_point(aes(x = Terminal_x, y = Terminal_y), size = 3, shape = 22, fill = "yellow") 




my_data <- expand.grid(Lat = seq(from = Ob_y[1], to = 72.8 , length.out = 100), Long =  seq(from = Ob_x[1], to =Ob_x[2] , length.out = 100))

salmod_mean2 <- salmod_mean %>% group_by(Station) %>% summarise_all(.funs = mean)

Mod_Dif <- gam(Dif  ~ s(Long, Lat), data = salmod_mean2)

my_data$Dif_predicted <- predict(Mod_Dif, newdata = my_data)

ggplot(my_data, aes(x = Long, y = Lat)) + 
  geom_tile(aes(fill = Dif_predicted)) +
  geom_polygon(data = Ob_df, aes(x=long, y=lat, group=group), fill = "gray90", colour = "gray20") +
  scale_fill_gradient(low = "white", high = "red") +
  geom_point(data = salmod_mean2) +
  labs(fill = "Salinity changes")



```





Продемонстрируем подход, основанный на JSDM, для ответа на вопрос какие изменения структуре сообществ ожидаются при сценарии "Constructed" по сравнению со сценарием "Native". Эти два сценария подразумевают некоторые изменения экологической лицензии акватории. Суть изменений описана выше. 

Для анализа нам необходимо смоделировать поведение сообщества в отношении одного единственного фактора - солености. К сожалению, в нашем распоряжении есть только одно описание сообщества, сделанное в +++ году. Полученные данные позволяют смоделировать связь сообщества с соленостью, которую наблюдали во время взятия проб. 
Эту связь правильнее описывать не линейными функциями (см. выше), а полиномами второй степени. Это позволит более реалистично описывать связь с соленостью в соответствии общеэкологическими представлениями о куполе толерантности. Таким образом, экологическая ниша каждого вида будет характеризоваться не двумя коэффициентами, как было описано выше, а тремя, в соответствии со следующей формулой: 

$$
ln(N) = b_0 + b_1S + b_2S^2 + \varepsilon
$$

Для построения модели в качестве показателя обилия будет использован логарифм от плотности поселения вида, $ln(N) + 1$, (это необходимо для построения модели, основанной на нормальном распределении). Подбор коэффициентов модели осуществлялся с помощью пакета "Hmsc" (Tikhonov, Ovaskainen, Oksanen, 2021). 


Если рассматривать данную модель в качестве точки отсчета, то можно рассчитать "ожидаемое сообщество" при двух сценариях. 

```{r}

library(Hmsc)


load("m.spatial.RData") # Загрузка модели, где предиктором является соленость из модели без строительства конструкций

load("m.spatial_constructed.RData") # Загрузка модели, где предиктором является соленость из модели после строительства конструкций

load("m.spatial_initial.RData") # Загрузка модели, где предиктором является изначально измеренная соленость 









Preds.spatial_Init = computePredictedValues(m.spatial_initial)

Predicted_Init <- apply(Preds.spatial_Init, c(1,2), mean)

Predicted_Init <- round(exp(Predicted_Init)-1, 0)

Predicted_Init <- as.data.frame(Predicted_Init)
Predicted_Init$Type <- "Init"


# Новые значения для предсказания для сценария, когда есть конструкции 
X_new <- as.matrix(data.frame(intercept = 1, Sal = Xdata_Constructed$Sal, Sal2 = Xdata_Constructed$Sal^2))

Predicted_Constr <- predict(m.spatial_initial, X = X_new)


Predicted_Constr_mean <- Reduce("+", Predicted_Constr) / length(Predicted_Constr)

Predicted_Constr_mean <- round(exp(Predicted_Constr_mean) -1, 0)
Predicted_Constr_mean <- as.data.frame(Predicted_Constr_mean)

Predicted_Constr_mean$Type <- "Constructed"




# Новые значения для предсказания для сценария, когда нет конструкций 
X_new <- as.matrix(data.frame(intercept = 1, Sal = Xdata_No$Sal, Sal2 = Xdata_No$Sal^2))

Predicted_No <- predict(m.spatial_initial, X = X_new)


Predicted_No_mean <- Reduce("+", Predicted_No) / length(Predicted_No)

Predicted_No_mean <- round(exp(Predicted_No_mean) -1, 0)

Predicted_No_mean <- as.data.frame(Predicted_No_mean)

Predicted_No_mean$Type <- "No"





All_Predicted <- rbind(Predicted_No_mean, Predicted_Constr_mean, Predicted_Init)


All_Predicted[All_Predicted<0] <- 0




library(vegan)
library(dplyr)
library(ggplot2)



H_init <- diversity(Predicted_Init[,-ncol(Predicted_Init)])

H_No <- diversity(Predicted_No_mean[,-ncol(Predicted_No_mean)])

H_Constructed <- diversity(Predicted_Constr_mean[,-ncol(Predicted_Constr_mean)])

# 
# mean((H_No - H_Constructed)/H_No *100)

```



Если теперь описать сообщества, предсказанные для двух сценариев, с помощью индекса Шеннона, то можно для каждой станции оценить возросло или упало видовое разнообразие. Для этого введем величину $Dif_H$, которая показывает на сколько процентов отличается индекс Шеннона в данной станции при сценарии "Constructed" от аналогичного индекса при сценарии "Native". 

$$
Dif_H = \frac{H_{Constructed} - H_{Native}}{H_{Native}}\cdot 100 \%
$$

Положительное значение  $Dif_H$ говорит о повышении разнообразия, отрицательное -  о его понижении.В среднем по всей акватории видовое разнообразие при разных сценариях изменяется незначительно, на `r round(mean((H_Constructed - H_No)/H_No *100), 4)`%. То есть строительство гидросооружений приводит к небольшому повышению видового разнообразия. Более детальную картину дает анализ пространственного распределения величины $Dif_H$.

```{r}


my_data <- expand.grid(Lat = seq(from = Ob_y[1], to = 72.8 , length.out = 100), Long =  seq(from = Ob_x[1], to =Ob_x[2] , length.out = 100))

stat_H <- stat_full %>% select(Station, Long, Lat, Bottom_Salinity_Aug_20 ) %>% mutate(Salinity = Bottom_Salinity_Aug_20, H_Native = H_No, H_Constructed = H_Constructed, Dif_H = (H_Constructed - H_No)/H_No*100 )




Mod_Dif_H <- gam(Dif_H  ~ s(Long, Lat), data = stat_H)

my_data$Dif_predicted <- predict(Mod_Dif_H, newdata = my_data)

ggplot(my_data, aes(x = Long, y = Lat)) + 
  geom_tile(aes(fill = Dif_predicted)) +
  geom_polygon(data = Ob_df, aes(x=long, y=lat, group=group), fill = "gray90", colour = "gray20") +
  scale_fill_gradient(low = "yellow", high = "blue") +
  geom_point(data = salmod_mean2) +
  geom_point(aes(x = Sabetta_x, y = Sabetta_y), size = 3, shape = 21, fill = "red") + 
  geom_point(aes(x = Terminal_x, y = Terminal_y), size = 3, shape = 22, fill = "yellow")+ 
  labs(fill = "Diversity changes (%)")

```


Видно, что наиболее сильное изменение разнообразия прогнозируется в южной, самой опресненной, части акватории. Здесь при реализации сценария "Constructed" видовое разнообразие вырастет по сравнению с таковым при сценарии "Native".  Морская часть акватории при проведении гидротехнических работ испытает меньшие изменения.    



```{r}
df2 <- data.frame(H = diversity(bent_short), Sal = Xdata_initial$Sal)

Mod_H_init <- lm(H ~ Sal, data = df2)

mydata_No <- data.frame(Sal = Xdata_No$Sal)
mydata_Constructed <- data.frame(Sal = Xdata_Constructed$Sal)

H_predicted_No <- predict(Mod_H_init, newdata = mydata_No)
H_predicted_Constructed <- predict(Mod_H_init, newdata = mydata_Constructed)

Dif_H <- (H_predicted_Constructed - H_predicted_No)/H_predicted_No*100


stat_H2 <- stat_full %>% select(Station, Long, Lat, Bottom_Salinity_Aug_20 ) %>% mutate(Salinity = Bottom_Salinity_Aug_20, H_Native = H_predicted_No, H_Constructed = H_predicted_Constructed, Dif_H = Dif_H )



Mod_Dif_H2 <- gam(Dif_H  ~ s(Long, Lat), data = stat_H2)

my_data$Dif_predicted2 <- predict(Mod_Dif_H2, newdata = my_data)




```





Если для решения этой задачи вместо метрики 3 типа применить метрику 2 типа, то результат будет существенно иным. В среднем, различие в видовом разнообразии для двух сценариев, если применить метрику 2 типа,  составляет `r round(mean(Dif_H),4)`%, что почти в два раза меньше, чем при применении метрик 3 типа (см. выше). Кроме того, пространственный паттерн различий между двумя сценариями отличается от того, который был получен при  использовании метрики 3 типа. Выявленный паттерн не согласуется с характером различий солености при реализации двух сценариев. 

```{r}
ggplot(my_data, aes(x = Long, y = Lat)) + 
  geom_tile(aes(fill = Dif_predicted2)) +
  geom_polygon(data = Ob_df, aes(x=long, y=lat, group=group), fill = "gray90", colour = "gray20") +
  scale_fill_gradient(low = "yellow", high = "blue") +
  geom_point(data = salmod_mean2) +
  geom_point(aes(x = Sabetta_x, y = Sabetta_y), size = 3, shape = 21, fill = "red") + 
  geom_point(aes(x = Terminal_x, y = Terminal_y), size = 3, shape = 22, fill = "yellow")+ 
  labs(fill = "Diversity changes (%)")

```




<!-- Ход анализа был следующим.   -->


<!-- 1. Используя подход JSDM, мы построили три модели, описывающую связь видов сообщества бентоса с соленостью (Benthos Salinity Model, BSM).  -->
<!-- - Модель BSM1 опиcывала связь бентоса с соленостью, измеренной при взятии проб. -->
<!-- - Модель BSM2 опиcывала связь бентоса с соленостью, предсказанной гидрологической моделью INMOM, которая наблюдалась бы на точках взятия проб при условии отсутствия гидротехнических работ -->
<!-- - Модель BSM3 опиcывала связь бентоса с соленостью, предсказанной гидрологической моделью INMOM, которая наблюдалась бы на точках взятия проб при условии проведения гидротехнических работ. -->





<!-- Эту связь удобнее описывать не линейными функциями (см. выше), а полиномами второй степени. Это позволит более реалистично описывать связь с соленостью в соответствии общеэкологическими представлениями о куполе толерантности. То есть экологическая ниша каждого вида будет характеризоваться не двумя коэффициентами, как было описано выше, а тремя, в соответствии со следующей формулой:  -->

<!-- $$ -->
<!-- ln(N) = b_0 + b_1S + b_2S^2 + \varepsilon -->
<!-- $$ -->

<!-- Для построения модели в качестве показателя обилия будет использован логарифм от плотности поселения вида, $ln(N) + 1$, (это необходимо для построения модели, основанной на нормальном распределении).  -->
<!-- Подбор коэффициентов осуществлялся с помощью пакета "Hmsc" (++++).  -->

<!-- 2. В соответствии с моделями BSM1, BSM2 и BSM3 были проведены вычисления предсказанных (fitted) моделями обилий видов. Эти три набора данных были сравнены с помощью величины $R_{global}$, используемой в качестве статистики в методе ANOSIM.  Это срвнение позволио выявить тот сценарий из модели +++, который создает условия наиболее похожие на те, которые наблюдались при взятии проб.  -->

<!-- 3. Так BSM модель, которая имела макисмальное сходство с BSM1 рассматривалась как источник коэффициентов для прогноза   -->




<!-- ```{r} -->
<!-- bent <- read_excel("Data/Obskaya_bay_2020.xlsx", sheet = "Benthos") -->


<!-- bent_B <- bent %>% filter(Type == "Biomass") %>% select(-Type) -->

<!-- bent_N <- bent %>% filter(Type == "Abundance") %>% select(-Type) -->


<!-- Spec_abund <- bent_N %>% select(-Station) %>% colSums(.) %>% t() %>% as.vector()  -->

<!-- spec_total_abund <- data.frame(Sp = bent_N %>% select(-Station) %>% colnames(), Spec_abund) -->

<!-- N_porog <- 0  -->

<!-- spec_selected <- spec_total_abund %>% filter(Spec_abund > N_porog) -->

<!-- bent_short <- bent_N %>% select(Station, spec_selected$Sp) -->


<!-- bent_short <- -->
<!--   bent_short %>% mutate(Oligochaeta = Oligochaeta_gen._sp. + Oligochaeta_gen._spp.) %>%  -->
<!--   select(-c(Oligochaeta_gen._sp., Oligochaeta_gen._spp., Oligochaeta_gen._sp._cocons,Senecella_siberica) ) -->



<!-- stations <- read_excel("Data/Obskaya_bay_2020.xlsx", sheet = "Station parameters", na = "NA") -->

<!-- # Stations with biological samples -->
<!-- stat_full <- stations %>% filter(Exclude == 0) -->

<!-- stat_full <- as.data.frame(stat_full) -->





<!-- ### Данные для модели ###### -->


<!-- # Убираем станции с отсутствующими оценками солености -->

<!-- salmod_mean2 <- salmod_mean2 %>% filter(!is.na(salmod_mean2$Sal_No)) -->

<!-- bent_short <- bent_short %>% filter(Station %in% salmod_mean2$Station) -->


<!-- bent_short <- bent_short %>% select(-Station) -->

<!-- bent_short <- bent_short[, colSums(bent_short) > 0] -->


<!-- stat_full <- stat_full %>% filter(Station %in% salmod_mean2$Station) -->




<!-- salmod_mean2 <- salmod_mean2  %>% filter(!is.na(salmod_mean2$Sal_No))  -->


<!-- n <- nrow(bent_short) # Число станций  -->
<!-- ns <- ncol(bent_short)-1 #Число видов -->




<!-- xycoords <- salmod_mean2 %>% select(Station, Long, Lat) %>% select(-Station) %>% as.matrix(.) -->

<!-- colnames(xycoords) = c("x-coordinate","y-coordinate") -->
<!-- rownames(xycoords) = 1:n -->




<!-- Ydata <- bent_short  %>% round(., 0) %>% as.matrix(.) -->
<!-- colnames(Ydata) <- names(bent_short) -->
<!-- rownames(Ydata) = 1:n -->

<!-- Ydata <- log(Ydata + 1) -->

<!-- # Ydata <- sqrt(Ydata) -->


<!-- Xdata_No <- salmod_mean2 %>% select(Sal_No, Depth)  -->

<!-- colnames(Xdata_No) <- c("Sal", "Depth") -->


<!-- Xdata_Constructed <- salmod_mean2 %>% select(Sal_Constructed, Depth) -->

<!-- colnames(Xdata_Constructed) <- c("Sal", "Depth", "Dist") -->


<!-- Xdata_initial <- stat_full %>% mutate (Sal = (Bottom_Salinity_Aug_20), Depth = (Depth_aug_20 + Depth_sep_20)/2 ) %>% select(Sal, Depth)  -->

<!-- colnames(Xdata_initial) <- c("Sal", "Depth") -->


<!-- ``` -->




<!-- ```{r} -->

<!-- library(Hmsc) -->

<!-- load("m.spatial.RData") # Загрузка модели, где предиктором является соленость из модели без строительства конструкций -->

<!-- load("m.spatial_constructed.RData") # Загрузка модели, где предиктором является соленость из модели после строительства конструкций -->

<!-- load("m.spatial_initial.RData") # Загрузка модели, где предиктором является изначально измеренная соленость  -->




<!-- Preds.spatial_Init = computePredictedValues(m.spatial_initial) -->

<!-- Predicted_Init <- apply(Preds.spatial_Init, c(1,2), mean) -->

<!-- Predicted_Init <- round(exp(Predicted_Init)-1, 0) -->

<!-- Predicted_Init <- as.data.frame(Predicted_Init) -->
<!-- Predicted_Init$Type <- "Init" -->



<!-- Preds.spatial_Native = computePredictedValues(m.spatial) -->

<!-- Predicted_Native <- apply(Preds.spatial_Native, c(1,2), mean) -->

<!-- Predicted_Native <- round(exp(Predicted_Native)-1, 0) -->

<!-- Predicted_Native <- as.data.frame(Predicted_Native) -->
<!-- Predicted_Native$Type <- "Native" -->




<!-- Preds.spatial_Constructed = computePredictedValues(m.spatial_constructed) -->

<!-- Predicted_Constructed <- apply(Preds.spatial_Constructed, c(1,2), mean) -->

<!-- Predicted_Constructed <- round(exp(Predicted_Constructed)-1, 0) -->

<!-- Predicted_Constructed <- as.data.frame(Predicted_Constructed) -->
<!-- Predicted_Constructed$Type <- "Constructed" -->


<!-- All_Predicted <- rbind(Predicted_Native, Predicted_Constructed, Predicted_Init) -->

<!-- All_Predicted[All_Predicted<0] <- 0 -->

<!-- ``` -->


<!-- ```{r} -->
<!-- library(vegan) -->
<!-- ord <- metaMDS(All_Predicted[,-ncol(All_Predicted)]) -->

<!-- ord_mds <- as.data.frame(scores(ord)) -->

<!-- ggplot(ord_mds, aes(NMDS1, NMDS2, color = All_Predicted$Type)) + geom_point() + facet_wrap(~All_Predicted$Type) -->



<!-- Init_Constr <- All_Predicted %>% filter(Type %in% c("Constructed", "Init"))  -->

<!-- anosim_1 <- Init_Constr %>% select(-Type) %>%  anosim(., grouping =  Init_Constr$Type) -->

<!-- summary(anosim_1) -->



<!-- Init_Native <- All_Predicted %>% filter(Type %in% c("Native", "Init"))  -->

<!-- anosim_2 <- Init_Native %>% select(-Type) %>%  anosim(., grouping =  Init_Native$Type) -->

<!-- summary(anosim_2) -->



<!-- Constructed_Native <- All_Predicted %>% filter(Type %in% c("Constructed", "Native"))  -->

<!-- anosim_3 <- Constructed_Native %>% select(-Type) %>%  anosim(., grouping =  Constructed_Native$Type) -->

<!-- summary(anosim_3) -->


<!-- ``` -->







<!-- ```{r} -->


<!-- # Новые значения для предсказания для сценария, когда есть конструкции  -->
<!-- X_new <- as.matrix(data.frame(intercept = 1, Sal = Xdata_No$Sal, Sal2 = Xdata_No$Sal^2)) -->

<!-- Predicted_Native_by_Constructed <- predict(m.spatial_constructed, X = X_new) -->



<!-- Predicted_No_mean <- Reduce("+", Predicted_Native_by_Constructed) / length(Predicted_Native_by_Constructed) -->

<!-- Predicted_No_mean <- round(exp(Predicted_No_mean) -1, 0) -->

<!-- Predicted_No_mean <- as.data.frame(Predicted_No_mean) -->

<!-- Predicted_No_mean$Type <- "Native" -->



<!-- ``` -->




<!-- ```{r} -->
<!-- library(vegan) -->

<!-- H_raw <- diversity(bent_short) -->

<!-- H_No <- diversity(Predicted_No_mean[,-ncol(Predicted_No_mean)]) -->

<!-- N_total_No <- rowSums(Predicted_No_mean[,-ncol(Predicted_No_mean)]) -->


<!-- H_Constructed <- diversity(Predicted_Constructed[,-ncol(Predicted_Constructed)]) -->

<!-- N_total_Constructed <- rowSums(Predicted_Constructed[,-ncol(Predicted_Constructed)]) -->

<!-- H <- data.frame(Station = stat_full$Station, Long = stat_full$Long, Lat = stat_full$Lat,  H_Constructed, H_No, H_Dif =  (H_Constructed - H_No)/H_Constructed    ) -->

<!-- hist(H$H_Dif) -->

<!-- qplot(H$Long, H$Lat) + aes(size = H$H_Dif) -->



<!-- ``` -->








