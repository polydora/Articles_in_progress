---
title: "Community changes modelling"
output: html_document
---


```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = FALSE, message = F, warning = F)

```

<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }
td {  /* Table  */
  font-size: 14px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 12px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}
</style>


Внесение существенных изменений в гидрологические характеристики акватории, связанные со строительством тех или иных гидротехнических сооружений, может оказать заметное влияние не только на биотопы непосредственно связанные с районом воздействия, но и на удаленные местообитания. В практике экологического мониторинга области, удаленные от зон антропогенного влияния, часто находятся вне фокуса внимания мониторинговых программ. В связи этим  картина изменений может оказаться неполной. Вместе с тем, тенденции, выявляемые при анализе сравнительно небольших участков акватории, могут давать достаточно надежную информацию для экстраполяции этих тенденций на большие участки акватории. Эта задача может быть решена с помощью моделирования поведения биосистем. 


В случае сообществ, систем состоящих из большого количества видов, взаимодействующих не только с параметрами окружающей среды, но и друг с другом, мощным инструментом для решения задач моделирования и прогноза является концепция  Joint Species Distribution Modelling (JSDM, рис. ++). Ядро этого подхода сводится к тому, что при моделировании связей сообщества с параметрами среды необходимо учитывать не только реакцию отдельных видов в соответствии с их экофизиологическими особенностями, но также и взаимоотношения между членами сообществ. Если мы рассматриваем не один вид, а все сообщество целиком, то в рамках концепции JSDM подбор коэффициентов, описывающих связи со средой, осуществляется не для каждого вида в отдельности (как серия независимых линейных моделей), а с учетом связей между видами (матрица корреляций) и учетом дизайна сбора материала (наличие случайных группирующих факторов и/или факторов, порождающих пространственные или временные автокорреляции). Потенциально в рамках JSDM можно учесть и филогенетические и функциональные характеристики видов.


![Figure 1. Principal scheme of Joint Species Distribution Modelling (from https://www2.helsinki.fi/en/researchgroups/statistical-ecology/hmsc)](Figures/JSDM.png)


Этот подход дает возможность построить модель, описывающую состояние сообщества при заданных условиях, а затем рассчитать параметры "предсказанного" сообщества для нового сочетания параметров окружающей среды. Данный подход был успешно применен к орнитологическому и геоботаническому материалу (Ovaskainen, Abrego, 2021), а также был успешно опробирован на материале исследований пресноводного макробентоса (Шитиков, Зинченко, Головотюк, 2021) и сообществ морских рыб (Roberts, Halpin, Clark, 2022). 

В Обской губе разворачивается масштабное строительство разнообразных гидротехнических сооружений, которые потенциально могут изменить гидрологический режим всей акватории. Наиболее уязвимым природным объектом в этих условиях становятся сообщества макробентоса, которые испытают не только прямое воздействие со стороны гидротехнических сооружений, но могут, также, проявить отклик в удаленных от мест воздействия участках за счет изменений рельефа дна, скорости течений, новой схемы перемещений водных масс и т.д. 


Гидрологические последствия строительства гидротехнических сооружений надежно прогнозируются исходя из знаний характера рельефа дна и связанных с ним других параметров. Это позволило в рамках гидрологической модели **INMOM** рассмотреть два сценария: "Native" (гидрологические условия в акватории до проведения гидротехнических работ) и "Constructed" (условия, прогнозируемые после проведения гидротехнических работ). Отклик бентосных сообществ не столь однозначно связан гидрофизическими условиями и требует специального анализа с помощью JSDM. Использование JSDM в приложении к гидробиологическиму материалу даст возможность ответить на ряд вопросов: 

1. Насколько сильно изменятся сообщества бентоса при реализации планов гидротехнических работ?

2. В каких участках акватории ожидаются наиболее сильные изменения?

3. Для каких видов гидробионтов ожидаются наиболее сильные изменения обилия при проведении гидротехнических работ?



Моделирование сообществ бентоса проходило по следующей схеме.

1. С помощью функций из пакета "Hmsс" (Tikhonov, Ovaskainen, Oksanen, 2021) была построена модель, описывающая связь структуры сообщества бентоса с гидрологическими характеристиками акватории, находящимися в режиме "Native" (без проведения гидротехнических работ). При этом в качестве матрицы зависимых переменных выступал массив плотностей поселения видов (значения были подвергнуты $ln(N+1)$ преобразованию). В качестве  предикторов в модель были включены гидрологические параметры, варьирование которых описывается моделью **INMOM**. Для обучения модели были использованы три относительно независимых (неколлинеарных) величины: соленость, модуль зональной компоненты скорости течения, модуль меридианальная составляющей скорости течения. Для формирования матрицы предикторов для каждой станции, на которой проводилось взятие проб бентоса, были получены предсказанные моделью **INMOM** значения указанных параметров для каждого дня календарного года. Далее значения всех показателей были усреднены. При построении модели связь с соленостью описывалась полиномом 2 степени. Связь со скоростями течения, как линейные функции. Для учета пространственных автокорреляций в модель, в качестве случайного фактора, были включены географические координаты точек взятия проб. 

2. С помощью модели **INMOM** были получены значения предикторов для сценария "Constructed", то есть после проведения гидротехнических работ. На основе этих данных была получена матрица значений предикторов в точках взятия бентосных проб, аналогичная той, которая была использована при построении модели.

3. Используя коэффициенты, подобранные на шаге 1, была сконструирована матрица обилий, характеризующая "предсказанное" сообщество при сценарии "Constructed". 

4. Используя данные по биомассе видов в пробах были вычислены средние веса особей для каждого вида. Далее на основе этих данных были получены суммарные биомассы бентоса предсказанные моделью для двух гидрологических режимов. 

5. Для оценки степени различий между суммарными биомассами сообществ в режиме "Native" и режиме "Constructed" была введена величина 

$$
Dif = ln(\frac{B_{Constructed}}{B_{Native}})
$$ 

Положительные значения этой величины свидетельствуют о возрастании суммарной биомассы после проведения гидротехнических работ, а отрицательные - о их падении. 




```{r}
library(readxl)
library(ggplot2)
library(dplyr)
library(lubridate)

library(ggmap)
library(mapproj)
library(maps)

library(rgeos) 

library(mapdata)
library(maptools) # Rgshhs
library(PBSmapping)
library(cowplot)
library(mgcv)
library(ggrepel)
library(png)
library(broom)

theme_set(theme_bw())

predictors <- read.csv("data/Bottom_salinity_and_curents_from_model.csv")


predictors_No <- predictors %>% filter(Scenario == "No") %>% select(Station, Long, Lat, Depth, Month, Sal_predicted, Cur_Zon_predicted, Cur_Mer_predicted)


predictors_Constructed <- predictors %>% filter(Scenario == "Constructed") %>% select(Station, Long, Lat, Depth, Month, Sal_predicted, Cur_Zon_predicted, Cur_Mer_predicted)


mean_predictors_No <- predictors_No %>% group_by(Station) %>% summarise( Long = mean(Long), Lat= mean(Lat), Sal = mean(Sal_predicted), Cur_Zon = mean(abs(Cur_Zon_predicted) ), Cur_Mer = mean(abs(Cur_Mer_predicted)), Prop_Sal_anomalia = mean(Sal_predicted > mean(Sal_predicted)), Prop_Sal_5 = mean(Sal_predicted > 5))


mean_predictors_No <- mean_predictors_No %>% filter(complete.cases(.))



mean_predictors_Constructed <- predictors_Constructed %>% group_by(Station) %>% summarise( Long = mean(Long), Lat= mean(Lat), Sal = mean(Sal_predicted), Cur_Zon = mean(abs(Cur_Zon_predicted) ), Cur_Mer = mean(abs(Cur_Mer_predicted)), Prop_Sal_anomalia = mean(Sal_predicted > mean(Sal_predicted)), Prop_Sal_5 = mean(Sal_predicted > 5))


mean_predictors_Constructed <- mean_predictors_Constructed %>% filter(complete.cases(.))


# Data on benthic communities ######
bent <- read_excel("Data/Obskaya_bay_2020.xlsx", sheet = "Benthos")


bent_B <- bent %>% filter(Type == "Biomass") %>% select(-Type)

bent_N <- bent %>% filter(Type == "Abundance") %>% select(-Type)




Spec_abund <- bent_N %>% select(-Station) %>% colSums(.) %>% t() %>% as.vector() 

spec_total_abund <- data.frame(Sp = bent_N %>% select(-Station) %>% colnames(), Spec_abund)

N_porog <- 0 

spec_selected <- spec_total_abund %>% filter(Spec_abund > N_porog)

bent_short <- bent_N %>% select(Station, spec_selected$Sp)
bent_B <- bent_B %>% select(Station, spec_selected$Sp)


bent_short <-
  bent_short %>% mutate(Oligochaeta = Oligochaeta_gen._sp. + Oligochaeta_gen._spp.) %>% 
  select(-c(Oligochaeta_gen._sp., Oligochaeta_gen._spp., Oligochaeta_gen._sp._cocons,Senecella_siberica) )

bent_B <-
  bent_B %>% mutate(Oligochaeta = Oligochaeta_gen._sp. + Oligochaeta_gen._spp.) %>% 
  select(-c(Oligochaeta_gen._sp., Oligochaeta_gen._spp., Oligochaeta_gen._sp._cocons,Senecella_siberica) )


mean_weight <- (bent_B %>% select(-Station) %>% colSums()) / (bent_short %>% select(-Station) %>% colSums()) 




stations <- read_excel("Data/Obskaya_bay_2020.xlsx", sheet = "Station parameters", na = "NA")

# Stations with biological samples
stat_full <- stations %>% filter(Exclude == 0)

stat_full <- as.data.frame(stat_full)


### Данные для модели ######


# Убираем станции с отсутствующими оценками предикторов

bent_short <- bent_short %>% filter(Station %in% mean_predictors_No$Station)


bent_short <- bent_short %>% select(-Station)

bent_short <- bent_short[, colSums(bent_short) > 0]


stat_full <- stat_full %>% filter(Station %in% mean_predictors_No$Station)


mean_weight <- mean_weight[names(mean_weight) %in% names(bent_short)] 



n <- nrow(bent_short) # Число станций 
ns <- ncol(bent_short) #Число видов



xycoords <- mean_predictors_No %>% select(Station, Long, Lat) %>% select(-Station) %>% as.matrix(.)

colnames(xycoords) = c("x-coordinate","y-coordinate")
rownames(xycoords) = 1:n




Ydata <- bent_short  %>% round(., 0) %>% as.matrix(.)
colnames(Ydata) <- names(bent_short)
rownames(Ydata) = 1:n

Ydata <- log(Ydata + 1)


Xdata_No <- mean_predictors_No %>% select(Sal, Cur_Zon, Cur_Mer, Prop_Sal_anomalia, Prop_Sal_5) 

colnames(Xdata_No) <- c("Sal", "Cur_Zon", "Cur_Mer", "Prop_Sal_anomalia", "Prop_Sal_5")



Xdata_Constructed <- mean_predictors_Constructed %>% select(Sal, Cur_Zon, Cur_Mer, Prop_Sal_anomalia, Prop_Sal_5) 

colnames(Xdata_Constructed) <- c("Sal", "Cur_Zon", "Cur_Mer", "Prop_Sal_anomalia", "Prop_Sal_5")



```





```{r}

# set.seed(123456)
library(Hmsc)

load( "m.spatial_No_new.RData")


X_new <- as.matrix(data.frame(intercept = 1, Sal = Xdata_No$Sal, Sal2 = Xdata_No$Sal^2, Xdata_No$Cur_Zon, Xdata_No$Cur_Mer))

Predicted_No <- predict(m.spatial, X = X_new, expected = TRUE)


Predicted_No_mean <- Reduce("+", Predicted_No) / length(Predicted_No)

Predicted_No_mean <- round(exp(Predicted_No_mean) -1, 0)
Predicted_No_mean <- as.data.frame(Predicted_No_mean)

Predicted_No_mean_B <- Predicted_No_mean * mean_weight



# Новые значения для предсказания для сценария, когда есть конструкции 
X_new <- as.matrix(data.frame(intercept = 1, Sal = Xdata_Constructed$Sal, Sal2 = Xdata_Constructed$Sal^2, Xdata_Constructed$Cur_Zon, Xdata_Constructed$Cur_Mer))

Predicted_Constr <- predict(m.spatial, X = X_new, expected = TRUE)


Predicted_Constr_mean <- Reduce("+", Predicted_Constr) / length(Predicted_Constr)

Predicted_Constr_mean <- round(exp(Predicted_Constr_mean) -1, 0)
Predicted_Constr_mean <- as.data.frame(Predicted_Constr_mean)

Predicted_Constr_mean_B <- Predicted_Constr_mean * mean_weight

```

```{r}
library(vegan)

H_No <- rowSums(Predicted_No_mean_B)

H_Constructed <- rowSums(Predicted_Constr_mean_B)


# H_No <- diversity(Predicted_No_mean)
# 
# H_Constructed <- diversity(Predicted_Constr_mean)


H <- data.frame(Station = stat_full$Station , Lat = xycoords[,2], Long = xycoords[,1], H_No = round(H_No, 4), H_Constructed =  round(H_Constructed, 4))

H$Dif_H <- with(H, round(log(H_Constructed/H_No), 4))

H <- H %>%  mutate(Dif_class = case_when(round(Dif_H, 4) >  0 ~ "Increase",
                                         round(Dif_H, 4) ==  0 ~ "Stable",
                                         round(Dif_H, 4) < 0  ~ "Decrease"))


```






```{r}
Ob_df <- read.csv("Data/Obskaya_bay_map.csv") # Map poligones


# Coordinate limites 
# Ob_x <- c(71, 79)

Ob_x <- c(71, 75.2)
Ob_y <- c(70, 73.2)



# Sabetta
Sabetta_y <- 71.235220
Sabetta_x <- 72.126754

# Terminal

Terminal_y <- 71.010886
Terminal_x <- 73.793525


my_data <- expand.grid(Lat = seq(from = 70.8, to = 72.8 , length.out = 200), Long =  seq(from = Ob_x[1], to =Ob_x[2] , length.out = 200))


H$Decrewase <- ifelse(H$Dif_H < 0, 1, 0)


Mod_Dif_H <- gam(Decrewase ~ s(Long, Lat, bs = "tp"), data = H, family = "binomial")




# plot(Mod_Dif_H)

my_data$Dif_predicted <- predict(Mod_Dif_H, newdata = my_data, type = "response")

# quantiles <- quantile(H$Dif_H, probs = c(0.25, 0.75))

# my_data <- my_data %>% mutate(Dif_class = case_when(Dif_predicted > quantiles[2] ~ "Increase",
#                                          Dif_predicted <= quantiles[2] & Dif_predicted >= quantiles[1] ~ "Stable",
#                                          Dif_predicted < quantiles[1] ~ "Decrease"))

# 
# my_data <- my_data %>% mutate(Dif_class = case_when(round(Dif_predicted, 4) >=  0 ~ "Increase",
#                                                     round(Dif_predicted, 4) < 0  ~ "Decrease"))


# my_data$Dif_class <- ifelse(my_data$Dif_predicted >= 0, "Increase", "Decrease")

# unique(my_data$Dif_class)

```





В целом, значительных изменений в сообществах при двух гидрологических режимах не выявляется. Однако, согласно предсказаниям модели, до дноуглубительных работ средняя суммарная биомасса составляет `r round(mean(H$H_No), 4)` г/м^2^, а после после их проведения ожидается, что суммарная биомасса  сократится и составит `r round(mean(H$H_Constructed), 4)` г/м^2^. Таким образом, по сравнению с режимом "Native" при режиме "Constructed" ожидается сокращение суммарной биомассы на `r round(abs((mean(H$H_Constructed) - mean(H$H_No))/mean(H$H_No)*100), 2)`%.  



Все станции, в соответствии со значением величины $Dif$, можно разделить на три группы (Table ++ ; Fig. +++): станции, на которых ожидается уменьшение биомассы, они имеют отрицательное значение величины $Dif$, станции, на которых ожидается увеличение биомассы бентоса (положительные значения величины $Dif$) и станции, на которых не прогнозируется никаких изменений ($Dif = 0$). Доля станций, попавших в первую группу, составляет `r round(mean(H$Dif_H < 0) * 100, 1)`%. Доля станций, на которых прогнозируется увеличение биомассы, несколько меньше и составляет `r round(mean(H$Dif_H > 0) * 100, 1)`%. Большинство станций (`r round(mean(H$Dif_H == 0) * 100, 1)`%) попадают в третью группу. Таким образом, на большей части акватории существенных изменений при двух гидрологических режимах наблюдаться не будет. 


```{r}

H <- H %>% mutate(Prop_changes = round((H_Constructed - H_No)/H_No*100, 2) ) %>% select(Station, Lat, Long, H_No, H_Constructed, Dif_H, Prop_changes, Dif_class) 


kable(H, col.names = c("Station", "Lat", "Long", "$Biomass_{Native}$", "$Biomass_{Constructed}$", "Dif", "Proportion of chages (%)", "Direction of changes")) 
```





```{r fig.cap="Fig. ++. Direction of total biomass changes at stations"}

ggplot(H, aes(x = Long, y = Lat)) +
     geom_polygon(data = Ob_df, aes(x=long, y=lat, group=group), fill = "gray90", colour = "gray20") +
  geom_point(aes(fill = Dif_class), shape = 21, size = 3) +
  scale_fill_manual(values = c("red", "yellow", "gray"))+
  labs(fill = "Dif value")

```






Для анализа пространственного паттерна прогнозируемых изменений была построена модель, позволяющая оценить вероятность встречи точки, на которой в режиме "Constructed"  произойдет снижение биомассы по сравнению с режимом "Native". Для этого станции, на которых было отмечено снижение биомассы, кодировались, как "1", а станции, на которых не происходило повышение биомассы, как "0". Далее была подобрана модель (Logistic Binomial Generalized Additive Model, GAM), устанавливающая связь между вероятностью присутствия сообщества, снижающего биомассу, и географическими координатами.

$$
GAM: P_{Decrease} = f(Lat, Long) + \varepsilon
$$
где     
$f$ - two dimensionsional thin plate smoother,     
$Lat$, $Long$ - geographic coordinates,    
$\varepsilon$ - residuals.      



Наибольшая вероятность встречи сообществ, испытывающих угнетение в режиме "Constructed, приходится на северо-восточную часть акватории (рис. +++).   




```{r}

ggplot(my_data, aes(x = Long, y = Lat)) +
  geom_tile(aes(fill = Dif_predicted)) +
  geom_polygon(data = Ob_df, aes(x=long, y=lat, group=group), fill = "gray90", colour = "gray20") +
  scale_fill_gradient(low = "white", high = "red")   +
  labs(fill = "Probability of Decrease") +
  guides(color = "none")


```







```{r}


sp_changes <- ((Predicted_Constr_mean - Predicted_No_mean) * mean_weight) %>% summarise_all(.funs = mean)   %>% t() 




sp_decreas <- gsub(pattern = "_", replacement = " ", row.names(sp_changes)[sp_changes<0])

sp_decreas <- sp_decreas[-c(4,5)]




sp_increas <- gsub(pattern = "_", replacement = " ", row.names(sp_changes)[sp_changes>0])

```



Сопоставление предсказанных моделью обилий отдельных видов позволяет выявить формы, обилие которых, согласно прогнозу, должно сократиться. К числу таких видов относятся следующие: `r sp_decreas`. Важно отметить, что к числу видов, для которых прогнозируется сокращение обилия, относятся самые массовые для Обской губы виды ракообразных (Saduria entomon, Monoporeia affinis, Pontoporeia femorata), которые составляют основу для питания бентоядных видов рыб. 
Увеличение обилия ожидается для следующих таксонов:`r sp_increas`. 



<!-- ```{r} -->
<!-- library(raster) -->


<!-- path = "D:/Data_LMBE/Obskaya Bay additional data/nc_files_from_model/No_construction_building" -->

<!-- files <- list.files(path) -->
<!-- name <- files[1] -->
<!--   name = paste(path, "/", name, sep = "") -->
<!--   Sal_layer <- brick(name, var="salt") -->
<!--   Uocn_layer <- brick(name, var="uocn") -->
<!--   Vocn_layer <- brick(name, var="vocn") -->

<!-- sal_df <- as.data.frame(rasterToPoints(Sal_layer)) -->

<!-- sal_df <- sal_df %>% mutate(Sal = case_when(!is.na(X20) ~ X20, -->
<!--                                   is.na(X20) & !is.na(X15) ~ X15, -->
<!--                                   is.na(X20) & is.na(X15) & !is.na(X10) ~ X10, -->
<!--                                   is.na(X20) & is.na(X15) & is.na(X10) & !is.na(X5)~ X5,  -->
<!--                                   is.na(X20) & is.na(X15) & is.na(X10) & is.na(X5) &  !is.na(X1) ~ X1))  -->


<!-- uucn_df <- as.data.frame(rasterToPoints(Uocn_layer)) -->

<!-- uucn_df <- uucn_df %>% mutate(Uucn = case_when(!is.na(X20) ~ X20, -->
<!--                                   is.na(X20) & !is.na(X15) ~ X15, -->
<!--                                   is.na(X20) & is.na(X15) & !is.na(X10) ~ X10, -->
<!--                                   is.na(X20) & is.na(X15) & is.na(X10) & !is.na(X5)~ X5,  -->
<!--                                   is.na(X20) & is.na(X15) & is.na(X10) & is.na(X5) &  !is.na(X1) ~ X1))  -->



<!-- vucn_df <- as.data.frame(rasterToPoints(Vocn_layer)) -->

<!-- vucn_df <- vucn_df %>% mutate(Vucn = case_when(!is.na(X20) ~ X20, -->
<!--                                   is.na(X20) & !is.na(X15) ~ X15, -->
<!--                                   is.na(X20) & is.na(X15) & !is.na(X10) ~ X10, -->
<!--                                   is.na(X20) & is.na(X15) & is.na(X10) & !is.na(X5)~ X5,  -->
<!--                                   is.na(X20) & is.na(X15) & is.na(X10) & is.na(X5) &  !is.na(X1) ~ X1))  -->






<!-- ``` -->


<!-- ```{r} -->
<!-- X_new <- as.matrix(data.frame(intercept = 1, Sal = sal_df$Sal, Sal2 = sal_df$Sal^2, Cur_Zon = uucn_df$Uucn, Cur_Mer = vucn_df$Vucn )) -->

<!-- xycoords <- as.matrix(sal_df[, 1:2]) -->
<!-- rL.spatial = HmscRandomLevel(sData = xycoords) -->


<!-- load("m.spatial_No_no_random.RData") -->
<!-- Predicted_No_rastr <- predict(m.spatial, X = X_new, expected = TRUE) -->


<!-- Predicted_No_mean <- Reduce("+", Predicted_No) / length(Predicted_No) -->

<!-- Predicted_No_mean <- round(exp(Predicted_No_mean) -1, 0) -->
<!-- Predicted_No_mean <- as.data.frame(Predicted_No_mean) -->

<!-- Predicted_No_mean_B <- Predicted_No_mean * mean_weight -->

<!-- ``` -->



  
<!-- ```{r} -->
<!-- Pl_H_class <-  -->
<!-- ggplot(my_data, aes(x = Long, y = Lat)) +  -->
<!--   geom_tile(aes(fill = Dif_class)) + -->
<!--   geom_polygon(data = Ob_df, aes(x=long, y=lat, group=group), fill = "gray90", colour = "gray20") + -->
<!--   scale_fill_manual(values = c("yellow","red", "gray")) + -->
<!--   geom_point(data = H)+ -->
<!--   geom_point(aes(x = Sabetta_x, y = Sabetta_y), size = 3, shape = 21, fill = "blue") +  -->
<!--   geom_point(aes(x = Terminal_x, y = Terminal_y), size = 3, shape = 22, fill = "blue")+ -->
<!--   labs(fill = "Direction of changes") -->

<!-- ``` -->


<!-- ```{r} -->

<!-- H_long <- data.frame(Scenario = c(rep("Native", nrow(H)), rep("Constructed", nrow(H))), Total_B = c(H$H_No, H$H_Constructed)) -->

<!-- ``` -->



<!-- ```{r} -->

<!-- (mean(H$H_No) - mean(H$H_Constructed))/ mean(H$H_No) *100 -->

<!-- qplot(H$H_No, H$H_Constructed) + geom_abline() -->



<!-- ``` -->


