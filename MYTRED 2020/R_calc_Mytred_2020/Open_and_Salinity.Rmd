---
title: "Соленость и открытость"
author: "ВМ"
date: "31 07 2021"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE, message = FALSE)


```

Антон, привет!
Я немного поиграл с данными, но, увы не до конца понял их структуру. Уж больно они не tidy. Разобрался, как мне кажется, только с Exp1. Итак, излагаю, как понял. Можешь копировать код из чанков и проходить его самостоятельно.

Как я понял, было 60 точек наблюдений. в каждой из которых была какая-то соленость (она менялась по мере проведения эксперимента). Соответственно это все можно описать следующим датасетом.

```{r}
library(readxl)
library(dplyr)
library(reshape2)
library(lme4)
library(ggplot2)


salinity <- read_excel("Data/Mytred_2021_Salinity.xlsx", sheet = "Exp1_Salinity")

salinity <- as.data.frame(salinity)

head(salinity)
```

Параметр "Duration" я ввел формально, так как это, вероятно, часы, но для модели это не столь важно. 



Далее, наблюдения над мидиями дают бинарную переменную отклика, которая при каждом наблюдении имеет значение 1 (открыта) или 0 (закрыта). Исходные данные у тебя даны в широком формате.

```{r}
myt <- read_excel("Data/Mytred_2021_Salinity.xlsx", sheet = "Exp1_tidy")

myt <- as.data.frame(myt)

head(myt)
```

Поскольку в ряде случаев ожидаемый морфотип не совпал с наблюдаемым (после вскрытия). То я таких мидий удалил, чтобы они не смущали.

```{r}
# Удаляю мидий с несовпадающими морфотипами
myt2 <- myt %>% filter(Expected_Morph == True_Morph) 
```



Широкий формат - это не лучшая форма для работы с данными. Поэтому я переделал все это в длинный формат.

```{r}
myt2_long <- melt(myt2, id.vars = c("Experiment", "Tank",	"Plank", 	"Mussel_ID",	"Expected_Morph",	"True_Morph",	"Length",	"Www"), value.name = "Status", variable.name = "Observation" ) %>% filter(Tank != "C")

# Обрати внимание, что контрольный аквариум я убрал из дальнейшего анализа. Он нужен только для одной цели, чтобы показать, что при неизменной солености от продолжительнсти наблюдений (Duration) ничего не зависит. 

# Приделываю к имеющимся данным по состоянию мидий даные по солености и продолжительности
myt2_sal_long <- merge(myt2_long, salinity)

head(myt2_sal_long)
```

С этим датасетом уже можно что-то делать.

### Строю модель

Здесь все пока довольно кисло, так как longitudial data это вообще херовые данные для моделирования. Было бы, конечно, здорово такой же эксперимент поставить без повторных наблюдений (много аквариумов с разной соленостью, типа по три на каждую соленость, в каждом акватриуме есть пластина, а лучше несколько, с мидиями каждого из морфотипов, ну и одновременно, через какое-то время, регистрируем сколько открытых-закрытых мидий в зависимости от морфотипа). Ну за неимением гербовой пишем на простой... 

Модель, что приведена ниже,  пока еще не совсем меня устраивает, так как в нее, конечно, надо как-то вкрячить временные корреляции. Как, пока не понял. 

Итак, модель

```{r}

Model1 <- glmer(Status ~ Salinity*True_Morph + Duration + (1|Mussel_ID) + (1|Tank), data = myt2_sal_long, family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=2e5)))

summary(Model1)

```

Видно, что есть существенное взаимодействие фактора "соленость" и "морфотип". То есть реакция на соленость у разных морфотипов отличается. Для более понятной трактовки строим визуализацию. Поскольку здесь, подспудно, будет сидеть фактор "Duration", то красивой визуализации не получается, так как надо как-то встроить в нее эту самую Duration, которая, сцука, еще и значимо влияет (см. summary от модели, где видно, чо чем больше Duration, тем больше доля открытых... типа, привыкают). Для визуалзации пришлось взять среднее значение Duration.

Итак, визуализация

```{r}
MyData <- expand.grid(Salinity = seq(min(myt2_sal_long$Salinity), max(myt2_sal_long$Salinity), 0.1), True_Morph = c("t", "e"), Duration = mean(myt2_sal_long$Duration))

logit_back <- function(x) exp(x)/(1 + exp(x)) # обратная логит-трансформация

X <- model.matrix(~  Salinity*True_Morph + Duration, data = MyData)
b <- fixef(Model1)

MyData$fit_eta <- X %*% b #Предсказанные значения в шкале логитов
MyData$se_eta <- sqrt(diag(X %*% vcov(Model1) %*% t(X))) #Ошибки в шкале логитов

MyData$fit_pi <- logit_back(MyData$fit_eta) #Предсказанные значения в шкале вероятностей

# Границы доверительного интервала
MyData$lwr <- logit_back(MyData$fit_eta - 1.96 * MyData$se_eta)
MyData$upr <- logit_back(MyData$fit_eta + 1.96 * MyData$se_eta)


Pl <-
  ggplot(MyData, aes(x = Salinity, y = fit_pi)) + 
  geom_line(aes(, color = True_Morph), size = 1) + 
  geom_ribbon(aes(ymin = lwr, ymax = upr, group = True_Morph), alpha = 0.2) +
  scale_color_manual(values = c("red", "blue")) + 
  labs(x = "Slinity", y = "Proportion of open")

Pl
```


Добавим первичку. Но! Помним при этом, что для визуализации мы взяли Duration равное среднему значению. В первичке такого мы себе позволить не сможем. Поэтому первичка не суперски ложится на линии регрессии, хотя, впрочем, бывает и хуже.

```{r}
# Вычисляем частоту открытых мидий в каждом из наблюдений
myt2_sal_summary <- myt2_sal_long %>% group_by(Tank, Observation, True_Morph) %>% summarize(Salinity = mean(Salinity), Prop_Open = mean(Status == 1)) %>% as.data.frame()

head(myt2_sal_summary)
```

Наносим полученные значения на график с визуализацией модели.

```{r}
Pl + 
  geom_point(data = myt2_sal_summary, aes(x = Salinity, y = Prop_Open, color = True_Morph))
```


Короче, что отсюда видно. 

1. Существенной разницы в доле открывшихся у e- и t-морфотипов нет.
2. У e-морфотипа при возрастании солености открывание идет немного быстре (чуть большее значение углового коэффициента).

Что нужно сделать. 
1. Надо вбить данные по всем остальным экспериментам так, чтобы их можно было бы прилинковать к уже иеющимся данным. Идеально все это делать в длинном формате.


