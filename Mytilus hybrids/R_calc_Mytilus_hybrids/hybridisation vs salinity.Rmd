---
title: Зависимость степени генетической смешанности поселений M.edulus и M.trossulus
  от солености
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
  opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```


```{r}
library(readxl)
library(ggplot2)
library(dplyr)
library(mgcv)
library(ggrepel)

theme_set(theme_bw())

hybr <- read_excel("Data/hybrids_BS.xlsx")
hybr$region <- factor(hybr$region)


rivers <- read_excel("Data/rivers_BS.xlsx")
rivers$Drainage_Area <- as.numeric(rivers$Drainage_Area)
rivers$Lat <- as.numeric(rivers$Lat)
rivers$Lon <- as.numeric(rivers$Lon)



# Доля гибридов в сборах

hybr_pop <- hybr %>% group_by(ID) %>% summarise(lat = mean(N), lon = mean(E), Year = mean(year), Region = unique(region), Ptros = mean(str), P_hybr = mean(str > 0.1 & str < 0.9), md = 1 - (sd(str))^2/(Ptros*(1-Ptros)), md_1 = 1-md, Salinity = unique(salinity) ) 

# %>% filter(Ptros<0.9 & Ptros>0.1)



hybr_pop$Region <- factor(hybr_pop$Region, levels = c("West_coast",  "Kola",  "Tyuva", "East_coast" ))

```



## Степень смешанности 
Было использовано два способа определения смешанности. 

1. Доля гибридов в популяции ($P_{hybr}$) оценивалась как доля особей в выборке со значением Structure score в диапазоне от 0.1 до 0.9.

2. Величина $md$, предложенная в работе (Kalinowski & Powell, 2015). Однако по причинам, основанным на непонятных мне материях высшей генетики, предлагается рассматривать величину $md_{inv} = 1-md$. Оценка степени генетической смешанности производилась в соответствии со следующей формулой

$$
md_{inv} = \frac{\sum(P_i - \overline P)^2}{Ptros(1-Ptros)}
$$

Эта величина стремится к 1 в абсолютно не гибридизованных смешанных популяциях и к 0 при полной смеси.





## Оценка солености 
Оценка степени опресненности/осолоненности в точке взятия проб проводилась двумя способами. 

1. **Бинарная оценка (фактор Salinity)**. Каждая популяция была отнесена к одной из двух категорий: `r unique(hybr$salinity)` в соответсвии с некими представлениями сборщиков материала о том, испытывает ли данная акватория перманентное опреснение со стороны рек ("brackish") или нет ("normal"). 

2. **Оценка с помощью `Salinity index`**. Для вычисления этого показателя были использованы данные водного реестра РФ, из которого были извлечены данные по площади водосбора и географическим координатам устьевых участков значимых рек, представленных в регионе исследования. Данные, использованные в анализе приведены в таблице 1. 


```{r}
kable(rivers, col.names = c("Река", "Площадь водосбора (кв. км)", "Широта устья", "Долгота устья"))
```


Для всех популяций, географические координаты которых были известны, было вычислено расстояние до устья ближайшей к данной точке реки. Расстояние определялось по прямой без учет изгибов береговой линии. Результаты оценки приведены в Таблице 2. 

```{r}

# Функция для определения расстояния до ближайшего объекта
nearest_dist <- function(XY, objects = river, x.name = "Lon", y.name = "Lat"){
  
  XY1 <-as.numeric(XY[,1])
  XY2 <- as.numeric(XY[,2])
  dist <- (acos(sin(XY1*pi/180)*sin(objects[ ,y.name]*pi/180) + cos(XY1*pi/180)*cos(objects[ ,y.name]*pi/180)*cos(XY2*pi/180 - objects[ ,x.name]*pi/180)) * 6371)
  
  MD <- data.frame(Min_dist = min(dist))
  cbind(objects[which(dist == min(dist)), ], MD)
  
}


#  distance to mouth of the neares river 

df_river <- nearest_dist(XY = hybr_pop[1, c("lat", "lon")], objects = rivers)

df_river[1,] <- NA

for(i in 1:nrow(hybr_pop)) {
  df_river[i,] <- nearest_dist(XY = hybr_pop[i, c("lat", "lon")], objects = rivers)
  df_river$ID[i] <- as.character(hybr_pop$ID)[i]
}


names(df_river) <- c( "River",  "Drainage_Area",  "Lat_river", "Lon_river", "Min_dist_river", "ID" )



hybr_pop_riv <- merge(hybr_pop, df_river, by = "ID")

hybr_pop_riv$Min_dist_river <- round(hybr_pop_riv$Min_dist_river, 2)

hybr_pop_riv$Drainage_Area_1 <- 1/hybr_pop_riv$Drainage_Area


hybr_pop_riv$Sal_index <- round( with(hybr_pop_riv, sqrt(rank(Min_dist_river) * rank(Drainage_Area_1)) ))
```


На основе приведенных данных был вычислен индекс солености в данной точке. Алгоритм вычисления индекса был следующим.

1. Все значения расстояния до ближайшей реки были ранжированы. Минимальный ранг получили точки, имеющие минимальное расстояние до устья ближайшей реки. 

2. Величины площади водосбора ближайших рек были возведены в степень (-1) для того, чтобы реки с большей площадью водосбора (приносящие больше пресной воды) имели бы минимальные значения в ряду чисел. Полученные трансформированные значения были ранжированы. Минимальный ранг получили те точки, для которых ближайшая река имела максимальную площадь водосбора. 

3. Для каждой точки была вычислена величина `Salinity index`, как средняя геометрическая между значениями рангов расстояния до ближайшей реки и трансформированного значения площади водосбора

$$
Salinity \ index = \sqrt{rank(Distance) \times  rank(Drainage^{-1})}
$$



```{r}
hybr_pop_riv_print <- hybr_pop_riv %>% select(ID, Salinity, River, Min_dist_river, Drainage_Area, Sal_index)

kable(hybr_pop_riv_print, col.names = c("ID", "Бинарная оценка", "Ближайшая река", "Расстояние до ближайшей реки (км)", "Площадь водосбора ближайшей реки", "Salinity index"), caption = "Табл. 2. Оценки солености для каждой из точек сбора материала")
```

Полученная оценка индекса солености демонстрирует явную корреляцию с визуальной бинарной оценкой солености (рис. +). Однако обладает двумя явными преимуществами. Во-первых, она лишена субъективной составляющей (авторы бинарной оценки, зная результат изучения генетической структуры популяции, могут потенциально относить выборку к тому или иному классу, основываясь на своих знаниях о структуре популяции). Во-вторых, это непрерывная величина, которая лучше отражает существующие градиенты.   

```{r fig.cap="Рис. 1. Связь между бинарной оценкой солености и значением индекса солености."}
 
ggplot(hybr_pop_riv, aes(x = Salinity, y = Sal_index )) + geom_boxplot() + labs(x = "Бинарная оценка", y = "Salinity index")

```

Рисунок 2 демонстрирует пространственное распределение индекса солености в Кольском заливе. Значение индекса солености демонстрирует хорошо выраженный градиент от кута (куда впадают реки Тулома и Кола) к выходу из залива. Однако видны локальные отклонения от общего градиента в местах впадения менее крупных рек (Средняя, Большая Тюва).  

```{r }

murm_shape <- read.csv("Data/Murman.csv")


Murm_x <-  c(30, 40)
Murm_y <- c(67.8, 69.8)


Murm_region_map <- 
  ggplot(murm_shape, aes(x=long, y=lat, group=group)) +
  geom_polygon(fill = "gray90", colour = "gray20") + 
  coord_map(xlim = Murm_x, ylim = Murm_y) + 
  theme_bw() +  
  theme(axis.title.x = element_blank(),  axis.title.y = element_blank(), plot.background = element_blank(), panel.border = element_blank()) 



Murm_x_small <-  c(32.5, 34)
Murm_y_small <- c(68.85, 69.5)

Kola_bay_map <- 
  ggplot(murm_shape, aes(x=long, y=lat, group=group)) +
  geom_polygon(fill = "gray90", colour = "gray20") + 
  coord_map(xlim = Murm_x_small, ylim = Murm_y_small) + 
  theme_bw() +  
  theme(axis.title.x = element_blank(),  axis.title.y = element_blank(), plot.background = element_blank(), panel.border = element_blank()) 



Tuva_x <-  c(33.55, 33.65)
Tuva_y <- c(69.17, 69.2)


Tuva_map <-
  ggplot(murm_shape, aes(x=long, y=lat, group=group)) +
  geom_polygon(fill = "gray90", colour = "gray20") + 
  coord_map(xlim = Tuva_x, ylim = Tuva_y) + 
  theme_bw() +  
  theme(axis.title.x = element_blank(),  axis.title.y = element_blank(), plot.background = element_blank(), panel.border = element_blank()) 




# + theme(panel.grid = element_blank(), axis.text.x =element_blank(), axis.text.y= element_blank()) + theme(axis.ticks = element_blank()) 

```

```{r fig.cap="Рис. 2. Значения индекса солености в разных точках. Звездочки маркируют устья рек. "}

Pl_Sal_index <- 
Kola_bay_map + 
  geom_point(data = rivers, aes(x = Lon, y = Lat, group = 1), shape = 8, size = 3) +
  geom_point(data = hybr_pop_riv, aes(x = lon, y = lat, group = 1, fill = Sal_index), shape = 21, size = 3) +
  scale_fill_gradient(low = "yellow", high = "red") 
  
Pl_Sal_index
```

## Анализ связи степени смешанности с соленостью.

Для демонстрации связи зависимых переменных ($md_{inv}$ или $P_{hybr}$) с бинарной оценкой солености были подобраны следующие модели:

$$
md_{inv_i} = s(Ptros) + b_0 + I_{normal}b_1 + \varepsilon_i \ [Eq \ 1]
$$


$$
P_{hybr_i} = s(Ptros) + b_0 + I_{normal}b_1 + \varepsilon_i \ [Eq \ 2]
$$

**Пояснения.** Поскольку $md_{inv}$ и $P_{hybr}$ зависят о $Ptros$, то моделировать связь с соленостью исходных значений  $md_{inv}$ и $P_{hybr}$ нельзя. Для того, чтобы убрать влияние  $Ptros$, в модель вводится непараметрическая сглаживающая функция (GAM smoother) $s(Ptros)$. Следующий член модели, $b_0 + I_{normal}b_1$, описывает связь "остатков" от сглаживающей функции с бинарной оценкой солености. Переменная-селектор (dummy variable) $I_{normal}$   принимает значение 0, если рассматривается группа "brackish" (базовый уровень в модели), или 1, если рассматривается уровень "normal". 

Обе указанные модели были основаны на beta-распределении зависимой величины. 

Для обеих зависимых переменных было выявлено статистически значимое влияние бинарного фактора Salinity (Табл. 3, 4).

```{r}
library(broom)
Mod1 <- gam(md_1 ~ s(Ptros) + Salinity, data = hybr_pop_riv, family = "betar")

kable(tidy(Mod1, parametric = TRUE), caption = "Таблица 3. Результаты регрессионного анализа $md_{inv}$ в зависимости от фактора Salinity")

```



```{r}

Mod2 <- gam(P_hybr ~ s(Ptros) + Salinity, data = hybr_pop_riv, family = "betar")

kable(tidy(Mod2, parametric = TRUE), caption = "Таблица 4. Результаты регрессионного анализа $P_{hybr}$ в зависимости от фактора Salinity" )

```


Обе модели предсказывают большую степень гибридизации (более высокие значения $P_{hybr}$ и более низкие значения $md_{inv}$) в популяциях из группы "brackish".


Более аккуратную оценку связи степени гибридизации с соленостью позволяет дать индекс солености Для этого анализа мы разделили материал  на две части.

1. *Обучающая часть*, включает все данные, собранные на побережье Мурмана, за исключением данных из Тюва губы. На этом материале будет подобрана модель, описывающая связь зависимой переменной ($md_{inv}$ или $P_{hybr}$) с индексом солености.


2. *Тестовая часть* включает только данные по Тюва губе. Если модель, подобранная на обучающей выборке, будет предсказывать величины  $md_{inv}$ и $P_{hybr}$ близкие к наблюдаемым значениям, то это будет веским свидетельством в пользу того, что модель работает.



$$
md_{inv_i} = s(Ptros) + b_0 + b_1Sindex + \varepsilon_i \ [Eq \ 3]
$$

$$
P_{hybr_i} = s(Ptros) + b_0 + b_1Sindex + \varepsilon_i \ [Eq \ 4]
$$
Обе указанные модели были основаны на beta-распределении зависимой величины. 

Результаты подбора моделей приведены в таблицах 5 и 6. 

```{r}
Mod3 <- gam(md_1 ~ s(Ptros) + Sal_index, data = hybr_pop_riv %>% filter(Region != "Tyuva") , family = "betar")

kable(tidy(Mod3, parametric = TRUE), caption = "Таблица 5. Результаты регрессионного анализа $md_{inv}$ в зависимости от индекса солености (Анализ основан на обучающей выборке)")


```



```{r}
Mod4 <- gam(P_hybr ~ s(Ptros) + Sal_index, data = hybr_pop_riv %>% filter(Region != "Tyuva") )

kable(tidy(Mod4, parametric = TRUE), caption = "Таблица 6. Результаты регрессионного анализа $P_{hybr}$ в зависимости от индекса солености (Анализ основан на обучающей выборке)")


```



Вычисленные для тестовой выборки (Тюва губа) предсказанные значения явно коррелируют с наблюдаемыми значениями зависимых переменных (Рис. 3). Наличие корреляции между наблюдаемыми и предсказанными значениями в тестовой выборке (данные которой не были использованы для построения модели) свидетельствует о работоспособности моделей.


```{r fig.cap="Рисунок 3. Соотношение наблюдаемых и предсказанных моделями значений переменных отклика для тестовой выборки. На обеих частях линия отражает зависимость Y=X."}
Tyuva <- hybr_pop_riv %>% filter(Region == "Tyuva")

Tyuva$Predicted_md_1 <- predict(Mod3, newdata = Tyuva, type = "response")
Tyuva$Predicted_P_hybr <- predict(Mod4, newdata = Tyuva, type = "response")

Pl_md <- ggplot(Tyuva, aes(x = md_1, y = Predicted_md_1)) + geom_point() + geom_abline() + labs(x = "Наблюдаемое значение 1-md", y = "Предсказанное моделью значение") 

Pl_Phybr <- ggplot(Tyuva, aes(x = P_hybr, y = Predicted_P_hybr)) + geom_point() + geom_abline() + labs(x = "Наблюдаемое значение P_hybr", y = "Предсказанное моделью значение")

library(cowplot)

plot_grid(Pl_md, Pl_Phybr )

```





Для обобщенного описания связи степени генетической смешанности с соленостью были подобраны  модели аналогичные моделям $[Eq \ 3]$ и $[Eq \ 4]$, но на всем материале, без разделения на обучающую и тестовую выборки. Параметры моделей  приведены в таблицах 7 и 8.



```{r}
Mod5 <- gam(md_1 ~ s(Ptros) + Sal_index, data = hybr_pop_riv , family = "betar")

kable(tidy(Mod5, parametric = TRUE), caption = "Таблица 7. Результаты регрессионного анализа $md_{inv}$ в зависимости от индекса солености (Анализ основан всех имеющихся данных)")


```



```{r}
Mod6 <- gam(P_hybr ~ s(Ptros) + Sal_index, data = hybr_pop_riv  )

kable(tidy(Mod6, parametric = TRUE), caption = "Таблица 8. Результаты регрессионного анализа $P_{hybr}$ в зависимости от индекса солености (Анализ основан на всех имеющихся данных)")


```



```{r fig.cap="Рисунок +. Визуализация модели, построенной на всех данных " }
My_data <- expand.grid(Ptros = seq(0,1,0.01), Sal_index = seq(min(hybr_pop_riv$Sal_index), max(hybr_pop_riv$Sal_index), 1 ), Region = unique(hybr_pop_riv$Region))

My_data$Predicted <- predict(Mod5, newdata = My_data, type = "response")

ggplot(My_data, aes(x = Ptros, y = Predicted, color = Sal_index, group = Sal_index)) + geom_line() + scale_color_gradient(low = "yellow", high = "red") + geom_point(data = hybr_pop_riv, aes(y = md_1, fill = Sal_index, shape = Region), shape = 21, color = "black", size = 4) + scale_fill_gradient(low = "yellow", high = "red")  + facet_wrap(~Region) + labs(y = "1-md")
```


```{r fig.cap="Рисунок +. Визуализация модели, построенной на всех данных " }
My_data <- expand.grid(Ptros = seq(0,1,0.01), Sal_index = seq(min(hybr_pop_riv$Sal_index), max(hybr_pop_riv$Sal_index), 1 ), Region = unique(hybr_pop_riv$Region))

My_data$Predicted <- predict(Mod6, newdata = My_data, type = "response")

ggplot(My_data, aes(x = Ptros, y = Predicted, color = Sal_index, group = Sal_index)) + geom_line() + scale_color_gradient(low = "yellow", high = "red") + geom_point(data = hybr_pop_riv, aes(y = P_hybr, fill = Sal_index, shape = Region), shape = 21, color = "black", size = 4) + scale_fill_gradient(low = "yellow", high = "red")  + facet_wrap(~Region) + labs(y = "Доля гибридов в популяции (P_hybr)")
```











<!-- ```{r} -->

<!-- Mod_tyuv <- gam(md_1 ~ s(Ptros) + Sal_index, data = Tyuva)  -->

<!-- Tyuva$Mod_tyuv_resid <-  resid(Mod_tyuv) -->

<!-- ``` -->



Для визуализации связи степени смешанности с индексом солености была подобрана модель, которая описывает связь $md_{inv}$ с $Ptros$ $[Eq \ 5]$. Остатки от этой модели характеризуют значение $md_{inv}$, освобожденное от влияния $Ptros$. Рисунок 4 демонстрирует связь остатков индексом солености: чем ниже индекс солености, тем большая смешанность наблюдается в популяции.  

$$
md_{inv_i} = s(Ptros) + b_0 + \varepsilon_i \ [Eq \ 5]
$$

```{r fig.cap="Рисунок 4. Связь степени генетической смешанности и индекса солености"}
Mod_all <- gam(md_1 ~ s(Ptros), data = hybr_pop_riv, family = "betar")

hybr_pop_riv$Resid_Mod_all <- resid(Mod_all)

ggplot(hybr_pop_riv, aes(x = Sal_index, y = Resid_Mod_all)) + geom_point(data = hybr_pop_riv, aes(color = Salinity), size = 2) + geom_smooth(method = "lm") + geom_hline(yintercept = 0) + labs(x = "Индекс солености", y = "Остатки для 1-md")

```

На рисунке 5 приведено все то же самое, но нарисованы только точки для Кольского залива и Тюва губы.


```{r fig.cap="Рисунок 5. Связь степени генетической смешанности и индекса солености для популяций из Кольского залива и Тюва губы"}
ggplot(hybr_pop_riv, aes(x = Sal_index, y = Resid_Mod_all)) + geom_point(data = hybr_pop_riv %>% filter(Region %in% c("Kola", "Tyuva")), aes(color = Salinity, shape = Region), size = 3) + geom_smooth(method = "lm") + geom_hline(yintercept = 0) + labs(x = "Индекс солености", y = "Остатки для 1-md")

```



Если оценивать генетическую смешанность в терминах доли гибридов, то результат аналогичен предыдущему.  

```{r fig.cap="Рисунок 6. Связь доли гибридов (за вычитом вляияния Ptros) и индекса солености"}
Mod_all_2 <- gam(P_hybr ~ s(Ptros), data = hybr_pop_riv, family = "betar")

hybr_pop_riv$Resid_Mod_all_2 <- resid(Mod_all_2)

ggplot(hybr_pop_riv, aes(x = Sal_index, y = Resid_Mod_all_2)) + geom_point(aes(color = Salinity), size = 2) + geom_smooth(method = "lm") + geom_hline(yintercept = 0) + labs(x = "Индекс солености", y = "Остатки для доли гибридов")

```



Не знаю, поможет ли такая картинка, но подумайте. 


<!-- ```{r fig.cap="Рис. 7. Значения индекса солености в разных точках. Звездочки маркируют устья рек. "} -->

<!-- hybr_pop_riv <- hybr_pop_riv[order(hybr_pop_riv$Resid_Mod_all, decreasing = T), ] -->
<!-- Murm_region_map +  -->
<!--   geom_point(data = rivers, aes(x = Lon, y = Lat, group = 1), shape = 8, size = 3) + -->
<!--   geom_point(data = hybr_pop_riv, aes(x = lon, y = lat, group = 1, size = Resid_Mod_all, fill = Resid_Mod_all), shape = 21) + -->
<!--   scale_fill_gradient(low = "yellow", high = "red")  -->

<!-- ``` -->





```{r fig.cap="Рис. 7. Значения индекса солености в разных точках. Звездочки маркируют устья рек. Чем желтее точка, тем больше генетическая смешанность. Размер точки информации не несет, он использован только для того, чтобы разделить накладывающиеся друг на друга точки."}

hybr_pop_riv <- hybr_pop_riv[order(hybr_pop_riv$Resid_Mod_all, decreasing = T), ]

Pl_md <- 
Kola_bay_map + 
  geom_point(data = rivers, aes(x = Lon, y = Lat, group = 1), shape = 8, size = 3) +
  geom_point(data = hybr_pop_riv, aes(x = lon, y = lat, group = 1, size = Resid_Mod_all, fill = Resid_Mod_all), shape = 21) +
  scale_fill_gradient(low = "yellow", high = "black") +
  ggtitle("1-md") +
  guides(size = "none") +
  labs(fill = "Residuals")
  

hybr_pop_riv <- hybr_pop_riv[order(hybr_pop_riv$Resid_Mod_all_2, decreasing = T), ]

 
Pl_hybr <- 
Kola_bay_map + 
  geom_point(data = rivers, aes(x = Lon, y = Lat, group = 1), shape = 8, size = 3) +
  geom_point(data = hybr_pop_riv, aes(x = lon, y = lat, group = 1, size = (Resid_Mod_all_2), fill = Resid_Mod_all_2), shape = 21) +
  scale_fill_gradient(low = "black", high = "yellow") +
  ggtitle("P_hybr") +
  guides(size = "none") +
  labs(fill = "Residuals")
  
plot_grid(Pl_md, Pl_hybr)

```



