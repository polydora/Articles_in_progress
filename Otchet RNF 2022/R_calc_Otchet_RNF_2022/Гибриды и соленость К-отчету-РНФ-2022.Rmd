---
title: Гибридизация *M.trossulus* и *M.edulis* в разных условиях солености
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
  opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```


```{r}
library(readxl)
library(ggplot2)
library(dplyr)
library(mgcv)
library(ggrepel)
library(latex2exp) #Пакет, который позволяет вставлять латеховские формулы в ggplot


theme_set(theme_bw())

hybr <- read_excel("Data/hybrids_BS_2022.xlsx", na = "NA")
hybr$region <- factor(hybr$region)

hybr <- hybr %>% filter(Exclude == 0)


rivers <- read_excel("Data/rivers_BS.xlsx")
rivers$Drainage_Area <- as.numeric(rivers$Drainage_Area)
rivers$Lat <- as.numeric(rivers$Lat)
rivers$Lon <- as.numeric(rivers$Lon)



# Доля гибридов в сборах

hybr_pop <- 
  hybr %>% group_by(ID) %>% summarise(lat = mean(N), lon = mean(E), Year = mean(year), Region = unique(region), Ptros = mean(str), P_hybr = mean(str > 0.1 & str < 0.9), md = 1 - (sd(str))^2/(Ptros*(1-Ptros)), md_1 = 1-md) 

# %>% filter(Ptros<0.9 & Ptros>0.1)



# hybr_pop$Region <- factor(hybr_pop$Region, levels = c("West_coast",  "Kola",  "Tyuva", "East_coast" ))

```




```{r}

# Функция для определения расстояния до ближайшего объекта
nearest_dist <- function(XY, objects = river, x.name = "Lon", y.name = "Lat"){
  
  XY1 <-as.numeric(XY[,1])
  XY2 <- as.numeric(XY[,2])
  dist <- (acos(sin(XY1*pi/180)*sin(objects[ ,y.name]*pi/180) + cos(XY1*pi/180)*cos(objects[ ,y.name]*pi/180)*cos(XY2*pi/180 - objects[ ,x.name]*pi/180)) * 6371)
  
  MD <- data.frame(Min_dist = min(dist))
  cbind(objects[which(dist == min(dist)), ], MD)
  
}


#  distance to mouth of the neares river 

df_river <- nearest_dist(XY = hybr_pop[1, c("lat", "lon")], objects = rivers)

df_river[1,] <- NA

for(i in 1:nrow(hybr_pop)) {
  df_river[i,] <- nearest_dist(XY = hybr_pop[i, c("lat", "lon")], objects = rivers)
  df_river$ID[i] <- as.character(hybr_pop$ID)[i]
}


names(df_river) <- c( "River",  "Drainage_Area",  "Lat_river", "Lon_river", "Min_dist_river", "ID" )



hybr_pop_riv <- merge(hybr_pop, df_river, by = "ID")

hybr_pop_riv$Min_dist_river <- round(hybr_pop_riv$Min_dist_river, 2)

hybr_pop_riv$Drainage_Area_1 <- 1/hybr_pop_riv$Drainage_Area


hybr_pop_riv$Sal_index <- round( with(hybr_pop_riv, sqrt(rank(Min_dist_river) * rank(Drainage_Area_1)) ))

# hybr_pop_riv %>% filter(P_hybr > 0.5)

```





$$
GAM: \ Phybr_i = te(Ptros, Sindex) + b_0  + \varepsilon_i 
$$


```{r}
# hybr_pop_riv$Fi_hybr <- 2*asin(sqrt(hybr_pop_riv$P_hybr)) * 180/pi





Mod7 <- gam(P_hybr ~ te(Ptros, Sal_index), data = hybr_pop_riv, family = "betar", method = "REML") 


# , k = c(5, 10)
# , knots=list(Ptros = c(0.3, 0.7))

summary(Mod7)

# gam.check(Mod7)

```



```{r}
library(scales)
library(ggnewscale)



hybr_pop_riv <- 
hybr_pop_riv %>% mutate(Ptros_class = case_when(
Ptros <= 0.25 ~ 1,
Ptros <= 0.5 & Ptros > 0.25 ~ 2,
Ptros <= 0.75 & Ptros > 0.5 ~ 3,
Ptros > 0.75  ~ 4
))


# My_data <- hybr_pop_riv %>% group_by(Ptros_class) %>% do(data.frame(Ptros = mean(.$Ptros), Sal_index = seq(min(.$Sal_index), max(.$Sal_index), length.out = 100)))

# My_data <- expand.grid(Ptros = seq(0, 1, 0.01), Sal_index = seq(min(hybr_pop_riv$Sal_index), max(hybr_pop_riv$Sal_index), 1))


My_data <- expand.grid(Ptros = seq(0, 1, 0.01), Sal_index = quantile(hybr_pop_riv$Sal_index, probs = c(0.1,  0.9)))


predicted_Phybr <-  predict(Mod7, newdata = My_data, type = "response", se.fit = T)

My_data$Predicted_Phybr <- predicted_Phybr$fit

My_data$SE <- predicted_Phybr$se.fit




Pl <- 
ggplot(My_data, aes(x = Ptros, y = Predicted_Phybr, group = Sal_index)) + 
  geom_line(aes(linetype = factor(Sal_index) ), size = 0.5) + 
  geom_point(data = hybr_pop_riv, aes(y = P_hybr, fill = Sal_index), shape = 21, size = 3) + 
  scale_fill_gradient(high = "darkblue", low = "white") + 
  scale_linetype_manual(values = c(2, 1)) + 
  # scale_color_gradient(high = "darkblue", low = "gray") + 
  labs(x = "Ptros", y = "Доля гибридов", fill = "Индекс \nсолености") + 
  guides(color = "none", linetype = "none") +
  theme(legend.position = "right") +
  coord_fixed(ratio = 2, xlim = NULL, ylim = c(0, 0.45), expand = F, clip = "off") +
  theme(legend.title = element_text(size = 6), legend.text = element_text(size = 6), axis.text = element_text(size = 12), axis.title = element_text(size = 12), panel.border = element_rect(fill = NA), legend.key.size = unit(1,"line") )

Pl

ggsave(filename = "Hybrids_vs_salinity.png", Pl, dpi = 400, width = 15, units = "cm")




  # My_data$Predicted_Phybr <- predict(Mod7, newdata = My_data, type = "response")
# hybr_pop_riv$dummy_P_hybr <- predict(Mod7, newdata = hybr_pop_riv, type = "response")
# 
# My_data$Predicted_Phybr_rank <- rank(My_data$Predicted_Phybr)
# hybr_pop_riv$P_hybr_rank <- rank(hybr_pop_riv$P_hybr)
# 
# 
# ggplot(My_data, aes(x = Ptros, y = Sal_index)) + 
#   geom_tile(aes(fill = Predicted_Phybr))+
#   scale_fill_gradient(low = "yellow", high = "red") +
#   labs(fill = "Частота гибридов") + 
#   new_scale("fill") +
#   geom_tile(aes(fill = Predicted_Phybr)) +
#   scale_fill_continuous(low = "yellow", high = "red") +
#   guides(fill = "none") + 
#   new_scale("fill") +
#   geom_point(data = hybr_pop_riv, aes(fill = P_hybr_rank), size = 4, shape = 21, position = position_jitter(width = 0.01, height = 0.01)) +
#   scale_fill_continuous(low = "yellow", high = "red") + 
#   geom_contour(aes(z = Predicted_Phybr), color = "blue", bins = 8) +
#   guides(fill = "none") + 
#   labs(x = "Ptros", y = "Индекс солености") +
#   theme(legend.position = "bottom")

  
  
```
 
